{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"matbii","text":""},{"location":"advanced/","title":"Advanced","text":"<p>The advanced guide presents some advanced topics and is experimental/a work in progress. Much of the guide will refer you to the <code>icua</code> documentation (which is a work in progress) as the <code>icua</code> package contains the relevant classes/APIs that enable deeper customisation. </p>"},{"location":"advanced/#custom-entry-points","title":"Custom Entry Points","text":"<p>The default entry points does lots, but you may want to use your own - especially if you have added some extra features! </p>"},{"location":"advanced/#custom-tasks","title":"Custom Tasks","text":"<p>Currently only three tasks are implemented in <code>matbii</code>, you may with to implement more tasks, the current task implementations should provide some inspiration, this guide will assist you in getting to know what is required using the current task as a running example. </p>"},{"location":"advanced/#custom-devices","title":"Custom Devices","text":"<p><code>matbii</code> supports the usual periferal devices (mouse, keyboard) and also eyetracking. This guide will show you how to implement a new custom device - note that you will need a python binding/SDK to your device.</p>"},{"location":"advanced/custom_devices/","title":"Custom Devices","text":""},{"location":"advanced/custom_devices/#avatars","title":"Avatars","text":"<p>An <code>Avatar</code> is a type of <code>Agent</code> that represents the user. It receives user input (e.g. mouse and keyboard), takes actions on the users behalf (as a result of this input) and displays the state of the environment to the user. This is how <code>matbii</code> includes a user in the agent simulation. </p>"},{"location":"advanced/custom_devices/#devices-iosensors","title":"Devices &amp; IOSensors","text":"<p>An <code>IOSensor</code> abstracts away from the underlying device implementation. The device class must follow the <code>IOSensor</code> API and contain the following methods: </p> <ul> <li><code>get_nowait() -&gt; List[Event]</code>: poll for latest events</li> <li><code>async get() -&gt; List[Event</code>: poll for latest events, waits until an event is avaliable (call as <code>await sensor.get()</code>)</li> <li><code>start()</code> : start/setup the device</li> <li><code>stop()</code> : stop/clean up the device</li> </ul> <p>The <code>get</code> or <code>get_nowait</code> methods will be polled periodically (during the avatar's cycle) and converted into observations for the agent.  <code>start</code> will be called during <code>on_add</code> and <code>stop</code> will be called during <code>on_remove</code>. An <code>IOSensor</code> is attached to the avatar agent in the usual way via <code>add_component</code>.</p> <p>If you wish to add support for a new device, see <code>EyetrackerIOSensor</code> for inspiration.</p> Example <pre><code>from star_ray.agent import AgentRouted, IOSensor\nfrom star_ray.event import MouseMotionEvent\n\nclass StubAgent(AgentRouted):\n\n    @observe\n    def on_mouse_event(self, mouse_event: MouseMotionEvent):\n        print(mouse_event) # do something with the mouse event\n\nclass StubDevice:\n\n    def get_nowait(self) -&gt; List[Event]:\n        # get the mouse position from an actual device\n        return [MouseMotionEvent(position=(0,0))]\n\n    def start(self):\n        pass \n\n    def stop(self):\n        pass\n\nsensor = IOSensor(StubDevice())\nagent = StubAgent([sensor], [])\n</code></pre>"},{"location":"advanced/custom_entry_points/","title":"Custom Entry Points","text":"<p>COMING SOON</p>"},{"location":"advanced/custom_tasks/","title":"Custom Tasks","text":"<p>COMING SOON</p>"},{"location":"advanced/temp/","title":"Temp","text":"<p>However if you wish to implement a custom entry point, or wish to understand the inner workings of <code>matbii</code> a bit better then read on. </p>"},{"location":"advanced/temp/#guidance","title":"Guidance","text":"<p>One class of experiments that <code>matbii</code> aims to support are those relating to attention guidance. This is done via with guidance agents. The goal of these agents is to assist the user in managing or completing one or more tasks by provide guidance or feedback to them in some form. As usual, the guidance agents follow a sense/decide/act loop:</p> <ul> <li>Sense: gather information about their environment via their sensors (e.g. user input and the state of the <code>matbii</code> UI)</li> <li>Decide: whether to display guidance based on this information.</li> <li>Act: Provide feedback to the user e.g. by modifying the UI, playing a sound, etc.</li> </ul> <p>Of course you are free to implement an agent that aims to acheive this goal how ever you'd like, but <code>matbii</code> has support for task-based visual guidance with <code>icua.agent.GuidanceAgent</code>. This class defines some useful methods and a convenient sensors-actuator API which will make developing guidance agents more straight-forward. </p>"},{"location":"advanced/temp/#sensors-task-acceptability","title":"Sensors &amp; Task Acceptability","text":"<p>We assume that each task may be in one of two states - acceptable or unacceptable. Acceptable means that the user does not need to do anything for this task. Unacceptable means that the attention of the user is required and that there is likely some action they need to take - this is when the guidance agent (may) need to intervene and provide feedback to the user. </p> <p>To keep things modular, task acceptability is tracked and managed by the agent's sensors, any sensor which implements: icua.agent.TaskAcceptabilitySensor may be used for this. </p> <p>Each of the tasks implemented in <code>matbii</code> has an associated task acceptability sensor:</p> <ul> <li><code>SystemMonitoringTaskAcceptabilitySensor</code></li> <li><code>ResourceManagementTaskAcceptabilitySensor</code></li> <li><code>TrackingTaskAcceptabilitySensor</code></li> </ul>"},{"location":"advanced/temp/#guidance-decision-making","title":"Guidance decision making","text":"<p><code>GuidanceAgent</code> defines four methods which will be called as a direct result of a change in acceptability or in activity. Task activity determines whether the task is current active in the environment. A task may be considered inactive if it is not accepting user interaction for what ever reason (e.g. if by design it not currently being displayed to the user). </p> <ul> <li><code>on_acceptable(self, task: str)</code></li> <li><code>on_unacceptable(self, task: str)</code></li> <li><code>on_active(self, task: str)</code></li> <li><code>on_inactive(self, task: str)</code></li> </ul> <p>where <code>task</code> is the name of the task. Guidance agents also automatically record user input which is made accessible via the <code>get_latest_user_input(self, event_type: type, n: int = 1) -&gt; Iterator[Event]</code> method, see devices and user input for details on which <code>event_types</code> are accepted.</p> Example <code>agent.py</code><code>main.py</code> <pre><code>from icua.agent import GuidanceAgent\nfrom icua.event import MouseMotionEvent\n\nclass MyGuidanceAgent(GuidanceAgent):\n\n    def on_unacceptable(self, task: str):\n        # assumes task is always active\n        target = self.get_latest_user_input(MouseMotionEvent)[0].target\n        if task in target: # the user is attending this task\n            self.guidance_actuator.hide_guidance()\n        else:\n            self.guidance_actuator.show_guidance()\n</code></pre> <p>from .agent import MyGuidanceAgent, MyGuidanceActuator, MyGuidanceSensor from .tasks import MyTask</p>"},{"location":"advanced/temp/#actuators-visual-feedback","title":"Actuators &amp; Visual Feedback","text":"<p>COMING SOON</p>"},{"location":"advanced/temp/#counter-factual-guidance","title":"Counter-factual guidance","text":"<p>COMING SOON</p>"},{"location":"advanced/temp/#multi-tasking","title":"Multi-tasking","text":"<p>COMING SOON</p>"},{"location":"advanced/temp/#multi-task-environment","title":"Multi-task Environment","text":"<p>COMING SOON</p>"},{"location":"advanced/temp/#task-control","title":"Task control","text":"<p>COMING SOON</p>"},{"location":"advanced/temp/#post-analysis","title":"Post-Analysis","text":"<p>COMING SOON</p>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#install","title":"Install","text":"<p><code>matbii</code> is avaliable as a pypi package and can be installed with pip (recommended): <pre><code>pip install matbii\n</code></pre> or can easily be installed from source (for the latest pre-release updates): <pre><code>git clone https://github.com/dicelab-rhul/matbii.git\npip install ./matbii\n</code></pre></p> <p>Note</p> <p>It is always a good idea to use the latest version of <code>icua</code> to get the latest fixes and features, update with:  <pre><code>pip install -U icua\n</code></pre></p>"},{"location":"getting_started/#run","title":"Run","text":"<p>Run with default configuration: <pre><code>python -m matbii\n</code></pre></p> Errors on Windows <p>You might encounter the following error when running for the first time:</p> <pre><code>ERROR: 'star-ray-pygame' requires a cairo installation which may not be installed automatically on some systems.\nCause:\n    no library called \"cairo-2\" was found\n    no library called \"cairo\" was found\n    no library called \"libcairo-2\" was found\n    cannot load library 'libcairo.so.2': error 0x7e.  Additionally, ctypes.util.find_library() did not manage to locate a library called 'libcairo.so.2'\n    cannot load library 'libcairo.2.dylib': error 0x7e.  Additionally, ctypes.util.find_library() did not manage to locate a library called 'libcairo.2.dylib'\n    cannot load library 'libcairo-2.dll': error 0x7e.  Additionally, ctypes.util.find_library() did not manage to locate a library called 'libcairo-2.dll'\n\nACTION REQUIRED: Please ensure the required binaries are installed and accessible via your PATH environment variable.\n    &gt;&gt; On Windows: Install the latest GTK-3 runtime from: https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer/releases, use the default install path!\n    &gt;&gt; See 'star-ray-pygame' README for more information: https://github.com/dicelab-rhul/star-ray-pygame.\n</code></pre> <p>To remedy: install the latest GTK-3 runtime. Make sure to use the default install directory so that <code>matbii</code> can find the installation.</p>"},{"location":"getting_started/#default-entry-point","title":"Default entry point","text":"<p>The default entry point for <code>matbii</code> (<code>python -m matbii &lt;OPTIONS&gt;</code> which will use <code>matbii.__main__.py</code>) is highly configurable and a good place to start. A full list of command line arguments is given below. The most important option is <code>-c</code> which specifies a path to a configuration file (details on next page).</p>"},{"location":"getting_started/#command-line-arguments","title":"Command line arguments","text":"Option Description <code>-c CONFIG</code>, <code>--config CONFIG</code> Path to configuration file. <code>-p PARTICIPANT</code>, <code>--participant PARTICIPANT</code> ID of the participant. <code>-e EXPERIMENT</code>, <code>--experiment EXPERIMENT</code> ID of the experiment. <p>All options except <code>-c</code> will override some option that is specified in the configuation file.</p> <p>See next page for details on the main configuration file.</p> Custom entry points (advanced) <p>Some experiments may require more advanced setups and you may wish to define your own entry point. The <code>__main__.py</code> file should serve as inspiration for this. For more details see the documentation for advanced users. It is recommended to read on to see what is offered by default before attempting to build you own entry point.</p>"},{"location":"getting_started/configuration/","title":"Configuration","text":"<p><code>matbii</code> is highly configurable thanks to the modular agent-based design of <code>icua</code>. Various files are used in the configuration of tasks and experiments, these files are described in the sections below. See this example for usage with the default entry point.</p>"},{"location":"getting_started/configuration/#main-configuration","title":"Main Configuration","text":"<p>Matbii can be configured using a <code>.json</code> file.</p> <p>The path of this file is supplied as <code>-c CONFIG PATH</code>, for example:</p> <pre><code>python -m matbii -c ./experiment-config.json\n</code></pre> <p>The default entry point (main) configuration has sections corresponding to a specific aspect of the simulation. Not all options need to be specified and most have reasonable default values.</p> ExperimentConfiguration <p>Configuration relating to the experiment to be run.</p> <ul> <li> <p><code>id (string | null) = null:</code> The unique ID of this experiment.</p> </li> <li> <p><code>path (string) = './':</code> The full path to the directory containing task configuration files. If this is a relative path it is relative to the current working directory.</p> </li> <li> <p><code>duration (integer) = -1:</code> The duration (in seconds) of this experiment (the simulation will close after this time), a negative value will leave the simulation running forever.</p> </li> <li> <p><code>enable_video_recording (boolean) = False:</code> Whether to begin a screen recording of the experiment when the simulation starts, the video will be saved to the logging path when the experiment ends.</p> </li> <li> <p><code>enable_tasks (array) = ['system_monitoring', 'resource_management', 'tracking']:</code> Which tasks to enable at the start of the simulation.</p> </li> <li> <p><code>meta (object) = {}:</code> Any additional meta data you wish to associate with this experiment.</p> </li> </ul> Example <pre><code>\"experiment\": {\n  \"id\": null,\n  \"path\": \"./\",\n  \"duration\": -1,\n  \"enable_video_recording\": false,\n  \"enable_tasks\": [\n    \"system_monitoring\",\n    \"resource_management\",\n    \"tracking\"\n  ],\n  \"meta\": {}\n}\n</code></pre> ParticipantConfiguration <p>Configuration relating to the participant (or user).</p> <ul> <li> <p><code>id (string | null) = null:</code> The unique ID of the participant that is taking part in the experiment.</p> </li> <li> <p><code>meta (object) = {}:</code> Any additional meta data you wish to associate with the participant.</p> </li> </ul> Example <pre><code>\"participant\": {\n  \"id\": null,\n  \"meta\": {}\n}\n</code></pre> GuidanceConfiguration <p>Configuration relating to guidance that may be provided to a user.</p> <ul> <li> <p><code>enable (boolean) = True:</code> Whether to enable guidance, if this is False then no guidance agent will be created.</p> </li> <li> <p><code>counter_factual (boolean) = False:</code> Whether to show guidance to the user, if False then guidance agent will be configured NOT to display guidance but will still take actions for logging purposes (if they support this).</p> </li> </ul> Example <pre><code>\"guidance\": {\n  \"enable\": true,\n  \"counter_factual\": false\n}\n</code></pre> WindowConfiguration <p>Window Configuration.</p> <ul> <li> <p><code>x (integer) = 0:</code> <li> <p><code>y (integer) = 0:</code> <li> <p><code>width (integer) = 640:</code> <li> <p><code>height (integer) = 480:</code> <li> <p><code>title (string) = 'window':</code> <li> <p><code>resizable (boolean) = False:</code> <li> <p><code>fullscreen (boolean) = False:</code> <li> <p><code>background_color (string) = '#ffffff':</code> Example <pre><code>\"window\": {\n  \"x\": 0,\n  \"y\": 0,\n  \"width\": 640,\n  \"height\": 480,\n  \"title\": \"window\",\n  \"resizable\": false,\n  \"fullscreen\": false,\n  \"background_color\": \"#ffffff\"\n}\n</code></pre> EyetrackingConfiguration <p>Configuration relating to eyetracking.</p> <ul> <li> <p><code>uri (string | null) = null:</code> The eye tracker address (example: <code>'tet-tcp://172.28.195.1'</code>). If left unspecified <code>matbii</code> will attempt to find an eye tracker. For details on setting up eye tracking, consult the wiki.</p> </li> <li> <p><code>sdk (string) = 'tobii':</code> The eye tracking SDK to use, current options are: <code>['tobii']</code>.</p> </li> <li> <p><code>enabled (boolean) = False:</code> Whether eye tracking is enabled.</p> </li> <li> <p><code>moving_average_n (integer) = 5:</code> The window size to used to smooth eye tracking coordinates.</p> </li> <li> <p><code>velocity_threshold (number) = 0.5:</code> The threshold on gaze velocity which will determine saccades/fixations. This is defined in screen space, where the screen coordinates are normalised in the range [0,1]. IMPORTANT NOTE: different monitor sizes may require different values, unfortunately this is difficult to standardise without access to data on the gaze angle (which would be monitor size independent).</p> </li> </ul> Example <pre><code>\"eyetracking\": {\n  \"uri\": null,\n  \"sdk\": \"tobii\",\n  \"enabled\": false,\n  \"moving_average_n\": 5,\n  \"velocity_threshold\": 0.5\n}\n</code></pre> LoggingConfiguration <p>Configuration relating to logging (including event logging).</p> <ul> <li> <p><code>level (string) = 'INFO':</code> The logging level to use: ['DEBUG', 'INFO', 'WARNING', 'ERROR'], this will not affect event logging.</p> </li> <li> <p><code>path (string) = './logs/':</code> The path to the directory where log files will be written.</p> </li> </ul> Example <pre><code>\"logging\": {\n  \"level\": \"INFO\",\n  \"path\": \"./logs/\"\n}\n</code></pre> UIConfiguration <p>Configuration relating to rendering and the UI.</p> <ul> <li> <p><code>size (array) = [810, 680]:</code> The width and height of the canvas used to render the tasks. This should fully encapsulate all task elements. If a task appears to be off screen, try increasing this value.</p> </li> <li> <p><code>offset (array) = [0, 0]:</code> The x and y offset used when rendering the root UI element, can be used to pad the top/left of the window.</p> </li> </ul> Example <pre><code>\"ui\": {\n  \"size\": [\n    810,\n    680\n  ],\n  \"offset\": [\n    0,\n    0\n  ]\n}\n</code></pre> <p>The default configuration file can be found below, you can simply copy it and modify as needed.</p> default-configuration.json <pre><code>{\n  \"experiment\": {\n    \"id\": null,\n    \"path\": \"./\",\n    \"duration\": -1,\n    \"enable_video_recording\": false,\n    \"enable_tasks\": [\n      \"system_monitoring\",\n      \"resource_management\",\n      \"tracking\"\n    ],\n    \"meta\": {}\n  },\n  \"participant\": {\n    \"id\": null,\n    \"meta\": {}\n  },\n  \"guidance\": {\n    \"enable\": true,\n    \"counter_factual\": false\n  },\n  \"window\": {\n    \"x\": 0,\n    \"y\": 0,\n    \"width\": 810,\n    \"height\": 680,\n    \"title\": \"icua matbii\",\n    \"resizable\": false,\n    \"fullscreen\": false,\n    \"background_color\": \"#ffffff\"\n  },\n  \"eyetracking\": {\n    \"uri\": null,\n    \"sdk\": \"tobii\",\n    \"enabled\": false,\n    \"moving_average_n\": 5,\n    \"velocity_threshold\": 0.5\n  },\n  \"logging\": {\n    \"level\": \"INFO\",\n    \"path\": \"./logs/\"\n  },\n  \"ui\": {\n    \"size\": [\n      810,\n      680\n    ],\n    \"offset\": [\n      0,\n      0\n    ]\n  }\n}\n</code></pre> <p>Custom entry points</p> <p>The main configuration outlined here is used in the default entry point (<code>__main__.py</code>), but may also be useful for custom entry points.</p>"},{"location":"getting_started/configuration/#task-configuration","title":"Task Configuration","text":"<p>Along with the main configuration which provides some general options for configuring experiments the tasks themselves can be configured. Task configuration is independent of the entry point. </p> <p>There are two types of task configuration files:</p> <ul> <li>State files (<code>.json</code>)</li> <li>Schedule files (<code>.sch</code>)</li> </ul> <p>For a single experiment these files will all be placed in a single directory, for example:  <pre><code>experiment/\n \u251c\u2500resource_management.json  \n \u251c\u2500resource_management.sch  \n \u251c\u2500system_monitoring.json  \n \u251c\u2500system_monitoring.sch  \n \u251c\u2500tracking.json  \n \u2514\u2500tracking.sch\n</code></pre></p> <p>The directory <code>experiment</code> above should be used as the <code>experiment.path</code> option in the main configuration file. You may or may not decide to place the main configuration inside this directory. Either way, it is better to provide an absolute path in <code>experiment.path</code> to avoid issues with path resolution (recall that the configuration path is relative to the working directory - where <code>python -m matbii -c &lt;CONFIG&gt;</code> is run).</p>"},{"location":"getting_started/configuration/#naming-convention","title":"Naming convention","text":"<p>Each configuration file must be named after the task (as above): <code>resource_management</code>, <code>system_monitoring</code>, <code>tracking</code> with <code>.json</code> for state files and <code>.sch</code> for schedule files. These names are also used when enabling a task in the main configuration file.</p>"},{"location":"getting_started/configuration/#default-configuration","title":"Default configuration","text":"<p>All tasks have a default configuration which will be used in place of state or schedule if the file is not given. Each of the files above is overriding the default state or schedule for the corresponding task.</p>"},{"location":"getting_started/configuration/#state-files","title":"State files","text":"<p>State files contain values that determine the starting state of the task and influence how the task is displayed in the UI. Options are described below.</p> Resource Management Task Configuration <ul> <li><code>x (integer) = 260:</code> x position of the task</li> <li><code>y (integer) = 360:</code> y position of the task</li> <li><code>width (integer) = 540:</code> width of the task</li> <li><code>height (integer) = 300:</code> height of the task</li> <li><code>padding (integer) = 10:</code> padding surrounding the task</li> <li><code>pump_on_color (color) = \"#00ff00\":</code> color of pumps when in the <code>\"on\"</code> state</li> <li><code>pump_off_color (color) = \"#add9e6\":</code> color of pumps when in the <code>\"off\"</code> state</li> <li><code>pump_failure_color (color) = \"#ff0000\":</code> color of pumps when in the <code>\"failure\"</code> state</li> <li><code>stroke_color (color) = \"#000000\":</code> line colour</li> <li><code>stroke_width (integer) = 2:</code> line width</li> <li><code>show_tank_labels (boolean) = true:</code> whether to show textual labels next to each tank</li> <li><code>background_color (color) = \"#ffffff\":</code> background color of the tanks</li> <li><code>debug (boolean) = false:</code> whether to display debug information</li> <li><code>tank_capacity (dict):</code> See details below:</li> <li><code>tank_capacity.a (integer) = 2000:</code> capacity for tank a</li> <li><code>tank_capacity.b (integer) = 2000:</code> capacity for tank b</li> <li><code>tank_capacity.c (integer) = 1500:</code> capacity for tank c</li> <li><code>tank_capacity.d (integer) = 1500:</code> capacity for tank d</li> <li><code>tank_capacity.e (integer) = 1000:</code> capacity for tank e</li> <li><code>tank_capacity.f (integer) = 1000:</code> capacity for tank f</li> <li><code>tank_level (dict):</code> See details below:</li> <li><code>tank_level.a (integer) = 1000:</code> starting fuel level for tank a (&lt; tank_capacity.a)</li> <li><code>tank_level.b (integer) = 1000:</code> starting fuel level for tank b (&lt; tank_capacity.b)</li> <li><code>tank_level.c (integer) = 750:</code> starting fuel level for tank c (&lt; tank_capacity.c)</li> <li><code>tank_level.d (integer) = 750:</code> starting fuel level for tank d (&lt; tank_capacity.d)</li> <li><code>tank_level.e (integer) = 750:</code> starting fuel level for tank e (&lt; tank_capacity.e)</li> <li><code>tank_level.f (integer) = 750:</code> starting fuel level for tank f (&lt; tank_capacity.f)</li> <li><code>pump_state (dict):</code> See details below:</li> <li><code>pump_state.ab (str) = \"off\":</code> starting state of pump ab (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.ba (str) = \"off\":</code> starting state of pump ba (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.ca (str) = \"off\":</code> starting state of pump ca (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.ec (str) = \"off\":</code> starting state of pump ec (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.ea (str) = \"off\":</code> starting state of pump ea (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.db (str) = \"off\":</code> starting state of pump db (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.fd (str) = \"off\":</code> starting state of pump fd (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> <li><code>pump_state.fb (str) = \"off\":</code> starting state of pump fb (options <code>\"off\"</code>, <code>\"on\"</code>, <code>\"failure\"</code>)</li> </ul> System Monitoring Task Configuration <ul> <li><code>x (integer) = 0:</code> x position of the task</li> <li><code>y (integer) = 0:</code> y position of the task</li> <li><code>width (integer) = 240:</code> width of the task</li> <li><code>height (integer) = 330:</code> height of the task</li> <li><code>padding (integer) = 10:</code> padding surrounding the task</li> <li><code>debug (boolean) = false:</code> whether to display debug information</li> <li><code>show_keyboard_shortcuts (boolean) = false:</code> whether to display keyboard shortcuts</li> <li><code>font_size (integer) = 12:</code> font size</li> <li><code>stroke_width (integer) = 2:</code> line width</li> <li><code>light_state (list) = [0, 0]:</code> initial states of each light (options: 0 or 1)</li> <li><code>light_on_color (color) = \"#00ff00\":</code> color of light 1 when on</li> <li><code>light_failure_color (color) = \"#ff0000\":</code> color of light 2 when on</li> <li><code>light_off_color (color) = \"#add9e6\":</code> color of light 1 and 2 when off</li> <li><code>light_width (integer) = 75:</code> width of each light</li> <li><code>light_height (integer) = 50:</code> height of each light</li> <li><code>slider_num_increments (integer) = 11:</code> number of increments in each slider</li> <li><code>slider_state (list) = [5, 5, 5, 5]:</code> intial states of each slider (options: 0 to slider_num_increments-1)</li> <li><code>slider_width (integer) = 30:</code> width of each slider</li> <li><code>slider_height (integer) = 20:</code> height of each slider</li> <li><code>slider_background_color (color) = \"#add9e6\":</code> slider background color</li> <li><code>slider_color (color) = \"#4682b4\":</code> slider color</li> <li><code>slider_arrow_color (color) = \"#ffff00\":</code> slider arrow color</li> </ul> Tracking Task Configuration <ul> <li><code>x (integer) = 320:</code> x position of the task</li> <li><code>y (integer) = 0:</code> y position of the task</li> <li><code>width (integer) = 320:</code> width of the task</li> <li><code>height (integer) = 320:</code> height of the task</li> <li><code>padding (integer) = 10:</code> padding surrounding the task</li> <li><code>debug (boolean) = false:</code> whether to display debug information</li> <li><code>line_color (color) = \"#1d90ff\":</code> line color</li> <li><code>target_color (color) = \"#1d90ff\":</code> line color of the target</li> <li><code>target_line_width (integer) = 4:</code> width of the target lines</li> <li><code>target_x_offset (integer) = 0:</code> starting x position of the target</li> <li><code>target_y_offset (integer) = 0:</code> starting y position of the target</li> <li><code>target_radius (integer) = 25:</code> size of the target</li> <li><code>dash_array (string) = \"4,2,1,2\":</code> dash array for dashed lines</li> </ul>"},{"location":"getting_started/configuration/#schedule-files","title":"Schedule files","text":"<p>Schedule files determine how each task evolves, the files are written in a DSL (Domain Specific Language) details of which can be found here.</p> <p>Briefly, schedule files contain a list of actions with times to execute them. Each line of a configuration file follows a template: <pre><code>ACTION(...) @ [T1, T2, ...] : R\n</code></pre></p> <p>Where <code>T1</code>, <code>T2</code>, ... are times to wait before executing the action <code>ACTION</code>, and <code>R</code> is the number of times to repeat the given sequence of wait times, the special character <code>*</code> means repeat forever. </p> <p>Each task has a number of actions that have been defined which will update the task's state. </p>"},{"location":"getting_started/configuration/#actions","title":"Actions","text":"<p>Actions make a change to the state of <code>matbii</code> and have their own internal definition. The full list of actions avaliable for use in a schedule is given below. Some examples are given in the next section.</p> Action Reference <p>Tracking</p> <ul> <li><code>move_target(direction: tuple[float, float] | int | float, speed: float)</code></li> <li><code>perturb_target(speed: float)</code></li> </ul> <p>System Monitoring</p> <ul> <li><code>on_light(target: int)</code></li> <li><code>off_light(target: int)</code></li> <li><code>toggle_light(target: int)</code></li> <li><code>perturb_slider(target: int)</code></li> </ul> <p>Resource Management</p> <ul> <li><code>burn_fuel(target: int | str, burn: float)</code></li> <li><code>pump_fuel(target: int | str, flow: float)</code></li> <li><code>toggle_pump_failure(target: int | str)</code></li> <li><code>toggle_pump(target: int | str)</code></li> </ul>"},{"location":"getting_started/configuration/#timing-functions","title":"Timing functions","text":"<p>Timings can be specified explicitly as constant <code>int</code> or <code>float</code> values (seconds).</p> <p>Example 1</p> <p><pre><code>toggle_light(1) @ [10]:*\n</code></pre> This will toggle light number 1 on/off every 10 seconds.</p> <p>but we may want some more complicated schedule. This can be acheived using some built-in timing functions to introduce randomness or otherwise.</p> <ul> <li><code>uniform(a : int, b : int)</code> - a random integer between a and b (inclusive).</li> <li><code>uniform(a : float, b : float)</code> - a random float between a and b (inclusive).</li> </ul> <p>Example 2</p> <p><pre><code>toggle_light(1) @ [uniform(10,20)]:*\n</code></pre> This will toggle light number 1 on/off at times randomly chosen between 10 and 20 seconds.</p> <p>We can build more complex schedules that mix timing functions and constant values. </p> <p>Example 3</p> <p><pre><code>toggle_pump_failure(\"ab\") @ [uniform(3,10), 2]:*\n</code></pre> This will trigger a pump failure for 2 seconds after some random time between 3-10 seconds and repeat.</p>"},{"location":"getting_started/configuration/#example-schedules","title":"Example Schedules","text":"Tracking Task Schedule <pre><code># this moves the target around randomly by 5 units every 0.1 seconds\nperturb_target(5) @ [0.1]:*\n</code></pre> System Monitoring Task Schedule <pre><code># this makes the lights turn to their unacceptable state every 10-20 seconds\noff_light(1) @ [uniform(10,20)]:*    # this means failure for light 1\non_light(2) @ [uniform(10,20)]:*     # this means failure for light 2\n# toggle_light(1) is also an option\n# toggle_light(2) is also an option\n\n# this randomly moves the sliders (up/down by 1) every 5-6 seconds.\nperturb_slider(1) @ [uniform(5,6)]:*\nperturb_slider(2) @ [uniform(5,6)]:*\nperturb_slider(3) @ [uniform(5,6)]:*\nperturb_slider(4) @ [uniform(5,6)]:*\n</code></pre> Resource Management Task Schedule <pre><code># these determine pump failures, fail for 2 seconds after between 3 and 10 seconds (and repeat)\ntoggle_pump_failure(\"fd\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"fb\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"db\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"ec\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"ea\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"ca\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"ba\") @ [uniform(3,10), 2]:*\ntoggle_pump_failure(\"ab\") @ [uniform(3,10), 2]:*\n\n# these determine the burning of fuel in the two main tanks\nburn_fuel(\"a\", 10) @ [0.1]:*\nburn_fuel(\"b\", 10) @ [0.1]:*\n\n# these determine the flow of the pumps (when they are \"on\")\npump_fuel(\"fd\", 20) @ [0.1]:*\npump_fuel(\"fb\", 20) @ [0.1]:*\npump_fuel(\"db\", 20) @ [0.1]:*\npump_fuel(\"ec\", 20) @ [0.1]:*\npump_fuel(\"ea\", 20) @ [0.1]:*\npump_fuel(\"ca\", 20) @ [0.1]:*\npump_fuel(\"ba\", 20) @ [0.1]:*\npump_fuel(\"ab\", 20) @ [0.1]:*\n</code></pre>"},{"location":"getting_started/configuration/#usage","title":"Usage","text":""},{"location":"getting_started/configuration/#default-entry-point","title":"Default entry point","text":"<p>An example of all files discussed above can be found here.</p> <p>To run the example, install matbii locally.</p> <p>Navigate to the <code>example</code> directory: <pre><code>cd matbii/example\n</code></pre> and run: <pre><code>python -m matbii -c experiment-C.json\n</code></pre></p>"},{"location":"getting_started/configuration/#custom-entry-point","title":"Custom entry point","text":"<p>Custom entry points are an advanced topic.</p>"},{"location":"getting_started/key-concepts/","title":"Key Concepts","text":"<p>This page presents some key concepts and explains terminology used in the getting started guide, if you are confident that you understand these or are in a rush then please skip to Configuration and refer back if needed.</p>"},{"location":"getting_started/key-concepts/#environment","title":"Environment","text":"<p>The environment contains all of the agents, tasks, and a state, and is responsible for running the simulation. <code>matbii</code> relies on the agent-based abstractions provided by the <code>star-ray</code> and <code>icua</code> packages. It is at its heart an multi-agent simulation that includes the user as one of these agent. </p>"},{"location":"getting_started/key-concepts/#state","title":"State","text":"<p>The state of <code>matbii</code> is represented using XML, more specifically using SVG. The state represents all of the persistent data in the <code>matbii</code> environment, agents have access to this data via their sensors and can modify it using their actuators. The state is represented internally as a data structure which can be queried using XPATH, actions are compiled queries that read or write XML data. </p> <p>Part of what makes <code>matbii</code> so configurable is that User Interface (UI) data is represented directly as part of the state. This is a departure from the more common Model-View-Controller (MVC) architecture where there is clearer seperation between the model (the state) and the view (the UI). The benefit of this architecture is that agents can directly modify the UI. This will happen as part of the normal running of the system (e.g. when updating a task) or when providing visual feedback or guidance to the user. In short, it enables maximum flexiblity and scope for experimentation with different kinds of visual feedback. It also makes the process of add new tasks or developing new multi-task systems more straightforward (see advanced topicsfor details).</p>"},{"location":"getting_started/key-concepts/#task","title":"Task","text":"<p><code>matbii</code> is a multi-task application originally designed as a platform for human attention research. Tasks require the user to perform some actions to solve, or in this case, continually manage their state and are typically indepedent from each other. Some tasks may be more challenging to manage than others, and typically a human user will struggle to address or interact with multiple tasks simultaneously. Instead, they will likely switch between them allocating bursts of attention. The strategies or mechanisms that humans employ to do this are of significant interest to attention research and have motivated the development of platforms such as <code>matbii</code>.</p> <p>This version of <code>matbii</code> currently defines three tasks (a subset of the five tasks originally implemented in NASA's MATB-II system):</p> <ul> <li><code>tracking</code></li> <li><code>system monitoring</code></li> <li><code>resource management</code></li> </ul> <p>The goals of a user in each of these tasks is outlined below.</p>"},{"location":"getting_started/key-concepts/#tracking","title":"Tracking","text":"<p>The user is tasked with keeping a target (1) within a central box (2) using the arrow keys on a keyboard. The target will move around according to the task schedule. </p> <p></p>"},{"location":"getting_started/key-concepts/#system-monitoring","title":"System Monitoring","text":"<p>The user is tasked with clicking on lights (1, 2) and sliders (3) to keep them in the acceptable state. </p> <ul> <li>light (1) should be kept on (green by default), grey represents the off state (unacceptable).</li> <li>light (2) should be kept off (grey by default), red represents the on state (unacceptable).</li> </ul> <p>Lights will toggle on/off on click.</p> <ul> <li>sliders (3) should be kept in the central position, they will move to this position on click.</li> </ul> <p>The lights and sliders will change their state according to the task schedule.</p> <p></p>"},{"location":"getting_started/key-concepts/#resource-management","title":"Resource Management","text":"<p>The user is tasked with keeping the fuel main fuel tanks in the acceptable range (1, 2). The fuel in these tanks will be slowly burned and reduce overtime. Fuel can be transfered between tanks by clicking on pumps (3), this will begin the transfer of fuel at a given rate. Pumps will periodically fail (4) rendering them unusable, fuel will stop flowing if a pump is the failure state.</p> <p>Pump failure, fuel transfer and burn happen according to the task schedule.  </p> <p></p>"},{"location":"getting_started/key-concepts/#agent","title":"Agent","text":"<p><code>matbii</code> follows an agent-based architecture, virtually everything is done by agents - updating tasks, providing guidance to a user, displaying the UI and putting user input to use (see Avatar). There are many definitions of what an agent is, but for our purposes it is a persistent and modular piece of software that makes decisions which influence its environment or other agents. An agent typically has a collection of sensors and a collection of actuators which permit certain affordances, that is, allow it to take certain actions and observe certain outcomes in pursuit of some goal. Goals may be more or less sophisticated and <code>matbii</code> has the full range. </p>"},{"location":"getting_started/key-concepts/#task-agents","title":"Task Agents","text":"<p>Each task in <code>matbii</code> is managed by an agent, its goal is to make modifications to its assigned task in line with the task definition. In practice, the task definition is implemented as part of the agents behaviour - it decides when and how to update the task. A task is therefore defined by its state, the assigned agent, and the Avatar which defines how the user interacts with a specific task (see also advanced topic: developing new tasks). This goal is fairly simple and doesn't typically require reasoning or other higher functions.</p>"},{"location":"getting_started/key-concepts/#guidance-agents","title":"Guidance Agents","text":"<p>The goal of the guidance agent on the other hand is more demanding, it is to decide when and how to prompt a human user into addressing a particular task, for example, to ensure that no task is neglected, or to ensure \"optimal\" allocation of attention. The best way to do this is an open question since we still don't fully understand the the mechanisms that drive our attention. There are many questions brought up by the design a guidance agent, experimenting with goals/behaviours here may give insight into the our attention mechanisms, this is what has motivated the development of this system.</p>"},{"location":"getting_started/key-concepts/#avatars","title":"Avatars","text":"<p>An avatar is a special kind of agent which acts on behalf of the user, think of an avatar as your virtual double. It captures input from periferal devices (mouse, keyboard, eyetracker, etc.) and performs actions on your behalf. There is a mapping from user input to tasks-specific actions which it uses to do so. This mapping forms part of the task definition and is implemented as a task-specific actuator. The avatar also provides its own observations to the user in a human-friendly fashion, in this case, it observes the state of the environment (the SVG data) and displays it in a window. Avatars don't have their own goals, they instead act as a bridge between the real world and virtual environment making your goals their goals.</p>"},{"location":"getting_started/key-concepts/#actuator","title":"Actuator","text":"<p>An actuator is an interface between an agent and its environment, it allows the agent to have tangible influence of the state of its environment. The real world analogue are your muscles, or your hands. They enable you to take certain situation-dependent actions and to acheive your goals. </p>"},{"location":"getting_started/key-concepts/#sensor","title":"Sensor","text":"<p>A sensor is an interface between an agent and its environment which allows the agent to observe the state of its environment. Sensors do not have influence over the state, but instead provide information crucial to the acheivement of an agents goals. </p>"},{"location":"getting_started/key-concepts/#action","title":"Action","text":"<p>An action is a discrete event or query which will modify (in the case of an actuator) or retrieve  (in the case of a sensor) data from the environment state.</p>"},{"location":"getting_started/key-concepts/#observation","title":"Observation","text":"<p>An observation is typically the result of an action, it contains data that an agent may use to make its decisions or review its beliefs. Typically observations are recived by sensors as a result of a sensing action, but actuators may also received them - think of the strain feedback your hand may give you when doing something strenuous.</p>"},{"location":"getting_started/resource_management_config/","title":"Resource management config","text":"<pre><code>- `x (integer) = 260:` x position of the task\n- `y (integer) = 360:` y position of the task\n- `width (integer) = 540:` width of the task\n- `height (integer) = 300:` height of the task\n- `padding (integer) = 10:` padding surrounding the task\n- `pump_on_color (color) = \"#00ff00\":` color of pumps when in the `\"on\"` state\n- `pump_off_color (color) = \"#add9e6\":` color of pumps when in the `\"off\"` state\n- `pump_failure_color (color) = \"#ff0000\":` color of pumps when in the `\"failure\"` state\n- `stroke_color (color) = \"#000000\":` line colour\n- `stroke_width (integer) = 2:` line width\n- `show_tank_labels (boolean) = true:` whether to show textual labels next to each tank\n- `background_color (color) = \"#ffffff\":` background color of the tanks\n- `debug (boolean) = false:` whether to display debug information\n- `tank_capacity (dict):` See details below:\n- `tank_capacity.a (integer) = 2000:` capacity for tank a\n- `tank_capacity.b (integer) = 2000:` capacity for tank b\n- `tank_capacity.c (integer) = 1500:` capacity for tank c\n- `tank_capacity.d (integer) = 1500:` capacity for tank d\n- `tank_capacity.e (integer) = 1000:` capacity for tank e\n- `tank_capacity.f (integer) = 1000:` capacity for tank f\n- `tank_level (dict):` See details below:\n- `tank_level.a (integer) = 1000:` starting fuel level for tank a (&lt; tank_capacity.a)\n- `tank_level.b (integer) = 1000:` starting fuel level for tank b (&lt; tank_capacity.b)\n- `tank_level.c (integer) = 750:` starting fuel level for tank c (&lt; tank_capacity.c)\n- `tank_level.d (integer) = 750:` starting fuel level for tank d (&lt; tank_capacity.d)\n- `tank_level.e (integer) = 750:` starting fuel level for tank e (&lt; tank_capacity.e)\n- `tank_level.f (integer) = 750:` starting fuel level for tank f (&lt; tank_capacity.f)\n- `pump_state (dict):` See details below:\n- `pump_state.ab (str) = \"off\":` starting state of pump ab (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.ba (str) = \"off\":` starting state of pump ba (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.ca (str) = \"off\":` starting state of pump ca (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.ec (str) = \"off\":` starting state of pump ec (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.ea (str) = \"off\":` starting state of pump ea (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.db (str) = \"off\":` starting state of pump db (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.fd (str) = \"off\":` starting state of pump fd (options `\"off\"`, `\"on\"`, `\"failure\"`)\n- `pump_state.fb (str) = \"off\":` starting state of pump fb (options `\"off\"`, `\"on\"`, `\"failure\"`)\n</code></pre>"},{"location":"getting_started/system_monitoring_config/","title":"System monitoring config","text":"<pre><code>- `x (integer) = 0:` x position of the task\n- `y (integer) = 0:` y position of the task\n- `width (integer) = 240:` width of the task\n- `height (integer) = 330:` height of the task\n- `padding (integer) = 10:` padding surrounding the task\n- `debug (boolean) = false:` whether to display debug information\n- `show_keyboard_shortcuts (boolean) = false:` whether to display keyboard shortcuts\n- `font_size (integer) = 12:` font size\n- `stroke_width (integer) = 2:` line width\n- `light_state (list) = [0, 0]:` initial states of each light (options: 0 or 1)\n- `light_on_color (color) = \"#00ff00\":` color of light 1 when on\n- `light_failure_color (color) = \"#ff0000\":` color of light 2 when on\n- `light_off_color (color) = \"#add9e6\":` color of light 1 and 2 when off\n- `light_width (integer) = 75:` width of each light\n- `light_height (integer) = 50:` height of each light\n- `slider_num_increments (integer) = 11:` number of increments in each slider\n- `slider_state (list) = [5, 5, 5, 5]:` intial states of each slider (options: 0 to slider_num_increments-1)\n- `slider_width (integer) = 30:` width of each slider\n- `slider_height (integer) = 20:` height of each slider\n- `slider_background_color (color) = \"#add9e6\":` slider background color\n- `slider_color (color) = \"#4682b4\":` slider color\n- `slider_arrow_color (color) = \"#ffff00\":` slider arrow color\n</code></pre>"},{"location":"getting_started/tracking_config/","title":"Tracking config","text":"<pre><code>- `x (integer) = 320:` x position of the task\n- `y (integer) = 0:` y position of the task\n- `width (integer) = 320:` width of the task\n- `height (integer) = 320:` height of the task\n- `padding (integer) = 10:` padding surrounding the task\n- `debug (boolean) = false:` whether to display debug information\n- `line_color (color) = \"#1d90ff\":` line color\n- `target_color (color) = \"#1d90ff\":` line color of the target\n- `target_line_width (integer) = 4:` width of the target lines\n- `target_x_offset (integer) = 0:` starting x position of the target\n- `target_y_offset (integer) = 0:` starting y position of the target\n- `target_radius (integer) = 25:` size of the target\n- `dash_array (string) = \"4,2,1,2\":` dash array for dashed lines\n</code></pre>"},{"location":"getting_started/devices/","title":"Devices","text":"<p>Users interact with <code>matbii</code> via various input devices. Currently three devices are supported:</p> <ul> <li>Eye tracker</li> <li>Mouse</li> <li>Keyboard</li> </ul> <p>Other events that come from the UI or window are also avaliable to agents see window &amp; UI.</p> <p>For more advanced usage and information on implementating new devices see Advanced usage.</p>"},{"location":"getting_started/devices/eye_tracking/","title":"Eye tracking","text":"<p>Courtesy of <code>icua</code>, <code>matbii</code> supports eye-tracking out of the box. Currently only tobii pro eye trackers are supported. If you want to make use of another eye tracker provider, see eye tracker API.</p> <p>Events:</p> <ul> <li><code>EyeMotionEvent</code></li> <li><code>EyeMotionEventRaw</code></li> </ul>"},{"location":"getting_started/devices/eye_tracking/#configuration","title":"Configuration","text":"<p>Eye tracking can be configured via the main configuration file.</p>"},{"location":"getting_started/devices/eye_tracking/#calibration","title":"Calibration","text":"<p><code>matbii</code> does not currently support calibrating eye trackers out of the box, this should be done via tools provided by your eye tracker manufacturer.</p> Tobii <p>Tobii eye trackers can be calibrated using tobii eye tracker manager. This is also where you will find your eyetracker URI (see section below).</p>"},{"location":"getting_started/devices/eye_tracking/#finding-your-eye-tracker-uri","title":"Finding your eye tracker URI","text":"<p>The URI is used by <code>matbii</code> to locate and connect to your eye tracker device.</p> Tobii <p> </p>"},{"location":"getting_started/devices/eye_tracking/#eye-tracking-api","title":"Eye tracking API","text":"<p>If your eyetracker brand is not yet supported then you will need to use the device API provided by <code>icua</code>. This is an advanced topic, see here.</p>"},{"location":"getting_started/devices/mouse_keyboard/","title":"Mouse &amp; Keyboard","text":"<p>Mouse and keyboard are supported by default by the UI backend. </p> <p>Events:</p> <ul> <li><code>MouseButtonEvent</code></li> <li><code>MouseMotionEvent</code></li> <li><code>KeyEvent</code></li> </ul>"},{"location":"getting_started/devices/window_ui/","title":"Window &amp; UI","text":"<p>COMING SOON</p>"},{"location":"getting_started/experiments/","title":"Experiments","text":"<p><code>matbii</code> has been built to support experiments in multi-task attention research. The main configuration provides a number of useful options that will help you set up an experiment. It also provides some useful functionality for analysing the results of your experiments, including logging of events, and various tools for parsing and working with these files to extract useful information.</p>"},{"location":"getting_started/experiments/logging/","title":"Logging","text":"<p><code>matbii</code> logs all events in the simulation to a file as they happen. This file can be configured in the main configuration under the <code>logging.path</code>. </p>"},{"location":"getting_started/experiments/logging/#log-file-structure","title":"Log file structure","text":"<p>Each line of the log file contains data for a single event and has the following format:</p> <pre><code>TIMESTAMP EVENT_TYPE EVENT_DATA\n</code></pre> <ul> <li> <p><code>TIMESTAMP</code> is the time that the event was logged, this is very close to the time that the event occurs in the simulation, logging happens immediately before an event is executed. This timestamp gives the most accurate timing information for when a state change was made. For device related events it may be better to use the instantiation time (part of <code>EVENT_DATA</code>) to get for example, the time at which a user reacted to a given stimulous. In most cases the difference in these timestamps is very minimal (0.1-1 millisecond)</p> </li> <li> <p><code>EVENT_TYPE</code> is the type of event that was executed (the name of the event class), for a full list of these types, see Event Types</p> </li> <li> <p><code>EVENT_DATA</code> a JSON representation of the data associated with the event (enclosed in <code>{</code> <code>}</code>). The event data will contain at the very least, a unique <code>id</code> for the event and a <code>timestamp</code> for when the event was instantiated. </p> </li> </ul> <p>We provide a parser for these files will which reconstruct the origin event class, see Post Analysis.</p>"},{"location":"getting_started/experiments/logging/#event-types","title":"Event types","text":"<p>You can expect to see various kinds of events in a log file, the types are documented in the API reference. </p>"},{"location":"getting_started/experiments/logging/#actions","title":"Actions","text":"<p>All actions that modify the state are recorded.</p> <p>Some actions are task specific, for example:</p> <ul> <li>System Monitoring: <code>SetLightAction</code>, <code>ToggleLightAction</code>, <code>SetSliderAction</code></li> <li>Resource Management: <code>BurnFuelAction</code>, <code>PumpFuelAction</code>, <code>TogglePumpAction</code>, <code>SetPumpAction</code></li> <li>Tracking: <code>TargetMoveAction</code></li> </ul> <p>Some actions are due to guidance, for example: <code>DrawBoxAction</code>, <code>DrawArrowAction</code>, <code>HideElementAction</code>, <code>ShowElementAction</code></p>"},{"location":"getting_started/experiments/logging/#primitive-actions","title":"Primitive Actions","text":"<p>Primitive events typically represent changes made internally by <code>matbii</code> or parent packages (<code>icua</code> or <code>star-ray</code>), for example when initially configuring the UI. These include: <code>Update, Insert, Replace, Delete</code> which are used to directly modify the state of <code>matbii</code>.</p>"},{"location":"getting_started/experiments/logging/#device","title":"Device","text":"<p>Events that come from devices are also recorded and include: <code>KeyEvent, MouseButtonEvent, MouseMotionEvent, EyeMotionEvent, WindowMoveEvent, WindowResizeEvent, WindowFocusEvent, WindowOpenEvent, WindowCloseEvent</code>, see device documentation for details of each event.</p>"},{"location":"getting_started/experiments/logging/#flags","title":"Flags","text":"<p>Flag events are used to indicate state changes that may be of interest during post analysis. These events typically do not modify the state themselves, but indicate that some important change has occured. </p> <ul> <li><code>RenderEvent</code> : the UI has been refreshed and that any changes are now visible to the user.</li> <li><code>TaskAcceptable</code> : the Guidance Agent has determined that a task has entered an acceptable state (according to its decision rules).</li> <li> <p><code>TaskUnacceptable</code> : the Guidance Agent has determined that a task has entered an unacceptable state (according to its decision rules).</p> </li> <li> <p><code>ShowGuidance</code> : the guidance agent has decided to show guidance on a task.</p> </li> <li><code>HideGuidance</code> : the guidance agent has decided to hide guidance on a task.</li> </ul>"},{"location":"getting_started/experiments/logging/#gotchas","title":"Gotchas","text":"<p>Below is a list of Gotchas that you should be aware of when working with log files and interpreting the results. </p>"},{"location":"getting_started/experiments/logging/#task-acceptability","title":"Task acceptability","text":"<p>The two flag events <code>TaskAcceptable</code> and <code>TaskUnacceptable</code> occur AFTER a task has reached an acceptable/unacceptable state. The agent requires 1 cycle to observe the state, decide it is acceptable/unacceptable and then act to produce the corresponding flag event. Using the timestamps of these events to classify other events as occuring when a task is acceptable/acceptable may lead to off-by-one errors. The analysis functions provided for analysis take this into account and are reliable for doing this classification.</p>"},{"location":"getting_started/experiments/logging/#order-of-execution","title":"Order of execution","text":"<p>You should not rely on the order of the execution of the agents (within a single cycle) when analysis event timestamps since this is undefined, all events that appear between two <code>RenderEvents</code> should be considered as happening simultaneously, at least from the perspective of the user. This effectively splits up the event stream into small discrete chunks and sets a limit on the accuracy of the timing information.</p>"},{"location":"getting_started/experiments/post-analysis/","title":"Post analysis","text":"<p><code>matbii</code> logs lots of relevant data for use in post analysis of an experiment or trial. This data can be a bit cumbersome to work with as not all of it will be relevant to your specific research question. We have provided some functionality that can parse, extract and visualise information relevant to your research questions.</p>"},{"location":"getting_started/experiments/post-analysis/#parsing-log-files","title":"Parsing log files","text":"<p>COMING SOON</p>"},{"location":"getting_started/experiments/post-analysis/#visualisation","title":"Visualisation","text":"<p>COMING SOON</p>"},{"location":"reference/","title":"Reference","text":"<p>Matbii package.</p>"},{"location":"reference/#packages","title":"Packages","text":"<ul> <li>matbii/agent</li> <li>matbii/avatar</li> <li>matbii/config</li> <li>matbii/environment</li> <li>matbii/guidance</li> <li>matbii/tasks</li> <li>matbii/utils</li> </ul>"},{"location":"reference/#modules","title":"Modules","text":"<ul> <li>matbii/main.py</li> </ul>"},{"location":"reference/agent/","title":"Agent","text":"<p>Package defining agent related functionality.</p>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator","title":"<code>ResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the resource management task.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class ResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the resource management task.\"\"\"\n\n    @attempt\n    def burn_fuel(\n        self,\n        target: int | str,\n        burn: float,\n    ) -&gt; \"BurnFuelAction\":\n        \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n        Args:\n            target (int | Literal[\"a\", \"b\"]): target tank\n            burn (float): amount of fuel to burn.\n\n        Returns:\n            BurnFuelAction: the action\n        \"\"\"\n        return BurnFuelAction(target=target, burn=burn)\n\n    @attempt\n    def pump_fuel(\n        self,\n        target: int | str,\n        flow: float,\n    ) -&gt; \"PumpFuelAction\":\n        \"\"\"Pumps the given amount of fuel via the given pump.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n            flow (float): amount of fuel to pump.\n\n        Returns:\n            PumpFuelAction: the action\n        \"\"\"\n        return PumpFuelAction(target=target, flow=flow)\n\n    @attempt\n    def toggle_pump_failure(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpFailureAction\":\n        \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpFailureAction(target=target)\n\n    @attempt\n    def toggle_pump(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpAction\":\n        \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.burn_fuel","title":"<code>burn_fuel(target, burn)</code>","text":"<p>Burns a given amount of fuel in the <code>target</code> tank, if the tank is empty this has no effect.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['a', 'b']</code> <p>target tank</p> required <code>burn</code> <code>float</code> <p>amount of fuel to burn.</p> required <p>Returns:</p> Name Type Description <code>BurnFuelAction</code> <code>BurnFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef burn_fuel(\n    self,\n    target: int | str,\n    burn: float,\n) -&gt; \"BurnFuelAction\":\n    \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n    Args:\n        target (int | Literal[\"a\", \"b\"]): target tank\n        burn (float): amount of fuel to burn.\n\n    Returns:\n        BurnFuelAction: the action\n    \"\"\"\n    return BurnFuelAction(target=target, burn=burn)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.pump_fuel","title":"<code>pump_fuel(target, flow)</code>","text":"<p>Pumps the given amount of fuel via the given pump.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump (this will determine which tanks are pumped to/from).</p> required <code>flow</code> <code>float</code> <p>amount of fuel to pump.</p> required <p>Returns:</p> Name Type Description <code>PumpFuelAction</code> <code>PumpFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef pump_fuel(\n    self,\n    target: int | str,\n    flow: float,\n) -&gt; \"PumpFuelAction\":\n    \"\"\"Pumps the given amount of fuel via the given pump.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n        flow (float): amount of fuel to pump.\n\n    Returns:\n        PumpFuelAction: the action\n    \"\"\"\n    return PumpFuelAction(target=target, flow=flow)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.toggle_pump","title":"<code>toggle_pump(target)</code>","text":"<p>Toggle pump state (on -&gt; off, off -&gt; on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpAction\":\n    \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.toggle_pump_failure","title":"<code>toggle_pump_failure(target)</code>","text":"<p>Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpFailureAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump_failure(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpFailureAction\":\n    \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpFailureAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator","title":"<code>SystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the system monitoring task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@agent_actuator\nclass SystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the system monitoring task.\"\"\"\n\n    @attempt\n    def on_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"on\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.ON)\n\n    @attempt\n    def off_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"off\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.OFF)\n\n    @attempt\n    def toggle_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return ToggleLightAction(target=target)\n\n    @attempt\n    def perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n        \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n        Args:\n            target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n        Returns:\n            SetSliderAction: the action\n        \"\"\"\n        state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n        return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.off_light","title":"<code>off_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"off\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef off_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"off\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.OFF)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.on_light","title":"<code>on_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"on\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef on_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"on\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.ON)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.perturb_slider","title":"<code>perturb_slider(target)</code>","text":"<p>Perturb the <code>target</code> slider by +/- 1 slot.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n    return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.toggle_light","title":"<code>toggle_light(target)</code>","text":"<p>Toggle the <code>target</code> light (on-&gt;off, off-&gt;on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef toggle_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return ToggleLightAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.TrackingActuator","title":"<code>TrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the tracking task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class TrackingActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the tracking task.\"\"\"\n\n    @attempt\n    def move_target(\n        self, direction: tuple[float, float] | int | float, speed: float\n    ) -&gt; \"TargetMoveAction\":\n        \"\"\"Move the tracking target in a given direction at a given speed.\n\n        Args:\n            direction (tuple[float, float] | int | float): direction to move.\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        # an angle was provided (in degrees), convert it to a direction vector\n        if isinstance(direction, int | float):\n            angle = math.radians(direction)\n            direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n\n    @attempt\n    def perturb_target(self, speed: float) -&gt; \"TargetMoveAction\":\n        \"\"\"Move the tracking target in a random direction at a given speed.\n\n        Args:\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        angle = (random.random() * 2 - 1) * math.pi\n        direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.TrackingActuator.move_target","title":"<code>move_target(direction, speed)</code>","text":"<p>Move the tracking target in a given direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>tuple[float, float] | int | float</code> <p>direction to move.</p> required <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef move_target(\n    self, direction: tuple[float, float] | int | float, speed: float\n) -&gt; \"TargetMoveAction\":\n    \"\"\"Move the tracking target in a given direction at a given speed.\n\n    Args:\n        direction (tuple[float, float] | int | float): direction to move.\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    # an angle was provided (in degrees), convert it to a direction vector\n    if isinstance(direction, int | float):\n        angle = math.radians(direction)\n        direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.TrackingActuator.perturb_target","title":"<code>perturb_target(speed)</code>","text":"<p>Move the tracking target in a random direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef perturb_target(self, speed: float) -&gt; \"TargetMoveAction\":\n    \"\"\"Move the tracking target in a random direction at a given speed.\n\n    Args:\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    angle = (random.random() * 2 - 1) * math.pi\n    direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/avatar/","title":"Avatar","text":"<p>Package defining avatar related functionality.</p>"},{"location":"reference/avatar/#matbii.avatar.Avatar","title":"<code>Avatar</code>","text":"<p>               Bases: <code>Avatar</code></p> <p>A special type of <code>Agent</code> that will display a UI (<code>pygame</code> backend) to the user and capture various kinds of user input, including: mouse clicks, motion, key events, window events, and eyetracking events (if the required sensor is added, see <code>EyetrackingIOSensor</code>).</p> Source code in <code>icua\\agent\\avatar.py</code> <pre><code>class Avatar(PygameAvatar):\n    \"\"\"A special type of `Agent` that will display a UI (`pygame` backend) to the user and capture various kinds of user input, including: mouse clicks, motion, key events, window events, and eyetracking events (if the required sensor is added, see `EyetrackingIOSensor`).\"\"\"\n\n    def __init__(\n        self,\n        sensors: list[Sensor],\n        actuators: list[Actuator],\n        window_config: WindowConfiguration = None,\n        **kwargs,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            sensors (list[Sensor]): list of initial sensors, this may include instances of `IOSensor` that will gather user input from devices (see e.g. `EyetrackingIOSensor`). Common user input events such as mouse, keyboard and window events are already handled by a io sensor that is added automatically.\n            actuators (list[Actuator]): list of initial actuators, this should generally include an actuator that is capable of forwarding user input events (see e.g. `AvatarActuator`).\n            window_config (WindowConfiguration, optional): UI window configuration. Defaults to None (see `star_ray_pygame.agent.PyGameAvatar` for details).\n            kwargs (dict[str,Any]): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(sensors, actuators, window_config=window_config, **kwargs)\n\n    def render(self) -&gt; None:\n        \"\"\"Renders the UI and triggers a `RenderEvent`.\"\"\"\n        # this is for logging purposes, we can see when the rendering beings. if all agents are running locally (and synchronously), then we can assume that all preceeding events in the event log will be visible to the user! this is very useful for post-analysis in experiments.\n        self.attempt(RenderEvent())\n        super().render()\n\n    @observe\n    def on_gaze(self, event: EyeMotionEvent):\n        \"\"\"Observe method for `EyeMotionEvents`, this will only be called if an `EyetrackingIOSensor` (or similar) is attached to this agent. It finalises the events by computing the svg coordinates (from window coordinates) and finding all svg elements that lie under this coordinate. It will attempt the event so that it is made avaliable (via an appropriate actuator) to other subscribing agents.\n\n        Args:\n            event (EyeMotionEvent): the eye motion event.\n        \"\"\"\n        # These events are generated by an EyetrackingIOSensor (if it exists).\n        # The position is in pixel-coordinates, we need to transform to SVG coordinates\n        # (similar to mouse events).\n        event.position = self._view.pixel_to_svg(event.position_raw)\n        # also find the elements that are under the gaze point\n        event.target = self._view.elements_under(event.position, transform=False)\n        # attempt the event, this will send it to other subscribing agents\n        self.attempt(event)\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.Avatar.__init__","title":"<code>__init__(sensors, actuators, window_config=None, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>sensors</code> <code>list[Sensor]</code> <p>list of initial sensors, this may include instances of <code>IOSensor</code> that will gather user input from devices (see e.g. <code>EyetrackingIOSensor</code>). Common user input events such as mouse, keyboard and window events are already handled by a io sensor that is added automatically.</p> required <code>actuators</code> <code>list[Actuator]</code> <p>list of initial actuators, this should generally include an actuator that is capable of forwarding user input events (see e.g. <code>AvatarActuator</code>).</p> required <code>window_config</code> <code>WindowConfiguration</code> <p>UI window configuration. Defaults to None (see <code>star_ray_pygame.agent.PyGameAvatar</code> for details).</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>icua\\agent\\avatar.py</code> <pre><code>def __init__(\n    self,\n    sensors: list[Sensor],\n    actuators: list[Actuator],\n    window_config: WindowConfiguration = None,\n    **kwargs,\n):\n    \"\"\"Constructor.\n\n    Args:\n        sensors (list[Sensor]): list of initial sensors, this may include instances of `IOSensor` that will gather user input from devices (see e.g. `EyetrackingIOSensor`). Common user input events such as mouse, keyboard and window events are already handled by a io sensor that is added automatically.\n        actuators (list[Actuator]): list of initial actuators, this should generally include an actuator that is capable of forwarding user input events (see e.g. `AvatarActuator`).\n        window_config (WindowConfiguration, optional): UI window configuration. Defaults to None (see `star_ray_pygame.agent.PyGameAvatar` for details).\n        kwargs (dict[str,Any]): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(sensors, actuators, window_config=window_config, **kwargs)\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.Avatar.on_gaze","title":"<code>on_gaze(event)</code>","text":"<p>Observe method for <code>EyeMotionEvents</code>, this will only be called if an <code>EyetrackingIOSensor</code> (or similar) is attached to this agent. It finalises the events by computing the svg coordinates (from window coordinates) and finding all svg elements that lie under this coordinate. It will attempt the event so that it is made avaliable (via an appropriate actuator) to other subscribing agents.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EyeMotionEvent</code> <p>the eye motion event.</p> required Source code in <code>icua\\agent\\avatar.py</code> <pre><code>@observe\ndef on_gaze(self, event: EyeMotionEvent):\n    \"\"\"Observe method for `EyeMotionEvents`, this will only be called if an `EyetrackingIOSensor` (or similar) is attached to this agent. It finalises the events by computing the svg coordinates (from window coordinates) and finding all svg elements that lie under this coordinate. It will attempt the event so that it is made avaliable (via an appropriate actuator) to other subscribing agents.\n\n    Args:\n        event (EyeMotionEvent): the eye motion event.\n    \"\"\"\n    # These events are generated by an EyetrackingIOSensor (if it exists).\n    # The position is in pixel-coordinates, we need to transform to SVG coordinates\n    # (similar to mouse events).\n    event.position = self._view.pixel_to_svg(event.position_raw)\n    # also find the elements that are under the gaze point\n    event.target = self._view.elements_under(event.position, transform=False)\n    # attempt the event, this will send it to other subscribing agents\n    self.attempt(event)\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.Avatar.render","title":"<code>render()</code>","text":"<p>Renders the UI and triggers a <code>RenderEvent</code>.</p> Source code in <code>icua\\agent\\avatar.py</code> <pre><code>def render(self) -&gt; None:\n    \"\"\"Renders the UI and triggers a `RenderEvent`.\"\"\"\n    # this is for logging purposes, we can see when the rendering beings. if all agents are running locally (and synchronously), then we can assume that all preceeding events in the event log will be visible to the user! this is very useful for post-analysis in experiments.\n    self.attempt(RenderEvent())\n    super().render()\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarActuator","title":"<code>AvatarActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>This actuator will forward all user generated events to the environment. Other agents may subscribe to receive these events, otherwise they will simply be logged. It may also be used to produce <code>RenderEvent</code>s which should be taken at the START of the UI rendering step performed by the avatar.</p> Source code in <code>icua\\agent\\actuator_avatar.py</code> <pre><code>class AvatarActuator(Actuator):\n    \"\"\"This actuator will forward all user generated events to the environment. Other agents may subscribe to receive these events, otherwise they will simply be logged. It may also be used to produce `RenderEvent`s which should be taken at the START of the UI rendering step performed by the avatar.\"\"\"\n\n    @attempt\n    def render(self, action: RenderEvent = None):\n        \"\"\"Attempt method that will attempt a `RenderEvent`.\"\"\"\n        if action is None:\n            return RenderEvent()\n        return action\n\n    @attempt\n    def default(self, action: UserInputEvent):\n        \"\"\"Default attempt method for this actuator, will simply forward any of the received types to the environment. Typically it will recieve all types present in `UserInputEvent` (assuming that the actuator is attached to an `Avatar`.\n\n        Args:\n            action (UserInputEvent): user input event.\n\n        Returns:\n            Event: the given `action`\n        \"\"\"\n        return action\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarActuator.default","title":"<code>default(action)</code>","text":"<p>Default attempt method for this actuator, will simply forward any of the received types to the environment. Typically it will recieve all types present in <code>UserInputEvent</code> (assuming that the actuator is attached to an <code>Avatar</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserInputEvent</code> <p>user input event.</p> required <p>Returns:</p> Name Type Description <code>Event</code> <p>the given <code>action</code></p> Source code in <code>icua\\agent\\actuator_avatar.py</code> <pre><code>@attempt\ndef default(self, action: UserInputEvent):\n    \"\"\"Default attempt method for this actuator, will simply forward any of the received types to the environment. Typically it will recieve all types present in `UserInputEvent` (assuming that the actuator is attached to an `Avatar`.\n\n    Args:\n        action (UserInputEvent): user input event.\n\n    Returns:\n        Event: the given `action`\n    \"\"\"\n    return action\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarActuator.render","title":"<code>render(action=None)</code>","text":"<p>Attempt method that will attempt a <code>RenderEvent</code>.</p> Source code in <code>icua\\agent\\actuator_avatar.py</code> <pre><code>@attempt\ndef render(self, action: RenderEvent = None):\n    \"\"\"Attempt method that will attempt a `RenderEvent`.\"\"\"\n    if action is None:\n        return RenderEvent()\n    return action\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator","title":"<code>AvatarResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class AvatarResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_pump_targets = partial(\n            AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[TogglePumpAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        # always include the user action as it needs to be logged\n        actions = []\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_pump_actions(user_action))\n        return actions\n\n    def _get_pump_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        targets = self._get_pump_targets(user_action.target)\n        return [TogglePumpAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_pump_targets = partial(\n        AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n    )\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt a <code>TogglePumpAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>TogglePumpAction</code>: toggle the pump on-&gt;off or off-&gt;on.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[TogglePumpAction]</code> <p>list[TogglePumpAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[\"TogglePumpAction\"]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[TogglePumpAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    # always include the user action as it needs to be logged\n    actions = []\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_pump_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator","title":"<code>AvatarSystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class AvatarSystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_light_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n        )\n        self._get_slider_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n        - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[SetLightAction | SetSliderAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        actions = []\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_light_actions(user_action))\n            actions.extend(self._get_slider_actions(user_action))\n        return actions\n\n    def _get_light_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"ToggleLightAction\"]:\n        targets = [int(x) for x in self._get_light_targets(user_action.target)]\n        return [ToggleLightAction(target=target) for target in targets]\n\n    def _get_slider_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"SetSliderAction\"]:\n        targets = [int(x) for x in self._get_slider_targets(user_action.target)]\n        return [ResetSliderAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_light_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n    )\n    self._get_slider_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n    )\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt either a <code>SetLightAction</code> or a <code>SetSliderAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>SetLightAction</code>: will always set the light to its preferred (acceptable) state. - <code>SetSliderAction</code> will reset the slider to its preferred (acceptable) state (which is the central position), see <code>ResetSliderAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[Union[SetLightAction, SetSliderAction]]</code> <p>list[SetLightAction | SetSliderAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n    - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[SetLightAction | SetSliderAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    actions = []\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_light_actions(user_action))\n        actions.extend(self._get_slider_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator","title":"<code>AvatarTrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class AvatarTrackingActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.\"\"\"\n\n    def __init__(\n        self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            target_speed (float): the speed of the target (svg units per second).\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._keys_pressed = set()\n        self._prev_time = time.time()\n        self._target_speed = target_speed\n\n    def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n        \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n        Returns:\n            list[TargetMoveAction]: the action\n        \"\"\"\n        current_time = time.time()\n        # this will contain the user action (KeyEvent)\n        actions = []\n        if len(self._keys_pressed) &gt; 0:\n            # compute speed based on time that has passed\n            dt = current_time - self._prev_time\n            speed = self._target_speed * dt\n            # this will be normalised when the action is executed\n            result = [0, 0]\n            # compute the movement action based on the currently pressed keys\n            for key in self._keys_pressed:\n                direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n                result[0] += direction[0]\n                result[1] += direction[1]\n            if result[0] != 0 or result[1] != 0:\n                actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n        self._prev_time = current_time\n        return actions\n\n    @attempt\n    def attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n        \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        Args:\n            user_action (KeyEvent): the users keyboard action\n\n        Returns:\n            list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n        \"\"\"\n        if user_action.key.lower() in DEFAULT_KEY_BINDING:\n            if user_action.status == KeyEvent.UP:\n                self._keys_pressed.remove(user_action.key)\n            elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n                self._keys_pressed.add(user_action.key)\n        return []\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator.__attempt__","title":"<code>__attempt__()</code>","text":"<p>Attempt method that will attempt a <code>TargetMoveAction</code> to move the target according to the users input (if it has been provided since the last call to this method).</p> <p>Returns:</p> Type Description <code>list[TargetMoveAction]</code> <p>list[TargetMoveAction]: the action</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n    \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n    Returns:\n        list[TargetMoveAction]: the action\n    \"\"\"\n    current_time = time.time()\n    # this will contain the user action (KeyEvent)\n    actions = []\n    if len(self._keys_pressed) &gt; 0:\n        # compute speed based on time that has passed\n        dt = current_time - self._prev_time\n        speed = self._target_speed * dt\n        # this will be normalised when the action is executed\n        result = [0, 0]\n        # compute the movement action based on the currently pressed keys\n        for key in self._keys_pressed:\n            direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n            result[0] += direction[0]\n            result[1] += direction[1]\n        if result[0] != 0 or result[1] != 0:\n            actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n    self._prev_time = current_time\n    return actions\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator.__init__","title":"<code>__init__(target_speed=5.0, *args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>target_speed</code> <code>float</code> <p>the speed of the target (svg units per second).</p> <code>5.0</code> <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __init__(\n    self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n):\n    \"\"\"Constructor.\n\n    Args:\n        target_speed (float): the speed of the target (svg units per second).\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._keys_pressed = set()\n    self._prev_time = time.time()\n    self._target_speed = target_speed\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator.attempt_key_event","title":"<code>attempt_key_event(user_action)</code>","text":"<p>Attempt method that takes a <code>KeyEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>KeyEvent</code> <p>the users keyboard action</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>an empty list (no action is taken by this attempt method, see <code>AvatarTrackingActuator.__attempt__</code>.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n    \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    Args:\n        user_action (KeyEvent): the users keyboard action\n\n    Returns:\n        list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n    \"\"\"\n    if user_action.key.lower() in DEFAULT_KEY_BINDING:\n        if user_action.status == KeyEvent.UP:\n            self._keys_pressed.remove(user_action.key)\n        elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n            self._keys_pressed.add(user_action.key)\n    return []\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.EyetrackerIOSensor","title":"<code>EyetrackerIOSensor</code>","text":"<p>               Bases: <code>IOSensor</code></p> <p>An <code>IOSensor</code> implementation that gathers observations <code>EyeMotionEvent</code> from an eyetracker.</p> Source code in <code>icua\\extras\\eyetracking\\sensor.py</code> <pre><code>class EyetrackerIOSensor(IOSensor):\n    \"\"\"An `IOSensor` implementation that gathers observations `EyeMotionEvent` from an eyetracker.\"\"\"\n\n    def __init__(\n        self,\n        eyetracker: EyetrackerBase,\n        velocity_threshold: float = 0.1,\n        moving_average: int = 10,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            eyetracker (EyetrackerBase): base eyetracker, this is the IO device of this `IOSensor`.\n            velocity_threshold (float, optional): velocity threshold for the `IVTFilter`. Defaults to 0.1.\n            moving_average (int, optional): moving average window size for the `NWMAFilter`. Defaults to 10.\n        \"\"\"\n        super().__init__(eyetracker)\n        self._ivt_filter = IVTFilter(velocity_threshold)\n        nan = tuple([float(\"nan\"), float(\"nan\")])\n        self._ws_filter = WindowSpaceFilter(nan, nan, nan)\n        self._ma_filter = NWMAFilter(moving_average)\n\n    def __transduce__(self, events: list[EyeMotionEventRaw]) -&gt; list[EyeMotionEvent]:\n        \"\"\"Converts the list of raw eyetracking events to a list of eyetracking events by appling the filters that are part of this sensor.\n\n        The filters are applied in order:\n        - `NWMAFilter` - computes a moving average over points\n        - `IVTFilter` - computes fixation/saccade based on velocity threshold.\n        - `WindowSpaceFilter` - computes window UI space coordinates from screen space (requires screen &amp; window information, see methods: `EyetrackerIOSensor.on_window_move`, `EyetrackerIOSensor.on_window_resize`, `EyetrackerIOSensor.on_screen_size`).\n\n        Args:\n            events (list[EyeMotionEventRaw]): raw eyetracking events\n\n        Returns:\n            list[EyeMotionEvent]: eyetracking events\n        \"\"\"\n        return list(self._transduce_iter(events))\n\n    def _transduce_iter(self, events: list[EyeMotionEventRaw]):  # noqa\n        # applies all filters to the each eye motion event\n        for event in events:\n            data = event.model_dump()\n            for filter in [self._ma_filter, self._ivt_filter, self._ws_filter]:\n                data = filter(data)\n            # NOTE: position needs to be set properly in the agent (i.e. convert to view space)\n            data[\"position_raw\"] = data[\"position\"]\n            yield EyeMotionEvent.model_validate(data)\n\n    @attempt\n    def on_window_move(self, event: WindowMoveEvent) -&gt; None:\n        \"\"\"Should be called when the UI window is moved. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.\n\n        If this sensor is attached to a `AgentRouted` this may be called automatically.\n\n        Args:\n            event (WindowMoveEvent): event with information about the UI window position.\n        \"\"\"\n        # print(\"WINDOW MOVE\", event.position)\n        self._ws_filter.window_position = event.position\n\n    @attempt\n    def on_window_resize(self, event: WindowResizeEvent) -&gt; None:\n        \"\"\"Should be called when the UI window is resized. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.\n\n        If this sensor is attached to a `AgentRouted` this may be called automatically.\n\n        Args:\n            event (WindowResizeEvent): event with information about the UI window size.\n        \"\"\"\n        # print(\"WINDOW RESIZE!\", event.size)\n        self._ws_filter.window_size = event.size\n\n    @attempt\n    def on_screen_size(self, event: ScreenSizeEvent) -&gt; None:\n        \"\"\"Should be called when the screen/monitor size is discovered for the first time. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.\n\n        If this sensor is attached to a `AgentRouted` this may be called automatically.\n\n        Args:\n            event (ScreenSizeEvent): event with information about the screen/monitor size.\n        \"\"\"\n        # print(\"SCREEN SIZE!\", event.size)\n        self._ws_filter.screen_size = event.size\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.EyetrackerIOSensor.__init__","title":"<code>__init__(eyetracker, velocity_threshold=0.1, moving_average=10)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>eyetracker</code> <code>EyetrackerBase</code> <p>base eyetracker, this is the IO device of this <code>IOSensor</code>.</p> required <code>velocity_threshold</code> <code>float</code> <p>velocity threshold for the <code>IVTFilter</code>. Defaults to 0.1.</p> <code>0.1</code> <code>moving_average</code> <code>int</code> <p>moving average window size for the <code>NWMAFilter</code>. Defaults to 10.</p> <code>10</code> Source code in <code>icua\\extras\\eyetracking\\sensor.py</code> <pre><code>def __init__(\n    self,\n    eyetracker: EyetrackerBase,\n    velocity_threshold: float = 0.1,\n    moving_average: int = 10,\n):\n    \"\"\"Constructor.\n\n    Args:\n        eyetracker (EyetrackerBase): base eyetracker, this is the IO device of this `IOSensor`.\n        velocity_threshold (float, optional): velocity threshold for the `IVTFilter`. Defaults to 0.1.\n        moving_average (int, optional): moving average window size for the `NWMAFilter`. Defaults to 10.\n    \"\"\"\n    super().__init__(eyetracker)\n    self._ivt_filter = IVTFilter(velocity_threshold)\n    nan = tuple([float(\"nan\"), float(\"nan\")])\n    self._ws_filter = WindowSpaceFilter(nan, nan, nan)\n    self._ma_filter = NWMAFilter(moving_average)\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.EyetrackerIOSensor.__transduce__","title":"<code>__transduce__(events)</code>","text":"<p>Converts the list of raw eyetracking events to a list of eyetracking events by appling the filters that are part of this sensor.</p> <p>The filters are applied in order: - <code>NWMAFilter</code> - computes a moving average over points - <code>IVTFilter</code> - computes fixation/saccade based on velocity threshold. - <code>WindowSpaceFilter</code> - computes window UI space coordinates from screen space (requires screen &amp; window information, see methods: <code>EyetrackerIOSensor.on_window_move</code>, <code>EyetrackerIOSensor.on_window_resize</code>, <code>EyetrackerIOSensor.on_screen_size</code>).</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>list[EyeMotionEventRaw]</code> <p>raw eyetracking events</p> required <p>Returns:</p> Type Description <code>list[EyeMotionEvent]</code> <p>list[EyeMotionEvent]: eyetracking events</p> Source code in <code>icua\\extras\\eyetracking\\sensor.py</code> <pre><code>def __transduce__(self, events: list[EyeMotionEventRaw]) -&gt; list[EyeMotionEvent]:\n    \"\"\"Converts the list of raw eyetracking events to a list of eyetracking events by appling the filters that are part of this sensor.\n\n    The filters are applied in order:\n    - `NWMAFilter` - computes a moving average over points\n    - `IVTFilter` - computes fixation/saccade based on velocity threshold.\n    - `WindowSpaceFilter` - computes window UI space coordinates from screen space (requires screen &amp; window information, see methods: `EyetrackerIOSensor.on_window_move`, `EyetrackerIOSensor.on_window_resize`, `EyetrackerIOSensor.on_screen_size`).\n\n    Args:\n        events (list[EyeMotionEventRaw]): raw eyetracking events\n\n    Returns:\n        list[EyeMotionEvent]: eyetracking events\n    \"\"\"\n    return list(self._transduce_iter(events))\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.EyetrackerIOSensor.on_screen_size","title":"<code>on_screen_size(event)</code>","text":"<p>Should be called when the screen/monitor size is discovered for the first time. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.</p> <p>If this sensor is attached to a <code>AgentRouted</code> this may be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ScreenSizeEvent</code> <p>event with information about the screen/monitor size.</p> required Source code in <code>icua\\extras\\eyetracking\\sensor.py</code> <pre><code>@attempt\ndef on_screen_size(self, event: ScreenSizeEvent) -&gt; None:\n    \"\"\"Should be called when the screen/monitor size is discovered for the first time. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.\n\n    If this sensor is attached to a `AgentRouted` this may be called automatically.\n\n    Args:\n        event (ScreenSizeEvent): event with information about the screen/monitor size.\n    \"\"\"\n    # print(\"SCREEN SIZE!\", event.size)\n    self._ws_filter.screen_size = event.size\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.EyetrackerIOSensor.on_window_move","title":"<code>on_window_move(event)</code>","text":"<p>Should be called when the UI window is moved. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.</p> <p>If this sensor is attached to a <code>AgentRouted</code> this may be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>WindowMoveEvent</code> <p>event with information about the UI window position.</p> required Source code in <code>icua\\extras\\eyetracking\\sensor.py</code> <pre><code>@attempt\ndef on_window_move(self, event: WindowMoveEvent) -&gt; None:\n    \"\"\"Should be called when the UI window is moved. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.\n\n    If this sensor is attached to a `AgentRouted` this may be called automatically.\n\n    Args:\n        event (WindowMoveEvent): event with information about the UI window position.\n    \"\"\"\n    # print(\"WINDOW MOVE\", event.position)\n    self._ws_filter.window_position = event.position\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.EyetrackerIOSensor.on_window_resize","title":"<code>on_window_resize(event)</code>","text":"<p>Should be called when the UI window is resized. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.</p> <p>If this sensor is attached to a <code>AgentRouted</code> this may be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>WindowResizeEvent</code> <p>event with information about the UI window size.</p> required Source code in <code>icua\\extras\\eyetracking\\sensor.py</code> <pre><code>@attempt\ndef on_window_resize(self, event: WindowResizeEvent) -&gt; None:\n    \"\"\"Should be called when the UI window is resized. It is the responsibility of the attached agent to provide this information to this sensor. It is required to transform raw eyetracking coordinates to UI coordinates.\n\n    If this sensor is attached to a `AgentRouted` this may be called automatically.\n\n    Args:\n        event (WindowResizeEvent): event with information about the UI window size.\n    \"\"\"\n    # print(\"WINDOW RESIZE!\", event.size)\n    self._ws_filter.window_size = event.size\n</code></pre>"},{"location":"reference/config/","title":"Config","text":"<p>Module containing configuration classes.</p>"},{"location":"reference/config/#matbii.config.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Main configuration class for the default entry point.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class Configuration(BaseModel, validate_assignment=True):\n    \"\"\"Main configuration class for the default entry point.\"\"\"\n\n    experiment: ExperimentConfiguration = Field(default_factory=ExperimentConfiguration)\n    participant: ParticipantConfiguration = Field(\n        default_factory=ParticipantConfiguration\n    )\n    guidance: GuidanceConfiguration = Field(default_factory=GuidanceConfiguration)\n    window: WindowConfiguration = Field(\n        default_factory=_default_window_configuration_factory\n    )\n    eyetracking: EyetrackingConfiguration = Field(\n        default_factory=EyetrackingConfiguration\n    )\n    logging: LoggingConfiguration = Field(default_factory=LoggingConfiguration)\n    ui: UIConfiguration = Field(default_factory=UIConfiguration)\n\n    @staticmethod\n    def from_file(\n        path: str | Path | None, context: dict[str, Any] | None = None\n    ) -&gt; \"Configuration\":\n        \"\"\"Factory that will build `Configuration` from a .json file.\n\n        Args:\n            path (str | Path | None): path to config file.\n            context (dict[str, Any] | None, optional): additional context (to override file content). Defaults to None.\n\n        Returns:\n            Configuration: resulting configuration.\n        \"\"\"\n        context = context if context else {}\n        if path:\n            path = Path(path).expanduser().resolve().as_posix()\n            LOGGER.info(f\"Using config file: {path}\")\n            with open(path) as f:\n                data = json.load(f)\n                data = always_merger.merge(data, context)\n                return Configuration.model_validate(data)\n        else:\n            LOGGER.info(\"No config file was specified, using default configuration.\")\n            return Configuration()\n\n    @staticmethod\n    def initialise_logging(config: \"Configuration\") -&gt; \"Configuration\":\n        \"\"\"Initialises logging for the given run. This will set logging options and set the config logging path which should be used throughout `matbii` to log information that may be relevant for experiment post-analysis. The configuration passed here will also be logged to the `configuration.json` file in the logging path.\n\n        The logging path will be derived: `&lt;config.experiment.id&gt;/&lt;config.participant.id&gt;` if these values are present, otherwise a timestamp will be used to make the logging path unique. If the two ids are given then they are assumed to be unique (they represent a single trial for a participant).\n\n        Args:\n            config (Configuration): configuration\n\n        Raises:\n            FileExistsError: if the derived logging path already exists.\n\n        Returns:\n            Configuration: the configuration (with updated path variables - modified in place)\n        \"\"\"\n        # set the logger path\n        path = Path(config.logging.path).expanduser().resolve()\n        full_path = path\n        if config.experiment.id:\n            full_path = full_path / config.experiment.id\n        if config.participant.id:\n            full_path = full_path / config.participant.id\n\n        if path == full_path:\n            full_path = full_path / datetime.now().strftime(\"%Y%m%d%H%M%S%f\")[:-3]\n\n        if full_path.exists():\n            raise FileExistsError(\n                f\"Logging path: {path} already exists, perhaps you have miss-specified `experiment.id` or `participant.id`?\\n    See &lt;TODO LINK&gt; for details.\"\n            )\n\n        full_path.mkdir(parents=True)\n        LOGGER.debug(f\"Logging to: {full_path.as_posix()}\")\n\n        # log the configuration that is in use\n        with open(full_path / \"configuration.json\", \"w\") as f:\n            f.write(config.model_dump_json(indent=2))\n\n        config.logging.path = full_path.as_posix()\n        return config\n</code></pre>"},{"location":"reference/config/#matbii.config.Configuration.from_file","title":"<code>from_file(path, context=None)</code>  <code>staticmethod</code>","text":"<p>Factory that will build <code>Configuration</code> from a .json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>path to config file.</p> required <code>context</code> <code>dict[str, Any] | None</code> <p>additional context (to override file content). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Configuration</code> <code>Configuration</code> <p>resulting configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>@staticmethod\ndef from_file(\n    path: str | Path | None, context: dict[str, Any] | None = None\n) -&gt; \"Configuration\":\n    \"\"\"Factory that will build `Configuration` from a .json file.\n\n    Args:\n        path (str | Path | None): path to config file.\n        context (dict[str, Any] | None, optional): additional context (to override file content). Defaults to None.\n\n    Returns:\n        Configuration: resulting configuration.\n    \"\"\"\n    context = context if context else {}\n    if path:\n        path = Path(path).expanduser().resolve().as_posix()\n        LOGGER.info(f\"Using config file: {path}\")\n        with open(path) as f:\n            data = json.load(f)\n            data = always_merger.merge(data, context)\n            return Configuration.model_validate(data)\n    else:\n        LOGGER.info(\"No config file was specified, using default configuration.\")\n        return Configuration()\n</code></pre>"},{"location":"reference/config/#matbii.config.Configuration.initialise_logging","title":"<code>initialise_logging(config)</code>  <code>staticmethod</code>","text":"<p>Initialises logging for the given run. This will set logging options and set the config logging path which should be used throughout <code>matbii</code> to log information that may be relevant for experiment post-analysis. The configuration passed here will also be logged to the <code>configuration.json</code> file in the logging path.</p> <p>The logging path will be derived: <code>&lt;config.experiment.id&gt;/&lt;config.participant.id&gt;</code> if these values are present, otherwise a timestamp will be used to make the logging path unique. If the two ids are given then they are assumed to be unique (they represent a single trial for a participant).</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Configuration</code> <p>configuration</p> required <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the derived logging path already exists.</p> <p>Returns:</p> Name Type Description <code>Configuration</code> <code>Configuration</code> <p>the configuration (with updated path variables - modified in place)</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>@staticmethod\ndef initialise_logging(config: \"Configuration\") -&gt; \"Configuration\":\n    \"\"\"Initialises logging for the given run. This will set logging options and set the config logging path which should be used throughout `matbii` to log information that may be relevant for experiment post-analysis. The configuration passed here will also be logged to the `configuration.json` file in the logging path.\n\n    The logging path will be derived: `&lt;config.experiment.id&gt;/&lt;config.participant.id&gt;` if these values are present, otherwise a timestamp will be used to make the logging path unique. If the two ids are given then they are assumed to be unique (they represent a single trial for a participant).\n\n    Args:\n        config (Configuration): configuration\n\n    Raises:\n        FileExistsError: if the derived logging path already exists.\n\n    Returns:\n        Configuration: the configuration (with updated path variables - modified in place)\n    \"\"\"\n    # set the logger path\n    path = Path(config.logging.path).expanduser().resolve()\n    full_path = path\n    if config.experiment.id:\n        full_path = full_path / config.experiment.id\n    if config.participant.id:\n        full_path = full_path / config.participant.id\n\n    if path == full_path:\n        full_path = full_path / datetime.now().strftime(\"%Y%m%d%H%M%S%f\")[:-3]\n\n    if full_path.exists():\n        raise FileExistsError(\n            f\"Logging path: {path} already exists, perhaps you have miss-specified `experiment.id` or `participant.id`?\\n    See &lt;TODO LINK&gt; for details.\"\n        )\n\n    full_path.mkdir(parents=True)\n    LOGGER.debug(f\"Logging to: {full_path.as_posix()}\")\n\n    # log the configuration that is in use\n    with open(full_path / \"configuration.json\", \"w\") as f:\n        f.write(config.model_dump_json(indent=2))\n\n    config.logging.path = full_path.as_posix()\n    return config\n</code></pre>"},{"location":"reference/config/#matbii.config.ExperimentConfiguration","title":"<code>ExperimentConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration relating to the experiment to be run.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class ExperimentConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Configuration relating to the experiment to be run.\"\"\"\n\n    id: str | None = Field(\n        default=None, description=\"The unique ID of this experiment.\"\n    )\n    path: str = Field(\n        # default_factory=lambda: Path(\"./\").resolve().as_posix(),\n        default=\"./\",\n        description=\"The full path to the directory containing task configuration files. If this is a relative path it is relative to the current working directory.\",\n    )\n    duration: int = Field(\n        default=-1,\n        description=\"The duration (in seconds) of this experiment (the simulation will close after this time), a negative value will leave the simulation running forever.\",\n    )\n    enable_video_recording: bool = Field(\n        default=False,\n        description=\"Whether to begin a screen recording of the experiment when the simulation starts, the video will be saved to the logging path when the experiment ends.\",\n    )\n    enable_tasks: list[str] = Field(\n        default=[\"system_monitoring\", \"resource_management\", \"tracking\"],\n        description=\"Which tasks to enable at the start of the simulation.\",\n    )\n    meta: dict = Field(\n        default={},\n        description=\"Any additional meta data you wish to associate with this experiment.\",\n    )\n\n    @field_validator(\"id\", mode=\"before\")\n    @classmethod\n    def _validate_id(cls, value: str | None):\n        if value is None:\n            LOGGER.warning(\"Configuration option: `experiment.id` was set to None\")\n        return value\n\n    @field_validator(\"path\", mode=\"before\")\n    @classmethod\n    def _validate_path(cls, value: str):\n        # we don't want to set it here, it should remain relative, just check that it exists!\n        experiment_path = Path(value).expanduser().resolve()\n        if not experiment_path.exists():\n            raise ValueError(\n                f\"Configuration option `experiment.path` is not valid: `{experiment_path.as_posix()}` does not exist.\"\n            )\n        return value\n</code></pre>"},{"location":"reference/config/#matbii.config.EyetrackingConfiguration","title":"<code>EyetrackingConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration relating to eyetracking.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class EyetrackingConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Configuration relating to eyetracking.\"\"\"\n\n    SUPPORTED_SDKS: ClassVar[tuple[str]] = (\"tobii\",)\n\n    uri: str | None = Field(\n        default=None,\n        description=\"The eye tracker address (example: `'tet-tcp://172.28.195.1'`). If left unspecified `matbii` will attempt to find an eye tracker. For details on setting up eye tracking, consult the [wiki](https://github.com/dicelab-rhul/matbii/wiki/Eyetracking).\",\n    )\n    sdk: str = Field(\n        default=\"tobii\",\n        description=\"The eye tracking SDK to use, current options are: `['tobii']`.\",\n    )\n    enabled: bool = Field(default=False, description=\"Whether eye tracking is enabled.\")\n    moving_average_n: PositiveInt = Field(\n        default=5,\n        description=\"The window size to used to smooth eye tracking coordinates.\",\n    )\n    velocity_threshold: PositiveFloat = Field(\n        default=0.5,\n        description=\"The threshold on gaze velocity which will determine saccades/fixations. This is defined in screen space, where the screen coordinates are normalised in the range [0,1]. **IMPORTANT NOTE:** different monitor sizes may require different values, unfortunately this is difficult to standardise without access to data on the gaze angle (which would be monitor size independent).\",\n    )\n\n    @field_validator(\"sdk\", mode=\"before\")\n    @classmethod\n    def _validate_sdk(cls, value: str):\n        if value not in EyetrackingConfiguration.SUPPORTED_SDKS:\n            raise ValueError(\n                f\"Eyetracker SDK: {value} is not supported, must be one of {EyetrackingConfiguration.SUPPORTED_SDKS}\"\n            )\n        return value\n\n    def new_eyetracking_sensor(self) -&gt; EyetrackerIOSensor | None:\n        \"\"\"Factory method for an eyetracking sensor.\n\n        Returns:\n            EyetrackerIOSensor | None: the sensor, created based on this eyetracking configuration.\n        \"\"\"\n        if self.enabled:\n            eyetracker = self.new_eyetracker()\n            return EyetrackerIOSensor(\n                eyetracker, self.velocity_threshold, self.moving_average_n\n            )\n        return None\n\n    def new_eyetracker(self) -&gt; EyetrackerBase | None:\n        \"\"\"Factory method for an eyetracker.\n\n        Returns:\n            EyetrackerBase | None: the eyetracker created based on this eyetracking configuration.\n        \"\"\"\n        if self.enabled:\n            if self.sdk == \"tobii\":\n                return self._new_tobii_eyetracker()\n            else:\n                raise ValueError(\n                    f\"Eyetracker SDK: {self.sdk} is not supported, must be one of {EyetrackingConfiguration.SUPPORTED_SDKS}\"\n                )\n        return None\n\n    def _new_tobii_eyetracker(self) -&gt; EyetrackerBase:\n        from icua.extras.eyetracking import tobii  # this may fail!\n\n        return tobii.TobiiEyetracker(uri=self.uri)\n</code></pre>"},{"location":"reference/config/#matbii.config.EyetrackingConfiguration.new_eyetracker","title":"<code>new_eyetracker()</code>","text":"<p>Factory method for an eyetracker.</p> <p>Returns:</p> Type Description <code>EyetrackerBase | None</code> <p>EyetrackerBase | None: the eyetracker created based on this eyetracking configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>def new_eyetracker(self) -&gt; EyetrackerBase | None:\n    \"\"\"Factory method for an eyetracker.\n\n    Returns:\n        EyetrackerBase | None: the eyetracker created based on this eyetracking configuration.\n    \"\"\"\n    if self.enabled:\n        if self.sdk == \"tobii\":\n            return self._new_tobii_eyetracker()\n        else:\n            raise ValueError(\n                f\"Eyetracker SDK: {self.sdk} is not supported, must be one of {EyetrackingConfiguration.SUPPORTED_SDKS}\"\n            )\n    return None\n</code></pre>"},{"location":"reference/config/#matbii.config.EyetrackingConfiguration.new_eyetracking_sensor","title":"<code>new_eyetracking_sensor()</code>","text":"<p>Factory method for an eyetracking sensor.</p> <p>Returns:</p> Type Description <code>EyetrackerIOSensor | None</code> <p>EyetrackerIOSensor | None: the sensor, created based on this eyetracking configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>def new_eyetracking_sensor(self) -&gt; EyetrackerIOSensor | None:\n    \"\"\"Factory method for an eyetracking sensor.\n\n    Returns:\n        EyetrackerIOSensor | None: the sensor, created based on this eyetracking configuration.\n    \"\"\"\n    if self.enabled:\n        eyetracker = self.new_eyetracker()\n        return EyetrackerIOSensor(\n            eyetracker, self.velocity_threshold, self.moving_average_n\n        )\n    return None\n</code></pre>"},{"location":"reference/config/#matbii.config.GuidanceConfiguration","title":"<code>GuidanceConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration relating to guidance that may be provided to a user.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class GuidanceConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Configuration relating to guidance that may be provided to a user.\"\"\"\n\n    enable: bool = Field(\n        default=True,\n        description=\"Whether to enable guidance, if this is False then no guidance agent will be created.\",\n    )\n    counter_factual: bool = Field(\n        default=False,\n        description=\"Whether to show guidance to the user, if False then guidance agent will be configured NOT to display guidance but will still take actions for logging purposes (if they support this).\",\n    )\n</code></pre>"},{"location":"reference/config/#matbii.config.LoggingConfiguration","title":"<code>LoggingConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration relating to logging (including event logging).</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class LoggingConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Configuration relating to logging (including event logging).\"\"\"\n\n    level: str = Field(\n        default=\"INFO\",\n        description=\"The logging level to use: ['DEBUG', 'INFO', 'WARNING', 'ERROR'], this will not affect event logging.\",\n    )\n    path: str = Field(\n        default=\"./logs/\",\n        description=\"The path to the directory where log files will be written.\",\n    )\n\n    @field_validator(\"level\", mode=\"before\")\n    @classmethod\n    def _validate_level(cls, value: str):\n        _value = value.upper()\n        if _value not in [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"]:\n            raise ValueError(\n                f\"Configuration option `logging.level` is invalid: `{value}` must be one of: ['DEBUG', 'INFO', 'WARNING', 'ERROR']\"\n            )\n        return _value\n</code></pre>"},{"location":"reference/config/#matbii.config.ParticipantConfiguration","title":"<code>ParticipantConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration relating to the participant (or user).</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class ParticipantConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Configuration relating to the participant (or user).\"\"\"\n\n    id: str | None = Field(\n        default=None,\n        description=\"The unique ID of the participant that is taking part in the experiment.\",\n    )\n    meta: dict = Field(\n        default={},\n        description=\"Any additional meta data you wish to associate with the participant.\",\n    )\n</code></pre>"},{"location":"reference/config/#matbii.config.UIConfiguration","title":"<code>UIConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration relating to rendering and the UI.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class UIConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Configuration relating to rendering and the UI.\"\"\"\n\n    size: tuple[PositiveInt, PositiveInt] = Field(\n        default=(810, 680),\n        description=\"The width and height of the canvas used to render the tasks. This should fully encapsulate all task elements. If a task appears to be off screen, try increasing this value.\",\n    )\n    offset: tuple[NonNegativeInt, NonNegativeInt] = Field(\n        default=(0, 0),\n        description=\"The x and y offset used when rendering the root UI element, can be used to pad the top/left of the window.\",\n    )\n</code></pre>"},{"location":"reference/environment/","title":"Environment","text":"<p>Package defining environment related functionality.</p>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient","title":"<code>MultiTaskAmbient</code>","text":"<p>               Bases: <code>SVGAmbient</code></p> <p>This class manages an SVG state and a collection of tasks that a user may want to interact with. It requires that a special agent the <code>Avatar</code> is provided which will act as an interface between the user and the environment. For details on what a <code>Task</code> is and how they are used see the <code>MultiTaskEnvironment</code> class documentation or read the <code>icua</code> wiki page on tasks (TODO provide a link to this).</p> Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>class MultiTaskAmbient(SVGAmbient):\n    \"\"\"This class manages an SVG state and a collection of tasks that a user may want to interact with. It requires that a special agent the `Avatar` is provided which will act as an interface between the user and the environment. For details on what a `Task` is and how they are used see the `MultiTaskEnvironment` class documentation or read the `icua` wiki page on tasks (TODO provide a link to this).\"\"\"\n\n    def __init__(\n        self,\n        avatar: Agent = None,\n        agents: list[Agent] = None,\n        svg_size: tuple[float, float] = None,\n        svg_position: tuple[float, float] = None,\n        logging_path: str = None,\n        **kwargs,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            avatar (Agent, optional): The users avatar. Defaults to None.\n            agents (list[Agent], optional): list of initial agents. Defaults to None.\n            svg_size (tuple[float, float], optional): size of the root SVG element, typically this should encompase the bounds of all tasks. Defaults to None, which will use the default `SVGAmbient.DEFAULT_SVG_SIZE`.\n            svg_position (tuple[float, float], optional): position of the root SVG element in the UI window. Defaults to None, which which will use the default `SVGAmbient.DEFAULT_SVG_POSITION`.\n            logging_path (str, optional): path that events will be logged to. Defaults to None  (see `MultiTaskAmbient` for details).\n            kwargs (dict[str, Any]): Additional optional keyword arguments, see `SVGAmbient` for options.\n        \"\"\"\n        # this needs to happen before any call to __update__\n        self._event_logger = None\n        self._initialise_logging(logging_path=logging_path)\n        # initialise agents\n        agents = agents if agents else []\n        agents.append(avatar)\n        super().__init__(\n            agents,\n            svg_size=svg_size,\n            svg_position=svg_position,\n            **kwargs,\n        )\n        self._avatar = avatar\n        self._task_loader = TaskLoader()\n        self._tasks: dict[str, Task] = dict()\n\n    def _initialise_logging(self, logging_path: str = None):\n        if logging_path:\n            logging_file = EventLogger.default_log_path(\n                path=logging_path, name=\"event_log_{datetime}.log\"\n            )\n            # general event logging -- all calls to __update__ will trigger this logger\n            self._event_logger = EventLogger(logging_file)\n\n    def add_task(\n        self,\n        name: str,\n        path: str | list[str],\n        agent_actuators: list[Callable[[], Actuator]] | None = None,\n        avatar_actuators: list[Callable[[], Actuator]] | None = None,\n        enable: bool = False,\n    ):\n        \"\"\"Add a new task, this will load all required files and prepare the task but will not start the task (unless `enable` is True). To start the task use `enable_task` or have an agent take the `EnableTask` action.\n\n        Args:\n            name (str): the unique name of the task.\n            path (str | list[str]): path(s) to task files.\n            agent_actuators (list[Callable[[], Actuator]] | None, optional): actuators with which to create agents from a schedule file, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n            avatar_actuators (list[Callable[[], Actuator]] | None, optional): actuators that will be added to the avatar upon enabling the task, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n            enable (bool, optional): whether to immediately enable the task. Defaults to False.\n        \"\"\"\n        if name in self._tasks:\n            raise ValueError(f\"Task with name {name} already exists.\")\n        if agent_actuators is None:\n            agent_actuators = []\n        if avatar_actuators is None:\n            avatar_actuators = []\n        self._task_loader.register_task(name, path)\n        self._tasks[name] = self._task_loader.load(\n            name, avatar_actuators=avatar_actuators, agent_actuators=agent_actuators\n        )\n        if enable:\n            self.enable_task(name)\n\n    def enable_task(\n        self, task_name: str, context: dict[str, Any] | None = None, insert_at: int = -1\n    ):\n        \"\"\"Manually enable a task. Tasks may otherwise be enabled via an `EnableTask` action.\n\n        Args:\n            task_name (str): name of the task to enable.\n            context (dict[str,Any]): context to use when enabling the task\n            insert_at (int): at what position in the SVG tree to insert the task element.\n        \"\"\"\n        event = EnableTask(\n            source=self.id, task_name=task_name, context=context, insert_at=insert_at\n        )\n        result = self.__update__(event)\n        if isinstance(result, ErrorActiveObservation):\n            raise result.exception()\n\n    def disable_task(self, task_name: str):\n        \"\"\"Manually disable a task. Tasks may otherwise be disabled via an `EnableTask` action.\n\n        Args:\n            task_name (str): name of the task to disable.\n        \"\"\"\n        event = DisableTask(source=self.id, task_name=task_name)\n        result = self.__update__(event)\n        if isinstance(result, ErrorActiveObservation):\n            raise result.exception()\n\n    def rename_task(self, task_name: str, new_name: str) -&gt; None:\n        \"\"\"Rename a task. If the task is enabled this will alter the `id` attribute of the task element (TODO).\n\n        Args:\n            task_name (str): current name of the task.\n            new_name (str): new name of the task.\n        \"\"\"\n        if task_name in self._tasks:\n            if new_name in self._tasks:\n                raise ValueError(\n                    f\"Failed to rename task: {task_name}, another take with name: {new_name} already exists.\"\n                )\n            task = self._tasks[new_name]\n            self._tasks[task_name] = task\n            task.task_name = new_name\n            del self._tasks[task_name]\n            # TODO update the name of the task element if it has been enabled!\n        else:\n            raise ValueError(f\"Failed to rename task: {task_name} as it doesn't exist.\")\n\n    def __update__(self, action: Event) -&gt; ActiveObservation | ErrorActiveObservation:  # noqa\n        # always log the action immediately (before execution)\n        if self._event_logger:\n            self._event_logger.log(action)\n        # execute the action here or in super()\n        if isinstance(action, EnableTask):\n            return self._enable_task(action)\n        elif isinstance(action, DisableTask):\n            return self._disable_task(action)\n        elif isinstance(action, INERT_ACTIONS):\n            # these actions have no effect but are important for experiment logging\n            return None\n        else:\n            return super().__update__(action)\n\n    def on_user_input_event(  # noqa\n        self,\n        action: EyeMotionEvent\n        | EyeMotionEventRaw\n        | MouseButtonEvent\n        | MouseMotionEvent\n        | KeyEvent\n        | WindowCloseEvent\n        | WindowOpenEvent\n        | WindowFocusEvent\n        | WindowMoveEvent\n        | WindowResizeEvent\n        | ScreenSizeEvent,\n    ):\n        return super().on_user_input_event(action)\n\n    def is_task_enabled(self, task_name: str) -&gt; bool:\n        \"\"\"Is the given task enabled? Specially, is the task element part of the state? This will search for an element with `id` equal to the name of the task.\n\n        Note that if the `id` of the task element has been changed elsewherethen this will not give the expected result. This will not happen with correct use of `MultiTaskAmbient`.\n\n        Args:\n            task_name (str): name of the task to check.\n\n        Returns:\n            bool: True if the task is enabled (is part of the state), False otherwise.\n        \"\"\"\n        try:\n            result = self._state.select(\n                Select.new(f\"/svg:svg/*[@id='{task_name}']\", [\"id\"])\n            )\n        except XPathElementsNotFound:\n            return False\n        return result is not None and len(result) &gt; 0\n\n    @wrap_observation\n    def _disable_task(self, event: DisableTask):\n        \"\"\"Disables a task - this will be called when a `DisableTask` event is received.\"\"\"\n        raise NotImplementedError(\"TODO\")  # TODO\n\n    @wrap_observation\n    def _enable_task(\n        self, event: EnableTask\n    ) -&gt; ActiveObservation | ErrorActiveObservation:\n        \"\"\"Enables a task - this will be called when an `EnableTask` event is received.\"\"\"\n        task = self._tasks[event.task_name]\n        # TODO this assumes that the id of the task is \"task_name\"!\n        if self.is_task_enabled(event.task_name):\n            raise ValueError(f\"Task {event.task_name} is already enabled.\")\n        agent = task.get_agent()\n        if agent:\n            self.add_agent(agent)\n        avatar = task.get_avatar(self._avatar)\n        # this should not change... the task should only add relevant actuators\n        assert self._avatar == avatar\n        # default is to insert as the first child of the root\n        # TODO we need to check what the task 'id' is to keep track of which tasks are enabled and active!\n        return self.__update__(\n            Insert.new(\n                xpath=\"/svg:svg\",\n                element=task.get_xml(event.context),\n                index=event.insert_at,\n            )\n        )\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient.__init__","title":"<code>__init__(avatar=None, agents=None, svg_size=None, svg_position=None, logging_path=None, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>avatar</code> <code>Agent</code> <p>The users avatar. Defaults to None.</p> <code>None</code> <code>agents</code> <code>list[Agent]</code> <p>list of initial agents. Defaults to None.</p> <code>None</code> <code>svg_size</code> <code>tuple[float, float]</code> <p>size of the root SVG element, typically this should encompase the bounds of all tasks. Defaults to None, which will use the default <code>SVGAmbient.DEFAULT_SVG_SIZE</code>.</p> <code>None</code> <code>svg_position</code> <code>tuple[float, float]</code> <p>position of the root SVG element in the UI window. Defaults to None, which which will use the default <code>SVGAmbient.DEFAULT_SVG_POSITION</code>.</p> <code>None</code> <code>logging_path</code> <code>str</code> <p>path that events will be logged to. Defaults to None  (see <code>MultiTaskAmbient</code> for details).</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Additional optional keyword arguments, see <code>SVGAmbient</code> for options.</p> <code>{}</code> Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>def __init__(\n    self,\n    avatar: Agent = None,\n    agents: list[Agent] = None,\n    svg_size: tuple[float, float] = None,\n    svg_position: tuple[float, float] = None,\n    logging_path: str = None,\n    **kwargs,\n):\n    \"\"\"Constructor.\n\n    Args:\n        avatar (Agent, optional): The users avatar. Defaults to None.\n        agents (list[Agent], optional): list of initial agents. Defaults to None.\n        svg_size (tuple[float, float], optional): size of the root SVG element, typically this should encompase the bounds of all tasks. Defaults to None, which will use the default `SVGAmbient.DEFAULT_SVG_SIZE`.\n        svg_position (tuple[float, float], optional): position of the root SVG element in the UI window. Defaults to None, which which will use the default `SVGAmbient.DEFAULT_SVG_POSITION`.\n        logging_path (str, optional): path that events will be logged to. Defaults to None  (see `MultiTaskAmbient` for details).\n        kwargs (dict[str, Any]): Additional optional keyword arguments, see `SVGAmbient` for options.\n    \"\"\"\n    # this needs to happen before any call to __update__\n    self._event_logger = None\n    self._initialise_logging(logging_path=logging_path)\n    # initialise agents\n    agents = agents if agents else []\n    agents.append(avatar)\n    super().__init__(\n        agents,\n        svg_size=svg_size,\n        svg_position=svg_position,\n        **kwargs,\n    )\n    self._avatar = avatar\n    self._task_loader = TaskLoader()\n    self._tasks: dict[str, Task] = dict()\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient.add_task","title":"<code>add_task(name, path, agent_actuators=None, avatar_actuators=None, enable=False)</code>","text":"<p>Add a new task, this will load all required files and prepare the task but will not start the task (unless <code>enable</code> is True). To start the task use <code>enable_task</code> or have an agent take the <code>EnableTask</code> action.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the unique name of the task.</p> required <code>path</code> <code>str | list[str]</code> <p>path(s) to task files.</p> required <code>agent_actuators</code> <code>list[Callable[[], Actuator]] | None</code> <p>actuators with which to create agents from a schedule file, see <code>MultiTaskEnvironment</code> documentation for details. Defaults to None.</p> <code>None</code> <code>avatar_actuators</code> <code>list[Callable[[], Actuator]] | None</code> <p>actuators that will be added to the avatar upon enabling the task, see <code>MultiTaskEnvironment</code> documentation for details. Defaults to None.</p> <code>None</code> <code>enable</code> <code>bool</code> <p>whether to immediately enable the task. Defaults to False.</p> <code>False</code> Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>def add_task(\n    self,\n    name: str,\n    path: str | list[str],\n    agent_actuators: list[Callable[[], Actuator]] | None = None,\n    avatar_actuators: list[Callable[[], Actuator]] | None = None,\n    enable: bool = False,\n):\n    \"\"\"Add a new task, this will load all required files and prepare the task but will not start the task (unless `enable` is True). To start the task use `enable_task` or have an agent take the `EnableTask` action.\n\n    Args:\n        name (str): the unique name of the task.\n        path (str | list[str]): path(s) to task files.\n        agent_actuators (list[Callable[[], Actuator]] | None, optional): actuators with which to create agents from a schedule file, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n        avatar_actuators (list[Callable[[], Actuator]] | None, optional): actuators that will be added to the avatar upon enabling the task, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n        enable (bool, optional): whether to immediately enable the task. Defaults to False.\n    \"\"\"\n    if name in self._tasks:\n        raise ValueError(f\"Task with name {name} already exists.\")\n    if agent_actuators is None:\n        agent_actuators = []\n    if avatar_actuators is None:\n        avatar_actuators = []\n    self._task_loader.register_task(name, path)\n    self._tasks[name] = self._task_loader.load(\n        name, avatar_actuators=avatar_actuators, agent_actuators=agent_actuators\n    )\n    if enable:\n        self.enable_task(name)\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient.disable_task","title":"<code>disable_task(task_name)</code>","text":"<p>Manually disable a task. Tasks may otherwise be disabled via an <code>EnableTask</code> action.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>name of the task to disable.</p> required Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>def disable_task(self, task_name: str):\n    \"\"\"Manually disable a task. Tasks may otherwise be disabled via an `EnableTask` action.\n\n    Args:\n        task_name (str): name of the task to disable.\n    \"\"\"\n    event = DisableTask(source=self.id, task_name=task_name)\n    result = self.__update__(event)\n    if isinstance(result, ErrorActiveObservation):\n        raise result.exception()\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient.enable_task","title":"<code>enable_task(task_name, context=None, insert_at=-1)</code>","text":"<p>Manually enable a task. Tasks may otherwise be enabled via an <code>EnableTask</code> action.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>name of the task to enable.</p> required <code>context</code> <code>dict[str, Any]</code> <p>context to use when enabling the task</p> <code>None</code> <code>insert_at</code> <code>int</code> <p>at what position in the SVG tree to insert the task element.</p> <code>-1</code> Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>def enable_task(\n    self, task_name: str, context: dict[str, Any] | None = None, insert_at: int = -1\n):\n    \"\"\"Manually enable a task. Tasks may otherwise be enabled via an `EnableTask` action.\n\n    Args:\n        task_name (str): name of the task to enable.\n        context (dict[str,Any]): context to use when enabling the task\n        insert_at (int): at what position in the SVG tree to insert the task element.\n    \"\"\"\n    event = EnableTask(\n        source=self.id, task_name=task_name, context=context, insert_at=insert_at\n    )\n    result = self.__update__(event)\n    if isinstance(result, ErrorActiveObservation):\n        raise result.exception()\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient.is_task_enabled","title":"<code>is_task_enabled(task_name)</code>","text":"<p>Is the given task enabled? Specially, is the task element part of the state? This will search for an element with <code>id</code> equal to the name of the task.</p> <p>Note that if the <code>id</code> of the task element has been changed elsewherethen this will not give the expected result. This will not happen with correct use of <code>MultiTaskAmbient</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>name of the task to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the task is enabled (is part of the state), False otherwise.</p> Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>def is_task_enabled(self, task_name: str) -&gt; bool:\n    \"\"\"Is the given task enabled? Specially, is the task element part of the state? This will search for an element with `id` equal to the name of the task.\n\n    Note that if the `id` of the task element has been changed elsewherethen this will not give the expected result. This will not happen with correct use of `MultiTaskAmbient`.\n\n    Args:\n        task_name (str): name of the task to check.\n\n    Returns:\n        bool: True if the task is enabled (is part of the state), False otherwise.\n    \"\"\"\n    try:\n        result = self._state.select(\n            Select.new(f\"/svg:svg/*[@id='{task_name}']\", [\"id\"])\n        )\n    except XPathElementsNotFound:\n        return False\n    return result is not None and len(result) &gt; 0\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskAmbient.rename_task","title":"<code>rename_task(task_name, new_name)</code>","text":"<p>Rename a task. If the task is enabled this will alter the <code>id</code> attribute of the task element (TODO).</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>current name of the task.</p> required <code>new_name</code> <code>str</code> <p>new name of the task.</p> required Source code in <code>icua\\environment\\multitask_ambient.py</code> <pre><code>def rename_task(self, task_name: str, new_name: str) -&gt; None:\n    \"\"\"Rename a task. If the task is enabled this will alter the `id` attribute of the task element (TODO).\n\n    Args:\n        task_name (str): current name of the task.\n        new_name (str): new name of the task.\n    \"\"\"\n    if task_name in self._tasks:\n        if new_name in self._tasks:\n            raise ValueError(\n                f\"Failed to rename task: {task_name}, another take with name: {new_name} already exists.\"\n            )\n        task = self._tasks[new_name]\n        self._tasks[task_name] = task\n        task.task_name = new_name\n        del self._tasks[task_name]\n        # TODO update the name of the task element if it has been enabled!\n    else:\n        raise ValueError(f\"Failed to rename task: {task_name} as it doesn't exist.\")\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment","title":"<code>MultiTaskEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Environment implementation that supports \"tasks\". A task is a modular part of the environment which the user typically interacts with via their <code>Avatar</code>. Tasks will typially have an associated agent that updates/manages the tasks state. The users avatar should also provide some means to interact with tasks. When a new task is added, this may mean the avatar gains a new actuator and will often mean that a new agent is added to the environment.</p> <p>TODO a thorough explaination of what tasks are and how to define/use them!</p> See <p><code>MultiTaskAmbient</code></p> Source code in <code>icua\\environment\\multitask_environment.py</code> <pre><code>class MultiTaskEnvironment(Environment):\n    \"\"\"Environment implementation that supports \"tasks\". A task is a modular part of the environment which the user typically interacts with via their `Avatar`. Tasks will typially have an associated agent that updates/manages the tasks state. The users avatar should also provide some means to interact with tasks. When a new task is added, this may mean the avatar gains a new actuator and will often mean that a new agent is added to the environment.\n\n    TODO a thorough explaination of what tasks are and how to define/use them!\n\n    See:\n        `MultiTaskAmbient`\n    \"\"\"\n\n    def __init__(\n        self,\n        avatar: Agent,\n        agents: list[Agent] = None,\n        wait: float = 0.01,\n        svg_size: tuple[float, float] = None,\n        svg_position: tuple[float, float] = None,\n        logging_path: str = None,\n        terminate_after: float = -1,\n        **kwargs: dict[str, Any],\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            avatar (Agent, optional): The users avatar. Defaults to None.\n            agents (list[Agent], optional): list of initial agents. Defaults to None.\n            wait (float, optional): time to wait between simulation cycles. Defaults to 0.01.\n            svg_size (tuple[float, float], optional): size of the root SVG element. Defaults to None (see `MultiTaskAmbient` for details).\n            svg_position (tuple[float, float], optional): position of the root SVG element. Defaults to None (see `MultiTaskAmbient` for details).\n            logging_path (str, optional): path that events will be logged to. Defaults to None (see `MultiTaskAmbient` for details).\n            terminate_after (float, optional): time after which to terminate the simulatio. Defaults to -1 (never terminate).\n            kwargs (dict[str, Any]): Additional optional keyword arguments, see `MultiTaskAmbient` for options.\n        \"\"\"\n        ambient = MultiTaskAmbient(\n            avatar=avatar,\n            agents=agents,\n            logging_path=logging_path,\n            svg_size=svg_size,\n            svg_position=svg_position,\n            **kwargs,\n        )\n        super().__init__(\n            ambient=ambient,\n            wait=wait,\n            sync=True,\n        )\n        # time until termination\n        self._terminate_after = terminate_after\n\n    @property\n    def ambient(self) -&gt; MultiTaskAmbient:\n        \"\"\"Getter for the inner ambient, which is always a `MultiTaskAmbient`. IMPORTANT NOTE: remote ambients are not currently supported.\n\n        Returns:\n            MultiTaskAmbient: the ambient.\n        \"\"\"\n        ambient = self._ambient._inner\n        # TODO remote ambient currently not supported - this would be easy to do... (just need relevant methods exposed)\n        assert isinstance(ambient, MultiTaskAmbient)\n        return ambient\n\n    def enable_task(\n        self, task_name: str, context: dict[str, Any] = None, insert_at: int = -1\n    ):\n        \"\"\"Manually enable a task. Tasks may otherwise be enabled via an `EnableTask` action.\n\n        Args:\n            task_name (str): name of the task to enable.\n            context (dict[str,Any]): context to use when enabling the task\n            insert_at (int): at what position in the SVG tree to insert the task element.\n        \"\"\"\n        self.ambient.enable_task(task_name, context=context, insert_at=insert_at)\n\n    def disable_task(self, task_name: str):\n        \"\"\"Manually disable a task. Tasks may otherwise be disabled via an `EnableTask` action.\n\n        Args:\n            task_name (str): name of the task to disable.\n        \"\"\"\n        self.ambient.disable_task(task_name)\n\n    def rename_task(self, task_name: str, new_name: str) -&gt; None:\n        \"\"\"Rename a task. If the task is enabled this will alter the `id` attribute of the task element (TODO).\n\n        Args:\n            task_name (str): current name of the task.\n            new_name (str): new name of the task.\n        \"\"\"\n        return self.ambient.rename_task(task_name, new_name)\n\n    def add_task(\n        self,\n        name: str,\n        path: str,\n        agent_actuators: list[Callable[[], Actuator]] = None,\n        avatar_actuators: list[Callable[[], Actuator]] = None,\n        enable: bool = False,\n    ):\n        \"\"\"Add a new task, this will load all required files and prepare the task but will not start the task (unless `enable` is True). To start the task use `enable_task` or have an agent take the `EnableTask` action.\n\n        Args:\n            name (str): the unique name of the task.\n            path (str | list[str]): path(s) to task files.\n            agent_actuators (list[Callable[[], Actuator]] | None, optional): actuators with which to create agents from a schedule file, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n            avatar_actuators (list[Callable[[], Actuator]] | None, optional): actuators that will be added to the avatar upon enabling the task, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n            enable (bool, optional): whether to immediately enable the task. Defaults to False.\n        \"\"\"\n        # attempt to log the files that will be used in the task\n        self.ambient.add_task(\n            name,\n            path,\n            agent_actuators=agent_actuators,\n            avatar_actuators=avatar_actuators,\n            enable=enable,\n        )\n\n    async def __initialise__(self, event_loop):  # noqa\n        await self._ambient.__initialise__()\n\n    def get_schedule(self) -&gt; list[asyncio.Task]:  # noqa\n        tasks = super().get_schedule()\n        # whether to terminate after a given period of time\n        if self._terminate_after &gt; 0:\n\n            async def _terminate_after(env: MultiTaskEnvironment):\n                try:\n                    await asyncio.sleep(env._terminate_after)\n                    # TODO perhaps this should be an event that is logged?\n                    LOGGER.debug(\n                        f\"Closing simulation: time limit ({env._terminate_after}s) reached\"\n                    )\n                    await env.ambient.__terminate__()\n                except asyncio.CancelledError:\n                    pass\n                except asyncio.TimeoutError:\n                    pass\n\n            tasks.append(asyncio.create_task(_terminate_after(self)))\n        return tasks\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment.ambient","title":"<code>ambient: MultiTaskAmbient</code>  <code>property</code>","text":"<p>Getter for the inner ambient, which is always a <code>MultiTaskAmbient</code>. IMPORTANT NOTE: remote ambients are not currently supported.</p> <p>Returns:</p> Name Type Description <code>MultiTaskAmbient</code> <code>MultiTaskAmbient</code> <p>the ambient.</p>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment.__init__","title":"<code>__init__(avatar, agents=None, wait=0.01, svg_size=None, svg_position=None, logging_path=None, terminate_after=-1, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>avatar</code> <code>Agent</code> <p>The users avatar. Defaults to None.</p> required <code>agents</code> <code>list[Agent]</code> <p>list of initial agents. Defaults to None.</p> <code>None</code> <code>wait</code> <code>float</code> <p>time to wait between simulation cycles. Defaults to 0.01.</p> <code>0.01</code> <code>svg_size</code> <code>tuple[float, float]</code> <p>size of the root SVG element. Defaults to None (see <code>MultiTaskAmbient</code> for details).</p> <code>None</code> <code>svg_position</code> <code>tuple[float, float]</code> <p>position of the root SVG element. Defaults to None (see <code>MultiTaskAmbient</code> for details).</p> <code>None</code> <code>logging_path</code> <code>str</code> <p>path that events will be logged to. Defaults to None (see <code>MultiTaskAmbient</code> for details).</p> <code>None</code> <code>terminate_after</code> <code>float</code> <p>time after which to terminate the simulatio. Defaults to -1 (never terminate).</p> <code>-1</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Additional optional keyword arguments, see <code>MultiTaskAmbient</code> for options.</p> <code>{}</code> Source code in <code>icua\\environment\\multitask_environment.py</code> <pre><code>def __init__(\n    self,\n    avatar: Agent,\n    agents: list[Agent] = None,\n    wait: float = 0.01,\n    svg_size: tuple[float, float] = None,\n    svg_position: tuple[float, float] = None,\n    logging_path: str = None,\n    terminate_after: float = -1,\n    **kwargs: dict[str, Any],\n):\n    \"\"\"Constructor.\n\n    Args:\n        avatar (Agent, optional): The users avatar. Defaults to None.\n        agents (list[Agent], optional): list of initial agents. Defaults to None.\n        wait (float, optional): time to wait between simulation cycles. Defaults to 0.01.\n        svg_size (tuple[float, float], optional): size of the root SVG element. Defaults to None (see `MultiTaskAmbient` for details).\n        svg_position (tuple[float, float], optional): position of the root SVG element. Defaults to None (see `MultiTaskAmbient` for details).\n        logging_path (str, optional): path that events will be logged to. Defaults to None (see `MultiTaskAmbient` for details).\n        terminate_after (float, optional): time after which to terminate the simulatio. Defaults to -1 (never terminate).\n        kwargs (dict[str, Any]): Additional optional keyword arguments, see `MultiTaskAmbient` for options.\n    \"\"\"\n    ambient = MultiTaskAmbient(\n        avatar=avatar,\n        agents=agents,\n        logging_path=logging_path,\n        svg_size=svg_size,\n        svg_position=svg_position,\n        **kwargs,\n    )\n    super().__init__(\n        ambient=ambient,\n        wait=wait,\n        sync=True,\n    )\n    # time until termination\n    self._terminate_after = terminate_after\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment.add_task","title":"<code>add_task(name, path, agent_actuators=None, avatar_actuators=None, enable=False)</code>","text":"<p>Add a new task, this will load all required files and prepare the task but will not start the task (unless <code>enable</code> is True). To start the task use <code>enable_task</code> or have an agent take the <code>EnableTask</code> action.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the unique name of the task.</p> required <code>path</code> <code>str | list[str]</code> <p>path(s) to task files.</p> required <code>agent_actuators</code> <code>list[Callable[[], Actuator]] | None</code> <p>actuators with which to create agents from a schedule file, see <code>MultiTaskEnvironment</code> documentation for details. Defaults to None.</p> <code>None</code> <code>avatar_actuators</code> <code>list[Callable[[], Actuator]] | None</code> <p>actuators that will be added to the avatar upon enabling the task, see <code>MultiTaskEnvironment</code> documentation for details. Defaults to None.</p> <code>None</code> <code>enable</code> <code>bool</code> <p>whether to immediately enable the task. Defaults to False.</p> <code>False</code> Source code in <code>icua\\environment\\multitask_environment.py</code> <pre><code>def add_task(\n    self,\n    name: str,\n    path: str,\n    agent_actuators: list[Callable[[], Actuator]] = None,\n    avatar_actuators: list[Callable[[], Actuator]] = None,\n    enable: bool = False,\n):\n    \"\"\"Add a new task, this will load all required files and prepare the task but will not start the task (unless `enable` is True). To start the task use `enable_task` or have an agent take the `EnableTask` action.\n\n    Args:\n        name (str): the unique name of the task.\n        path (str | list[str]): path(s) to task files.\n        agent_actuators (list[Callable[[], Actuator]] | None, optional): actuators with which to create agents from a schedule file, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n        avatar_actuators (list[Callable[[], Actuator]] | None, optional): actuators that will be added to the avatar upon enabling the task, see `MultiTaskEnvironment` documentation for details. Defaults to None.\n        enable (bool, optional): whether to immediately enable the task. Defaults to False.\n    \"\"\"\n    # attempt to log the files that will be used in the task\n    self.ambient.add_task(\n        name,\n        path,\n        agent_actuators=agent_actuators,\n        avatar_actuators=avatar_actuators,\n        enable=enable,\n    )\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment.disable_task","title":"<code>disable_task(task_name)</code>","text":"<p>Manually disable a task. Tasks may otherwise be disabled via an <code>EnableTask</code> action.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>name of the task to disable.</p> required Source code in <code>icua\\environment\\multitask_environment.py</code> <pre><code>def disable_task(self, task_name: str):\n    \"\"\"Manually disable a task. Tasks may otherwise be disabled via an `EnableTask` action.\n\n    Args:\n        task_name (str): name of the task to disable.\n    \"\"\"\n    self.ambient.disable_task(task_name)\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment.enable_task","title":"<code>enable_task(task_name, context=None, insert_at=-1)</code>","text":"<p>Manually enable a task. Tasks may otherwise be enabled via an <code>EnableTask</code> action.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>name of the task to enable.</p> required <code>context</code> <code>dict[str, Any]</code> <p>context to use when enabling the task</p> <code>None</code> <code>insert_at</code> <code>int</code> <p>at what position in the SVG tree to insert the task element.</p> <code>-1</code> Source code in <code>icua\\environment\\multitask_environment.py</code> <pre><code>def enable_task(\n    self, task_name: str, context: dict[str, Any] = None, insert_at: int = -1\n):\n    \"\"\"Manually enable a task. Tasks may otherwise be enabled via an `EnableTask` action.\n\n    Args:\n        task_name (str): name of the task to enable.\n        context (dict[str,Any]): context to use when enabling the task\n        insert_at (int): at what position in the SVG tree to insert the task element.\n    \"\"\"\n    self.ambient.enable_task(task_name, context=context, insert_at=insert_at)\n</code></pre>"},{"location":"reference/environment/#matbii.environment.MultiTaskEnvironment.rename_task","title":"<code>rename_task(task_name, new_name)</code>","text":"<p>Rename a task. If the task is enabled this will alter the <code>id</code> attribute of the task element (TODO).</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>current name of the task.</p> required <code>new_name</code> <code>str</code> <p>new name of the task.</p> required Source code in <code>icua\\environment\\multitask_environment.py</code> <pre><code>def rename_task(self, task_name: str, new_name: str) -&gt; None:\n    \"\"\"Rename a task. If the task is enabled this will alter the `id` attribute of the task element (TODO).\n\n    Args:\n        task_name (str): current name of the task.\n        new_name (str): new name of the task.\n    \"\"\"\n    return self.ambient.rename_task(task_name, new_name)\n</code></pre>"},{"location":"reference/guidance/","title":"Guidance","text":"<p>Package defining guidance related functionality.</p>"},{"location":"reference/guidance/#modules","title":"Modules","text":"<ul> <li>matbii/guidance/agent_base.py</li> <li>matbii/guidance/agent_default.py</li> <li>matbii/guidance/sensor_guidance.py</li> <li>matbii/guidance/sensor_resource_management.py</li> <li>matbii/guidance/sensor_system_monitoring.py</li> <li>matbii/guidance/sensor_tracking.py</li> </ul>"},{"location":"reference/guidance/agent_base/","title":"Agent base","text":"<p>Module containing the base class for matbii guidance agents, see <code>GuidanceAgent</code> documentation for details.</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent","title":"<code>GuidanceAgent</code>","text":"<p>               Bases: <code>GuidanceAgent</code></p> <p>Base class for matbii guidance agents.</p> <p>This class implements belief logging, assuming it has an attached <code>LogActuator</code>. Any updates to beliefs are logged by the actuator at the end of each cycle (during execute). This information, along with the raw event logs can be used for post-experiment analysis. Working with the guidance agent's beliefs may be easier than with the raw event logs as they contain relevant guidance &amp; task acceptability info and custom data can be added in any subclass (simply by updating <code>self.beliefs</code>).</p> Source code in <code>matbii\\guidance\\agent_base.py</code> <pre><code>class GuidanceAgent(_GuidanceAgent):\n    \"\"\"Base class for matbii guidance agents.\n\n    This class implements belief logging, assuming it has an attached `LogActuator`. Any updates to beliefs are logged by the actuator at the end of each cycle (during __execute__). This information, along with the raw event logs can be used for post-experiment analysis. Working with the guidance agent's beliefs may be easier than with the raw event logs as they contain relevant guidance &amp; task acceptability info and custom data can be added in any subclass (simply by updating `self.beliefs`).\n    \"\"\"\n\n    def __init__(  # noqa inherited docs\n        self,\n        sensors: list[Sensor],\n        actuators: list[Actuator],\n        user_input_events: tuple[type[Event]] = None,\n        user_input_events_history_size: int | list[int] = 50,\n    ):\n        super().__init__(\n            sensors, actuators, user_input_events, user_input_events_history_size\n        )\n        # these are used to look at differences in beliefs for logging purposes, old beliefs are copied at the end of each cycle (see __execute__)\n        self._old_beliefs = deepcopy(self.beliefs)\n\n    def log_belief(self, belief: dict[str, Any] | Event) -&gt; None:\n        \"\"\"Method that is intended for logging the beliefs of this agent to a file. This can be very useful for keeping track of the state of the simulation, user input, task acceptability and guidance for post analysis purposes.\n\n        Requires `icua.extras.logging.LogActuator` be attached to this agent and will otherwise have no effect. Logging can be configured in the `LogActuator`, including the way that beliefs are formatted in the file.\n\n        Note that the belief wont be logged immediately, but will be buffered as an action and logged as part of usual action execution cycle (on execute).\n\n        Args:\n            belief (dict[str, Any]): belief to log\n        \"\"\"\n        actuator: LogActuator = next(iter(self.get_actuators(oftype=LogActuator)), None)\n        if actuator:\n            actuator.log(belief)\n        else:\n            LOGGER.warning(\n                \"Attempted to log a belief without the required actuator: `icua.extras.logging.LogActuator`\"\n            )\n\n    def __execute__(self, state: State, *args, **kwargs):  # noqa\n        # always call this at the end of the cycle (when all beliefs have been updated in subclass)\n        diff = dict_diff(self._old_beliefs, self.beliefs)\n        if diff:\n            # there were some updates to the beliefs, log them and update old beliefs to reflect these changes\n            self.log_belief(self.beliefs)  # differences in beliefs\n            self._old_beliefs = deepcopy(self.beliefs)\n            # print(diff)\n\n        # t = time.time()\n        # print(t - self._timestamp)\n        # self._timestamp = t\n        super().__execute__(state, *args, **kwargs)\n\n    # this is manually added to the event router (see __init__), so no @observe here\n    def on_user_input(self, observation: Event):\n        \"\"\"Called when this agent receives a user input event, it will add the event to an internal buffer. See `get_latest_user_input`.\n\n        This method should not be called manually and will be handled by this agents event routing mechanism.\n\n        Args:\n            observation (Any): the observation.\n        \"\"\"\n        super().on_user_input(observation)\n        # TODO may move this into `log_beliefs` and just use the event buffer.\n        # log all user input events as beliefs\n        # self.log_belief(observation)\n\n    # ================================================================================================ #\n    # =============================== Below are some useful properties =============================== #\n    # ================================================================================================ #\n\n    @property\n    def has_eyetracker(self) -&gt; bool:\n        \"\"\"Whether this agent has an attached `EyetrackerIOSensor`.\n\n        Returns:\n            bool: Whether this agent has an attached `EyetrackerIOSensor`\n        \"\"\"\n        return len(self.get_sensors(oftype=EyetrackerIOSensor)) &gt; 0\n\n    @property\n    def mouse_at_elements(self) -&gt; list[str]:\n        \"\"\"Getter for the elements that the mouse pointer is currently over (according to this agents beliefs).\n\n        Returns:\n            List[str]: list of element ids that the mouse pointer is currently over.\n        \"\"\"\n        try:\n            return next(self.get_latest_user_input(MouseMotionEvent)).target\n        except StopIteration:\n            return []\n\n    @property\n    def mouse_position(self) -&gt; dict[str, Any]:\n        \"\"\"Getter for the user's current mouse position (according to this agents beliefs).\n\n        Returns:\n            Dict[str, Any]: dict containing the `timestamp` and mouse `position` (in svg coordinate space).\n        \"\"\"\n        try:\n            event = next(self.get_latest_user_input(MouseMotionEvent))\n            return dict(timestamp=event.timestamp, position=event.position)\n        except StopIteration:\n            return None\n\n    @property\n    def gaze_at_elements(self) -&gt; list[str]:\n        \"\"\"Getter for the elements that the user is currently gazing at (according to this agents beliefs).\n\n        Returns:\n            List[str]: list of element id's that the user is currently gazing at.\n        \"\"\"\n        try:\n            return next(self.get_latest_user_input(EyeMotionEvent)).target\n        except StopIteration:\n            return []\n\n    @property\n    def gaze_position(self) -&gt; dict[str, Any]:\n        \"\"\"Getter for the user's current gaze position (according to this agents beliefs).\n\n        Returns:\n            Dict[str, Any]: dict containing the `timestamp` and gaze `position` (in svg coordinate space).\n        \"\"\"\n        try:\n            event = next(self.get_latest_user_input(EyeMotionEvent))\n            return dict(timestamp=event.timestamp, position=event.position)\n        except StopIteration:\n            return None\n</code></pre>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.gaze_at_elements","title":"<code>gaze_at_elements: list[str]</code>  <code>property</code>","text":"<p>Getter for the elements that the user is currently gazing at (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: list of element id's that the user is currently gazing at.</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.gaze_position","title":"<code>gaze_position: dict[str, Any]</code>  <code>property</code>","text":"<p>Getter for the user's current gaze position (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: dict containing the <code>timestamp</code> and gaze <code>position</code> (in svg coordinate space).</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.has_eyetracker","title":"<code>has_eyetracker: bool</code>  <code>property</code>","text":"<p>Whether this agent has an attached <code>EyetrackerIOSensor</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether this agent has an attached <code>EyetrackerIOSensor</code></p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.mouse_at_elements","title":"<code>mouse_at_elements: list[str]</code>  <code>property</code>","text":"<p>Getter for the elements that the mouse pointer is currently over (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: list of element ids that the mouse pointer is currently over.</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.mouse_position","title":"<code>mouse_position: dict[str, Any]</code>  <code>property</code>","text":"<p>Getter for the user's current mouse position (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: dict containing the <code>timestamp</code> and mouse <code>position</code> (in svg coordinate space).</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.log_belief","title":"<code>log_belief(belief)</code>","text":"<p>Method that is intended for logging the beliefs of this agent to a file. This can be very useful for keeping track of the state of the simulation, user input, task acceptability and guidance for post analysis purposes.</p> <p>Requires <code>icua.extras.logging.LogActuator</code> be attached to this agent and will otherwise have no effect. Logging can be configured in the <code>LogActuator</code>, including the way that beliefs are formatted in the file.</p> <p>Note that the belief wont be logged immediately, but will be buffered as an action and logged as part of usual action execution cycle (on execute).</p> <p>Parameters:</p> Name Type Description Default <code>belief</code> <code>dict[str, Any]</code> <p>belief to log</p> required Source code in <code>matbii\\guidance\\agent_base.py</code> <pre><code>def log_belief(self, belief: dict[str, Any] | Event) -&gt; None:\n    \"\"\"Method that is intended for logging the beliefs of this agent to a file. This can be very useful for keeping track of the state of the simulation, user input, task acceptability and guidance for post analysis purposes.\n\n    Requires `icua.extras.logging.LogActuator` be attached to this agent and will otherwise have no effect. Logging can be configured in the `LogActuator`, including the way that beliefs are formatted in the file.\n\n    Note that the belief wont be logged immediately, but will be buffered as an action and logged as part of usual action execution cycle (on execute).\n\n    Args:\n        belief (dict[str, Any]): belief to log\n    \"\"\"\n    actuator: LogActuator = next(iter(self.get_actuators(oftype=LogActuator)), None)\n    if actuator:\n        actuator.log(belief)\n    else:\n        LOGGER.warning(\n            \"Attempted to log a belief without the required actuator: `icua.extras.logging.LogActuator`\"\n        )\n</code></pre>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.on_user_input","title":"<code>on_user_input(observation)</code>","text":"<p>Called when this agent receives a user input event, it will add the event to an internal buffer. See <code>get_latest_user_input</code>.</p> <p>This method should not be called manually and will be handled by this agents event routing mechanism.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>Any</code> <p>the observation.</p> required Source code in <code>matbii\\guidance\\agent_base.py</code> <pre><code>def on_user_input(self, observation: Event):\n    \"\"\"Called when this agent receives a user input event, it will add the event to an internal buffer. See `get_latest_user_input`.\n\n    This method should not be called manually and will be handled by this agents event routing mechanism.\n\n    Args:\n        observation (Any): the observation.\n    \"\"\"\n    super().on_user_input(observation)\n</code></pre>"},{"location":"reference/guidance/agent_default/","title":"Agent default","text":"<p>Module contains a default implementation for a guidance agent, see <code>DefaultGuidanceAgent</code> documentation for details.</p>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator","title":"<code>ArrowGuidanceActuator</code>","text":"<p>               Bases: <code>GuidanceActuator</code></p> <p>A concrete implementation of <code>GuidanceActuator</code> that implements a guidance arrow. The arrow is displayed at the users mouse (or gaze) position that points towards a given task element, typically this task will be one that is not in an acceptible state.</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>class ArrowGuidanceActuator(GuidanceActuator):\n    \"\"\"A concrete implementation of `GuidanceActuator` that implements a guidance arrow. The arrow is displayed at the users mouse (or gaze) position that points towards a given task element, typically this task will be one that is not in an acceptible state.\"\"\"\n\n    ARROW_MODES = Literal[\"gaze\", \"mouse\", \"fixed\"]\n\n    def __init__(\n        self,\n        arrow_mode: Literal[\"gaze\", \"mouse\", \"fixed\"],\n        arrow_scale: float = 1.0,\n        arrow_fill_color: str = \"none\",\n        arrow_stroke_color: str = \"#ff0000\",\n        arrow_stroke_width: float = 4.0,\n        arrow_offset: tuple[float, float] = (80, 80),\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            arrow_mode (Literal): modes for arrow display,\n            arrow_scale (float, optional): scale of the arrow. Defaults to 1.0.\n            arrow_fill_color (str, optional): fill colour of the arrow. Defaults to \"none\".\n            arrow_stroke_color (str, optional): line colour of the arrow outlien. Defaults to \"#ff0000\".\n            arrow_stroke_width (float, optional): line width of the arrow outline. Defaults to 4.0.\n            arrow_offset (tuple[float, float], optional): offset of the arrow from its set position. Defaults to (80, 80).\n\n        Raises:\n            ValueError: _description_\n        \"\"\"\n        super().__init__()\n        self._arrow_mode = arrow_mode\n        self._arrow_scale = arrow_scale\n        self._arrow_fill_color = arrow_fill_color\n        self._arrow_stroke_color = arrow_stroke_color\n        self._arrow_stroke_width = arrow_stroke_width\n        self._arrow_offset = arrow_offset\n\n        if self._arrow_mode not in ArrowGuidanceActuator.ARROW_MODES.__args__:\n            raise ValueError(\n                f\"Invalid argument: `arrow_mode` must be one of {ArrowGuidanceActuator.ARROW_MODES}\"\n            )\n        self._guidance_arrow_id = \"guidance_arrow\"\n        self._guidance_on = None\n        self._gaze_position = None\n        self._mouse_position = None\n\n    def __attempt__(self):  # noqa\n        if self._guidance_on is None:\n            return []\n        elif self._arrow_mode == \"gaze\":\n            # eyetracking positions can be nan, dont update the position if they are?\n            if isfinite(self._gaze_position[0]) and isfinite(self._gaze_position[1]):\n                attrs = dict(\n                    id=self._guidance_arrow_id,\n                    x=self._gaze_position[0] + self._arrow_offset[0],\n                    y=self._gaze_position[1] + self._arrow_offset[0],\n                    point_to=self._guidance_on,\n                )\n                return [DrawArrowAction(xpath=\"/svg:svg\", data=attrs)]\n            else:\n                LOGGER.warning(\"Ignoring NaN arrow position.\")\n            return []\n        elif self._arrow_mode == \"mouse\":\n            if self._mouse_position:\n                attrs = dict(\n                    id=self._guidance_arrow_id,\n                    x=self._mouse_position[0] + self._arrow_offset[0],\n                    y=self._mouse_position[1] + self._arrow_offset[0],\n                    point_to=self._guidance_on,\n                )\n                return [DrawArrowAction(xpath=\"/svg:svg\", data=attrs)]\n            return []\n        elif self._arrow_mode == \"fixed\":\n            # TODO where should it be? the center of the screen?\n            raise NotImplementedError(\"TODO\")\n        else:\n            raise ValueError(\n                f\"Invalid argument: `arrow_mode` must be one of {ArrowGuidanceActuator.ARROW_MODES}\"\n            )\n\n    @attempt([EyeMotionEvent])\n    def set_gaze_position(self, action: EyeMotionEvent) -&gt; None:\n        \"\"\"Sets the users current gaze position. This may be used as a position for arrow display.\"\"\"\n        self._gaze_position = action.position\n\n    @attempt([MouseMotionEvent])\n    def set_mouse_motion(self, action: MouseMotionEvent) -&gt; None:\n        \"\"\"Sets the users current mouse position. This may be used as a position for arrow display.\"\"\"\n        self._mouse_position = action.position\n\n    def on_add(self, agent: Agent) -&gt; None:  # noqa\n        super().on_add(agent)\n        self.draw_guidance_arrow(\n            self._guidance_arrow_id,\n            0.0,\n            0.0,\n            fill=self._arrow_fill_color,\n            stroke_width=self._arrow_stroke_width,\n            stroke_color=self._arrow_stroke_color,\n            opacity=0.0,\n            scale=self._arrow_scale,\n        )\n\n    def on_remove(self, agent: Agent) -&gt; None:  # noqa\n        super().on_remove(agent)\n        # TODO remove arrow element!\n\n    @attempt()\n    def draw_guidance_arrow(\n        self,\n        name: str,\n        x: float,\n        y: float,\n        scale: float = 1.0,\n        rotation: float = 0.0,\n        fill: str = \"none\",\n        opacity: float = 0.0,\n        stroke_color: str = \"#ff0000\",\n        stroke_width: float = 2.0,\n        **kwargs,\n    ) -&gt; DrawArrowAction:\n        \"\"\"Attempt method that takes an action to draw a guidance arrow.\n\n        Args:\n            name (str): id.\n            x (float): x position.\n            y (float): y position.\n            scale (float, optional): scale. Defaults to 1.0.\n            rotation (float, optional): rotation. Defaults to 0.0.\n            fill (str, optional): fill color. Defaults to \"none\".\n            opacity (float, optional): opacity (0.0 means hidden). Defaults to 0.0.\n            stroke_color (str, optional): color of the arrow border. Defaults to \"#ff0000\".\n            stroke_width (float, optional): thickness of the arrow border. Defaults to 2.0.\n            kwargs : (dict[str,Any]): additional optional keyword arguments.\n\n        Returns:\n            DrawArrowAction: action\n        \"\"\"\n        return DrawArrowAction(\n            xpath=\"/svg:svg\",\n            data=dict(\n                id=name,\n                x=x,\n                y=y,\n                scale=scale,\n                rotation=rotation,\n                fill=fill,\n                opacity=opacity,\n                stroke=stroke_color,\n                stroke_width=stroke_width,\n                **kwargs,\n            ),\n        )\n\n    @attempt()\n    def show_guidance(self, task: str):\n        \"\"\"Show guidance on the given task.\n\n        Args:\n            task (str): task to show guidance for.\n\n        Returns:\n            list[Action]: guidance actions\n        \"\"\"\n        self._guidance_on = task\n        actions = [\n            ShowElementAction(xpath=f\"//*[@id='{self._guidance_arrow_id}']\"),\n        ]\n        return actions\n\n    @attempt()\n    def hide_guidance(self, task: str):\n        \"\"\"Hide guidance on the given task.\n\n        Args:\n            task (str): task to hide guidance for.\n\n        Returns:\n            list[Action]: guidance actions\n        \"\"\"\n        self._guidance_on = None\n        actions = [\n            HideElementAction(xpath=f\"//*[@id='{self._guidance_arrow_id}']\"),\n        ]\n        return actions\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator.__init__","title":"<code>__init__(arrow_mode, arrow_scale=1.0, arrow_fill_color='none', arrow_stroke_color='#ff0000', arrow_stroke_width=4.0, arrow_offset=(80, 80))</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>arrow_mode</code> <code>Literal</code> <p>modes for arrow display,</p> required <code>arrow_scale</code> <code>float</code> <p>scale of the arrow. Defaults to 1.0.</p> <code>1.0</code> <code>arrow_fill_color</code> <code>str</code> <p>fill colour of the arrow. Defaults to \"none\".</p> <code>'none'</code> <code>arrow_stroke_color</code> <code>str</code> <p>line colour of the arrow outlien. Defaults to \"#ff0000\".</p> <code>'#ff0000'</code> <code>arrow_stroke_width</code> <code>float</code> <p>line width of the arrow outline. Defaults to 4.0.</p> <code>4.0</code> <code>arrow_offset</code> <code>tuple[float, float]</code> <p>offset of the arrow from its set position. Defaults to (80, 80).</p> <code>(80, 80)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>def __init__(\n    self,\n    arrow_mode: Literal[\"gaze\", \"mouse\", \"fixed\"],\n    arrow_scale: float = 1.0,\n    arrow_fill_color: str = \"none\",\n    arrow_stroke_color: str = \"#ff0000\",\n    arrow_stroke_width: float = 4.0,\n    arrow_offset: tuple[float, float] = (80, 80),\n):\n    \"\"\"Constructor.\n\n    Args:\n        arrow_mode (Literal): modes for arrow display,\n        arrow_scale (float, optional): scale of the arrow. Defaults to 1.0.\n        arrow_fill_color (str, optional): fill colour of the arrow. Defaults to \"none\".\n        arrow_stroke_color (str, optional): line colour of the arrow outlien. Defaults to \"#ff0000\".\n        arrow_stroke_width (float, optional): line width of the arrow outline. Defaults to 4.0.\n        arrow_offset (tuple[float, float], optional): offset of the arrow from its set position. Defaults to (80, 80).\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n    super().__init__()\n    self._arrow_mode = arrow_mode\n    self._arrow_scale = arrow_scale\n    self._arrow_fill_color = arrow_fill_color\n    self._arrow_stroke_color = arrow_stroke_color\n    self._arrow_stroke_width = arrow_stroke_width\n    self._arrow_offset = arrow_offset\n\n    if self._arrow_mode not in ArrowGuidanceActuator.ARROW_MODES.__args__:\n        raise ValueError(\n            f\"Invalid argument: `arrow_mode` must be one of {ArrowGuidanceActuator.ARROW_MODES}\"\n        )\n    self._guidance_arrow_id = \"guidance_arrow\"\n    self._guidance_on = None\n    self._gaze_position = None\n    self._mouse_position = None\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator.draw_guidance_arrow","title":"<code>draw_guidance_arrow(name, x, y, scale=1.0, rotation=0.0, fill='none', opacity=0.0, stroke_color='#ff0000', stroke_width=2.0, **kwargs)</code>","text":"<p>Attempt method that takes an action to draw a guidance arrow.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>id.</p> required <code>x</code> <code>float</code> <p>x position.</p> required <code>y</code> <code>float</code> <p>y position.</p> required <code>scale</code> <code>float</code> <p>scale. Defaults to 1.0.</p> <code>1.0</code> <code>rotation</code> <code>float</code> <p>rotation. Defaults to 0.0.</p> <code>0.0</code> <code>fill</code> <code>str</code> <p>fill color. Defaults to \"none\".</p> <code>'none'</code> <code>opacity</code> <code>float</code> <p>opacity (0.0 means hidden). Defaults to 0.0.</p> <code>0.0</code> <code>stroke_color</code> <code>str</code> <p>color of the arrow border. Defaults to \"#ff0000\".</p> <code>'#ff0000'</code> <code>stroke_width</code> <code>float</code> <p>thickness of the arrow border. Defaults to 2.0.</p> <code>2.0</code> <code>kwargs</code> <p>(dict[str,Any]): additional optional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DrawArrowAction</code> <code>DrawArrowAction</code> <p>action</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt()\ndef draw_guidance_arrow(\n    self,\n    name: str,\n    x: float,\n    y: float,\n    scale: float = 1.0,\n    rotation: float = 0.0,\n    fill: str = \"none\",\n    opacity: float = 0.0,\n    stroke_color: str = \"#ff0000\",\n    stroke_width: float = 2.0,\n    **kwargs,\n) -&gt; DrawArrowAction:\n    \"\"\"Attempt method that takes an action to draw a guidance arrow.\n\n    Args:\n        name (str): id.\n        x (float): x position.\n        y (float): y position.\n        scale (float, optional): scale. Defaults to 1.0.\n        rotation (float, optional): rotation. Defaults to 0.0.\n        fill (str, optional): fill color. Defaults to \"none\".\n        opacity (float, optional): opacity (0.0 means hidden). Defaults to 0.0.\n        stroke_color (str, optional): color of the arrow border. Defaults to \"#ff0000\".\n        stroke_width (float, optional): thickness of the arrow border. Defaults to 2.0.\n        kwargs : (dict[str,Any]): additional optional keyword arguments.\n\n    Returns:\n        DrawArrowAction: action\n    \"\"\"\n    return DrawArrowAction(\n        xpath=\"/svg:svg\",\n        data=dict(\n            id=name,\n            x=x,\n            y=y,\n            scale=scale,\n            rotation=rotation,\n            fill=fill,\n            opacity=opacity,\n            stroke=stroke_color,\n            stroke_width=stroke_width,\n            **kwargs,\n        ),\n    )\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator.hide_guidance","title":"<code>hide_guidance(task)</code>","text":"<p>Hide guidance on the given task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>task to hide guidance for.</p> required <p>Returns:</p> Type Description <p>list[Action]: guidance actions</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt()\ndef hide_guidance(self, task: str):\n    \"\"\"Hide guidance on the given task.\n\n    Args:\n        task (str): task to hide guidance for.\n\n    Returns:\n        list[Action]: guidance actions\n    \"\"\"\n    self._guidance_on = None\n    actions = [\n        HideElementAction(xpath=f\"//*[@id='{self._guidance_arrow_id}']\"),\n    ]\n    return actions\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator.set_gaze_position","title":"<code>set_gaze_position(action)</code>","text":"<p>Sets the users current gaze position. This may be used as a position for arrow display.</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt([EyeMotionEvent])\ndef set_gaze_position(self, action: EyeMotionEvent) -&gt; None:\n    \"\"\"Sets the users current gaze position. This may be used as a position for arrow display.\"\"\"\n    self._gaze_position = action.position\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator.set_mouse_motion","title":"<code>set_mouse_motion(action)</code>","text":"<p>Sets the users current mouse position. This may be used as a position for arrow display.</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt([MouseMotionEvent])\ndef set_mouse_motion(self, action: MouseMotionEvent) -&gt; None:\n    \"\"\"Sets the users current mouse position. This may be used as a position for arrow display.\"\"\"\n    self._mouse_position = action.position\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.ArrowGuidanceActuator.show_guidance","title":"<code>show_guidance(task)</code>","text":"<p>Show guidance on the given task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>task to show guidance for.</p> required <p>Returns:</p> Type Description <p>list[Action]: guidance actions</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt()\ndef show_guidance(self, task: str):\n    \"\"\"Show guidance on the given task.\n\n    Args:\n        task (str): task to show guidance for.\n\n    Returns:\n        list[Action]: guidance actions\n    \"\"\"\n    self._guidance_on = task\n    actions = [\n        ShowElementAction(xpath=f\"//*[@id='{self._guidance_arrow_id}']\"),\n    ]\n    return actions\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.BoxGuidanceActuator","title":"<code>BoxGuidanceActuator</code>","text":"<p>               Bases: <code>GuidanceActuator</code></p> <p>A concrete implementation of <code>GuidanceActuator</code> that implements box guidance. The box bounds a given task element serving to highlight it to the user, typically the task will be one that is not in an acceptible state.</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>class BoxGuidanceActuator(GuidanceActuator):\n    \"\"\"A concrete implementation of `GuidanceActuator` that implements box guidance. The box bounds a given task element serving to highlight it to the user, typically the task will be one that is not in an acceptible state.\"\"\"\n\n    def __init__(\n        self,\n        box_stroke_color: str = \"#ff0000\",\n        box_stroke_width: float = 4.0,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            box_stroke_color (str, optional): color of the box. Defaults to \"#ff0000\".\n            box_stroke_width (float, optional): width of the box outline. Defaults to 4.0.\n        \"\"\"\n        super().__init__()\n        self._box_stroke_color = box_stroke_color\n        self._box_stroke_width = box_stroke_width\n        self._guidance_box_id_template = \"guidance_box_%s\"\n        # ids of each of the guidance boxes that have been created TODO this should be removed when `on_remove` is called!\n        self._guidance_boxes = set()\n\n    def on_remove(self, agent: Agent) -&gt; None:  # noqa\n        return super().on_remove(agent)  # TODO remove all guidance boxes!\n\n    @attempt()\n    def draw_guidance_box_on_element(\n        self, element_id: str, **box_data: dict[str, Any]\n    ) -&gt; DrawBoxOnElementAction:\n        \"\"\"Attempt method that will draw a box around a given element.\n\n        Args:\n            element_id (str): the `id` of the element.\n            box_data (dict[str,Any]): data associated with the box.\n\n        Returns:\n            DrawBoxOnElementAction: action\n        \"\"\"\n        # TODO explicit parameters for box data\n        box_data[\"id\"] = self._guidance_box_id_template % element_id\n        return DrawBoxOnElementAction(\n            xpath=f\"//*[@id='{element_id}']\", box_data=box_data\n        )\n\n    @attempt()\n    def show_guidance(self, task: str) -&gt; list[Action]:\n        \"\"\"Show guidance on the given task.\n\n        Args:\n            task (str): task to show guidance for.\n\n        Returns:\n            list[Action]: guidance actions\n        \"\"\"\n        self._guidance_on = task\n        guidance_box_id = self._guidance_box_id_template % task\n\n        actions = []\n\n        if guidance_box_id not in self._guidance_boxes:\n            # first time! insert the guidance box\n            self._guidance_boxes.add(guidance_box_id)\n            box_data = {\n                \"stroke-width\": self._box_stroke_width,\n                \"stroke\": self._box_stroke_color,\n            }\n            # draw the box but it is hidden (opacity=0)\n            actions.append(\n                self.draw_guidance_box_on_element(task, opacity=0.0, **box_data)\n            )\n        actions.append(ShowElementAction(xpath=f\"//*[@id='{guidance_box_id}']\"))\n        return actions\n\n    @attempt()\n    def hide_guidance(self, task: str):\n        \"\"\"Hide guidance on the given task.\n\n        Args:\n            task (str): task to hide guidance for.\n\n        Returns:\n            list[Action]: guidance actions\n        \"\"\"\n        self._guidance_on = None\n        guidance_box_id = self._guidance_box_id_template % task\n\n        actions = []\n\n        if guidance_box_id not in self._guidance_boxes:\n            # first time! insert the guidance box\n            self._guidance_boxes.add(guidance_box_id)\n            box_data = {\n                \"stroke-width\": self._box_stroke_width,\n                \"stroke\": self._box_stroke_color,\n            }\n            # draw the box but it is hidden (opacity=0)\n            actions.append(\n                self.draw_guidance_box_on_element(task, opacity=0.0, **box_data)\n            )\n        actions.append(HideElementAction(xpath=f\"//*[@id='{guidance_box_id}']\"))\n        return actions\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.BoxGuidanceActuator.__init__","title":"<code>__init__(box_stroke_color='#ff0000', box_stroke_width=4.0)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>box_stroke_color</code> <code>str</code> <p>color of the box. Defaults to \"#ff0000\".</p> <code>'#ff0000'</code> <code>box_stroke_width</code> <code>float</code> <p>width of the box outline. Defaults to 4.0.</p> <code>4.0</code> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>def __init__(\n    self,\n    box_stroke_color: str = \"#ff0000\",\n    box_stroke_width: float = 4.0,\n):\n    \"\"\"Constructor.\n\n    Args:\n        box_stroke_color (str, optional): color of the box. Defaults to \"#ff0000\".\n        box_stroke_width (float, optional): width of the box outline. Defaults to 4.0.\n    \"\"\"\n    super().__init__()\n    self._box_stroke_color = box_stroke_color\n    self._box_stroke_width = box_stroke_width\n    self._guidance_box_id_template = \"guidance_box_%s\"\n    # ids of each of the guidance boxes that have been created TODO this should be removed when `on_remove` is called!\n    self._guidance_boxes = set()\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.BoxGuidanceActuator.draw_guidance_box_on_element","title":"<code>draw_guidance_box_on_element(element_id, **box_data)</code>","text":"<p>Attempt method that will draw a box around a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>the <code>id</code> of the element.</p> required <code>box_data</code> <code>dict[str, Any]</code> <p>data associated with the box.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DrawBoxOnElementAction</code> <code>DrawBoxOnElementAction</code> <p>action</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt()\ndef draw_guidance_box_on_element(\n    self, element_id: str, **box_data: dict[str, Any]\n) -&gt; DrawBoxOnElementAction:\n    \"\"\"Attempt method that will draw a box around a given element.\n\n    Args:\n        element_id (str): the `id` of the element.\n        box_data (dict[str,Any]): data associated with the box.\n\n    Returns:\n        DrawBoxOnElementAction: action\n    \"\"\"\n    # TODO explicit parameters for box data\n    box_data[\"id\"] = self._guidance_box_id_template % element_id\n    return DrawBoxOnElementAction(\n        xpath=f\"//*[@id='{element_id}']\", box_data=box_data\n    )\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.BoxGuidanceActuator.hide_guidance","title":"<code>hide_guidance(task)</code>","text":"<p>Hide guidance on the given task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>task to hide guidance for.</p> required <p>Returns:</p> Type Description <p>list[Action]: guidance actions</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt()\ndef hide_guidance(self, task: str):\n    \"\"\"Hide guidance on the given task.\n\n    Args:\n        task (str): task to hide guidance for.\n\n    Returns:\n        list[Action]: guidance actions\n    \"\"\"\n    self._guidance_on = None\n    guidance_box_id = self._guidance_box_id_template % task\n\n    actions = []\n\n    if guidance_box_id not in self._guidance_boxes:\n        # first time! insert the guidance box\n        self._guidance_boxes.add(guidance_box_id)\n        box_data = {\n            \"stroke-width\": self._box_stroke_width,\n            \"stroke\": self._box_stroke_color,\n        }\n        # draw the box but it is hidden (opacity=0)\n        actions.append(\n            self.draw_guidance_box_on_element(task, opacity=0.0, **box_data)\n        )\n    actions.append(HideElementAction(xpath=f\"//*[@id='{guidance_box_id}']\"))\n    return actions\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.BoxGuidanceActuator.show_guidance","title":"<code>show_guidance(task)</code>","text":"<p>Show guidance on the given task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>task to show guidance for.</p> required <p>Returns:</p> Type Description <code>list[Action]</code> <p>list[Action]: guidance actions</p> Source code in <code>icua\\agent\\actuator_guidance.py</code> <pre><code>@attempt()\ndef show_guidance(self, task: str) -&gt; list[Action]:\n    \"\"\"Show guidance on the given task.\n\n    Args:\n        task (str): task to show guidance for.\n\n    Returns:\n        list[Action]: guidance actions\n    \"\"\"\n    self._guidance_on = task\n    guidance_box_id = self._guidance_box_id_template % task\n\n    actions = []\n\n    if guidance_box_id not in self._guidance_boxes:\n        # first time! insert the guidance box\n        self._guidance_boxes.add(guidance_box_id)\n        box_data = {\n            \"stroke-width\": self._box_stroke_width,\n            \"stroke\": self._box_stroke_color,\n        }\n        # draw the box but it is hidden (opacity=0)\n        actions.append(\n            self.draw_guidance_box_on_element(task, opacity=0.0, **box_data)\n        )\n    actions.append(ShowElementAction(xpath=f\"//*[@id='{guidance_box_id}']\"))\n    return actions\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent","title":"<code>DefaultGuidanceAgent</code>","text":"<p>               Bases: <code>GuidanceAgent</code></p> <p>Default implementation of a guidance agent for the matbii system.</p> <p>TODO document</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>class DefaultGuidanceAgent(GuidanceAgent):\n    \"\"\"Default implementation of a guidance agent for the matbii system.\n\n    TODO document\n    \"\"\"\n\n    # used to break ties when multiple tasks could be highlighted. See `break_guidance_tie` method below.\n    BREAK_TIES = (\"random\", \"longest\", \"since\")\n\n    # if we havent had fresh eyetracking data for more than this, there may be something wrong... display a warning\n    MISSING_GAZE_DATA_THRESHOLD = 0.1\n\n    def __init__(\n        self,\n        sensors: list[Sensor],\n        actuators: list[Actuator],\n        break_ties: Literal[\"random\", \"longest\", \"since\"] = \"random\",\n        attention_mode: Literal[\"gaze\", \"mouse\"] = \"mouse\",\n        grace_period: float = 3.0,\n        counter_factual: bool = False,\n        **kwargs: dict[str, Any],\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            sensors (list[Sensor]): list of sensors, this will typically be a list of `icua.agent.TaskAcceptabilitySensor`s. A `UserInputSensor` will always be added automatically.\n            actuators (list[Actuator]): list of actuators, this will typically contain actuators that are capable of providing visual feedback to a user, see e.g. `icua.agent.GuidanceActuator` and its concrete implementations. A `CounterFactualGuidanceActuator` will be added by default.\n            break_ties (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest time.\n            attention_mode (Literal[\"gaze\", \"mouse\"], optional): method of determining where the user is paying attention. \"mouse\" will track the mouse position, \"gaze\" will track the gaze position (if avaliable). Defaults to \"mouse\".\n            grace_period (float, optional): the time to wait (seconds) before guidance may be shown for a task after the last time guidance was shown on the task. Defaults to 3.0 seconds.\n            counter_factual (bool, optional): whether guidance should be shown to the user, or whether it should just be logged.  This allows counter-factual experiments to be run, we can track when guidance would have been shown, and compare the when it was actually shown (in a different run). Defaults to False.\n            kwargs (dict[str,Any]): Additional optional keyword arguments.\n        \"\"\"\n        _counter_factual_guidance_actuator = CounterFactualGuidanceActuator()\n        actuators.append(_counter_factual_guidance_actuator)\n        super().__init__(sensors, actuators, **kwargs)\n\n        # this agent is tracking the following tasks (based on the provided sensors)\n        self._tracking_tasks = [s.task_name for s in self.task_acceptability_sensors]\n        # initialise beliefs (empty)\n        for task in self._tracking_tasks:\n            self.beliefs[task] = dict(guidance=False)\n        # also record some attention information (for logging)\n        self.beliefs[\"attention\"] = dict()\n\n        # time since tasks went into an unacceptable state\n        self._task_unacceptable_start: dict[str, float] = None\n        # time since tasks become inactive\n        self._task_inactive_start: dict[str, float] = None\n        # TODO track the time since user input (gaze) has been provided, we can trigger an error if this is too long\n        self._missing_gaze_since: float = None\n        # guidance shown on task?\n        self._guidance_on_task: str = None\n        # time since guidance was shown for each task (for grace period)\n        self._guidance_last: dict[str, float] = None\n        # method to use to break ties when more than one task meets the guidance criteria\n        self._break_ties = break_ties  # (\"random\", \"longest\", \"since\")\n        if self._break_ties not in (\"random\", \"longest\", \"since\"):\n            raise ValueError(\n                f\"Invalid argument: `break_ties` {self._break_ties} must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n            )\n        # time to wait before showing guidance again on a task (can be zero)\n        self._grace_period = grace_period  # TODO\n        if self._grace_period &lt; 0.0:\n            raise ValueError(\n                f\"Invalid argument: `grace_period` {self._grace_period} must be &gt; 0 \"\n            )\n        # whether to actually display guidance, or just trigger a guidance event\n        self._counter_factual = counter_factual\n        self._counter_factual_guidance_actuator = _counter_factual_guidance_actuator\n        self._attention_mode = attention_mode\n\n    def __initialise__(self, state: State):  # noqa\n        super().__initialise__(state)\n        # initialise task unacceptability and inactivity\n        start_time = time.time()  # not accurate but good enough\n        self._task_inactive_start = {t: start_time for t in self._tracking_tasks}\n        self._task_unacceptable_start = {t: start_time for t in self._tracking_tasks}\n        # initialise time to last guidance shown\n        self._guidance_last = {t: start_time for t in self._tracking_tasks}\n\n    def show_guidance(self, task: str):\n        \"\"\"Show guidance for a given task.\n\n        If overriding you must call super() to ensure consistent behaviour.\n\n        Args:\n            task (str): the task to show guidance for.\n        \"\"\"\n        self._guidance_on_task = task\n        self.beliefs[task][\"guidance\"] = True\n        if not self._counter_factual:\n            for actuator in self.guidance_actuators:\n                actuator.show_guidance(task=task)\n        else:\n            self._counter_factual_guidance_actuator.show_guidance(task=task)\n\n    def hide_guidance(self, task: str):\n        \"\"\"Hide guidance for a given task.\n\n        If overriding you must call super() to ensure consistent behaviour.\n\n        Args:\n            task (str): the task to hide guidance for.\n        \"\"\"\n        if self._guidance_on_task:\n            self.beliefs[self._guidance_on_task][\"guidance\"] = False\n        self._guidance_on_task = None\n        if not self._counter_factual:\n            for actuator in self.guidance_actuators:\n                actuator.hide_guidance(task=task)\n        else:\n            self._counter_factual_guidance_actuator.hide_guidance(task=task)\n\n        # update the last time guidance was shown for the given task (for the grace period check)\n        self._guidance_last[task] = time.time()\n\n    def get_inactive_tasks(self) -&gt; set[str]:\n        \"\"\"Get the set of inactive tasks.\n\n        Returns:\n            set[str]: set of inactive tasks.\n        \"\"\"\n        active = list(self._is_task_active.items())\n        return set([x[0] for x in active if not x[1]])\n\n    def get_unacceptable_tasks(self) -&gt; set[str]:\n        \"\"\"Get the set of unacceptable tasks.\n\n        Returns:\n            set[str]: set of unacceptable tasks.\n        \"\"\"\n        unacceptable = list(self._is_task_acceptable.items())\n        # is the task in an unacceptable state? (remove if they are acceptable)\n        unacceptable = set([x[0] for x in unacceptable if not x[1]])\n        # remove all inactive tasks (never display guidance for these)\n        unacceptable -= self.get_inactive_tasks()\n        return unacceptable\n\n    def get_attending(self):\n        \"\"\"Get attention data from mouse or eyetracker.\"\"\"\n        if self._attention_mode == \"gaze\":\n            elements, gaze = self.gaze_at_elements, self.gaze_position\n            # check if the gaze data is None, if so we need to see how long and give a warning, it may indicate that the eyetracker\n            # has stopped functioning which may invalidate an experimental trial!\n            if gaze is None:\n                if self._missing_gaze_since is None:\n                    self._missing_gaze_since = time.time()\n                elif (\n                    time.time() - self._missing_gaze_since\n                    &gt; DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD\n                ):\n                    LOGGER.warning(\n                        f\"No fresh gaze data for longer than: { DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD}s\"\n                    )\n                return {\"elements\": elements}\n            else:\n                self._missing_gaze_since = None\n            # gaze data may be present, but it may be old (its stored in a buffer until fresh data arrives)\n            if (\n                time.time() - gaze[\"timestamp\"]\n                &gt; DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD\n            ):\n                LOGGER.warning(\n                    f\"No fresh gaze data for longer than: { DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD}s\"\n                )\n            return {\"elements\": elements, **(gaze if gaze else {})}\n        elif self._attention_mode == \"mouse\":\n            position_data = self.mouse_position\n            return {\n                \"elements\": self.mouse_at_elements,\n                **(position_data if position_data else {}),\n            }\n        else:\n            raise ValueError(f\"Unknown attention mode: {self._attention_mode}\")\n\n    def __cycle__(self):  # noqa\n        super().__cycle__()\n        attending = self.get_attending()\n        att_to = attending[\"elements\"]\n\n        # TODO we might also care about recording other info in the event!\n        # this is the one that is being used by the agent to make its guidance decisions either way...\n        self.beliefs[\"attention\"][\"timestamp\"] = attending.get(\"timestamp\")\n        self.beliefs[\"attention\"][\"position\"] = attending.get(\"position\")\n        self.beliefs[\"attention\"][\"attending\"] = next(\n            iter([e for e in att_to if e in self._tracking_tasks]), None\n        )\n\n        # =================================================== #\n        # here the agent is deciding whether to show guidance\n        # it uses the same rules as icua version 1 (TODO check this)\n        # =================================================== #\n        if self._guidance_on_task:\n            # guidance is active, should it be?\n            if self._is_task_acceptable[self._guidance_on_task]:\n                # the task is now acceptable - hide guidance for this task\n                self.hide_guidance(self._guidance_on_task)\n            if self._guidance_on_task in att_to:\n                # turn off guidance, the user is looking at the task - hide guidance\n                self.hide_guidance(self._guidance_on_task)\n            else:\n                # the user is not looking at the task and its unacceptable, keep guidance on.\n                pass\n        else:\n            current_time = time.time()\n            # guidance is not active, should it be?\n            unacceptable = self.get_unacceptable_tasks()\n            # is the user looking at the task? (remove if they are)\n            unacceptable = [x for x in unacceptable if x not in att_to]\n            # is the grace period over for the task?\n            unacceptable = [\n                x\n                for x in unacceptable\n                if current_time - self._guidance_last[x] &gt; self._grace_period\n            ]\n            if len(unacceptable) &gt; 0:\n                # there are tasks in failure, decide which one to highlight\n                task = self.break_guidance_tie(unacceptable, self._break_ties)\n                self.show_guidance(task)  # show guidance on the chosen task\n            else:\n                pass  # no task is in failure, no guidance should be shown.\n\n    def break_guidance_tie(\n        self, tasks: list[str], method: Literal[\"random\", \"longest\", \"since\"] = \"random\"\n    ) -&gt; str:\n        \"\"\"Break a tie on tasks that all met the criteria for displaying guiance.\n\n        Args:\n            tasks (list[str]): tasks to break the tie, one of which will be returned.\n            method (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.\n\n        Returns:\n            str: the chosen task.\n        \"\"\"\n        assert len(tasks) &gt; 0\n        if method == \"random\":\n            # randomly break the tie\n            return random.choice(tasks)\n        elif method == \"longest\":\n            return max(\n                [(x, self._task_unacceptable_start[x]) for x in tasks],\n                key=lambda x: x[1],\n            )[0]\n            # choose the one longest in failure\n        elif method == \"since\":\n            # choose the one with with the longest time since guidance was last shown\n            return max(\n                [(x, self._guidance_last[x]) for x in tasks], key=lambda x: x[1]\n            )[0]\n        else:\n            raise ValueError(\n                f\"Unknown guidance tie break method: {self._break_ties}, must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n            )\n\n    def on_acceptable(self, task: str):  # noqa\n        self.beliefs[task][\"acceptable\"] = True\n        self._log_acceptability(task, \"acceptable\", True)\n\n    def on_active(self, task: str):  # noqa\n        self.beliefs[task][\"active\"] = True\n\n        self._log_acceptability(task, \"active\", True)\n\n    def on_unacceptable(self, task: str):  # noqa\n        # NOTE: this time is not the exact time that the task went into failure.\n        # for this we would need to track the exact events that caused the failure, this is easier said than done...\n        self.beliefs[task][\"acceptable\"] = False\n\n        self._task_unacceptable_start[task] = time.time()\n        self._log_acceptability(task, \"acceptable\", False)\n\n    def on_inactive(self, task: str):  # noqa\n        self.beliefs[task][\"active\"] = False\n        self._task_inactive_start[task] = time.time()\n\n        self._log_acceptability(task, \"active\", False)\n\n    @observe([EyeMotionEvent, MouseMotionEvent])\n    def _on_motion_event(self, event: MouseMotionEvent | EyeMotionEvent):\n        \"\"\"It may be useful to the actuators to get these events. It is a trick to forward sensory input to the agents actuators. The `ArrowGuidanceActuator` is an example that requires this information to display the array at the gaze/mouse position.\"\"\"\n        # TODO we may need to guard against actuators executing these actions...?\n        # manually attempt the event, we could specify which actuators need this information...?\n        self.attempt(event)\n\n    @property\n    def task_acceptability_sensors(self) -&gt; list[TaskAcceptabilitySensor]:\n        \"\"\"Getter for task acceptability sensors (sensors that derive the type: `icua.agent.TaskAcceptabilitySensor`).\n\n        Returns:\n            list[TaskAcceptabilitySensor]: the sensors.\n        \"\"\"\n        return list(self.get_sensors(oftype=TaskAcceptabilitySensor))\n\n    @property\n    def guidance_actuators(self) -&gt; list[GuidanceActuator]:\n        \"\"\"Getter for guidance actuators (actuators that derive the type: `icua.agent.GuidanceActuator`).\n\n        Returns:\n            list[GuidanceActuator]: the GuidanceActuator.\n        \"\"\"\n        candidates = list(self.get_actuators(oftype=GuidanceActuator))\n        if len(candidates) == 0:\n            raise ValueError(\n                f\"Missing required actuator of type: `{GuidanceActuator.__qualname__}`\"\n            )\n        return candidates\n\n    def _log_acceptability(self, task, z, ok):\n        info = \"task %20s %20s %s\" % (z, task, [\"\u2718\", \"\u2714\"][int(ok)])\n        LOGGER.info(info)\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.guidance_actuators","title":"<code>guidance_actuators: list[GuidanceActuator]</code>  <code>property</code>","text":"<p>Getter for guidance actuators (actuators that derive the type: <code>icua.agent.GuidanceActuator</code>).</p> <p>Returns:</p> Type Description <code>list[GuidanceActuator]</code> <p>list[GuidanceActuator]: the GuidanceActuator.</p>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.task_acceptability_sensors","title":"<code>task_acceptability_sensors: list[TaskAcceptabilitySensor]</code>  <code>property</code>","text":"<p>Getter for task acceptability sensors (sensors that derive the type: <code>icua.agent.TaskAcceptabilitySensor</code>).</p> <p>Returns:</p> Type Description <code>list[TaskAcceptabilitySensor]</code> <p>list[TaskAcceptabilitySensor]: the sensors.</p>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.__init__","title":"<code>__init__(sensors, actuators, break_ties='random', attention_mode='mouse', grace_period=3.0, counter_factual=False, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>sensors</code> <code>list[Sensor]</code> <p>list of sensors, this will typically be a list of <code>icua.agent.TaskAcceptabilitySensor</code>s. A <code>UserInputSensor</code> will always be added automatically.</p> required <code>actuators</code> <code>list[Actuator]</code> <p>list of actuators, this will typically contain actuators that are capable of providing visual feedback to a user, see e.g. <code>icua.agent.GuidanceActuator</code> and its concrete implementations. A <code>CounterFactualGuidanceActuator</code> will be added by default.</p> required <code>break_ties</code> <code>Literal['random', 'longest', 'since']</code> <p>how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest time.</p> <code>'random'</code> <code>attention_mode</code> <code>Literal['gaze', 'mouse']</code> <p>method of determining where the user is paying attention. \"mouse\" will track the mouse position, \"gaze\" will track the gaze position (if avaliable). Defaults to \"mouse\".</p> <code>'mouse'</code> <code>grace_period</code> <code>float</code> <p>the time to wait (seconds) before guidance may be shown for a task after the last time guidance was shown on the task. Defaults to 3.0 seconds.</p> <code>3.0</code> <code>counter_factual</code> <code>bool</code> <p>whether guidance should be shown to the user, or whether it should just be logged.  This allows counter-factual experiments to be run, we can track when guidance would have been shown, and compare the when it was actually shown (in a different run). Defaults to False.</p> <code>False</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def __init__(\n    self,\n    sensors: list[Sensor],\n    actuators: list[Actuator],\n    break_ties: Literal[\"random\", \"longest\", \"since\"] = \"random\",\n    attention_mode: Literal[\"gaze\", \"mouse\"] = \"mouse\",\n    grace_period: float = 3.0,\n    counter_factual: bool = False,\n    **kwargs: dict[str, Any],\n):\n    \"\"\"Constructor.\n\n    Args:\n        sensors (list[Sensor]): list of sensors, this will typically be a list of `icua.agent.TaskAcceptabilitySensor`s. A `UserInputSensor` will always be added automatically.\n        actuators (list[Actuator]): list of actuators, this will typically contain actuators that are capable of providing visual feedback to a user, see e.g. `icua.agent.GuidanceActuator` and its concrete implementations. A `CounterFactualGuidanceActuator` will be added by default.\n        break_ties (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest time.\n        attention_mode (Literal[\"gaze\", \"mouse\"], optional): method of determining where the user is paying attention. \"mouse\" will track the mouse position, \"gaze\" will track the gaze position (if avaliable). Defaults to \"mouse\".\n        grace_period (float, optional): the time to wait (seconds) before guidance may be shown for a task after the last time guidance was shown on the task. Defaults to 3.0 seconds.\n        counter_factual (bool, optional): whether guidance should be shown to the user, or whether it should just be logged.  This allows counter-factual experiments to be run, we can track when guidance would have been shown, and compare the when it was actually shown (in a different run). Defaults to False.\n        kwargs (dict[str,Any]): Additional optional keyword arguments.\n    \"\"\"\n    _counter_factual_guidance_actuator = CounterFactualGuidanceActuator()\n    actuators.append(_counter_factual_guidance_actuator)\n    super().__init__(sensors, actuators, **kwargs)\n\n    # this agent is tracking the following tasks (based on the provided sensors)\n    self._tracking_tasks = [s.task_name for s in self.task_acceptability_sensors]\n    # initialise beliefs (empty)\n    for task in self._tracking_tasks:\n        self.beliefs[task] = dict(guidance=False)\n    # also record some attention information (for logging)\n    self.beliefs[\"attention\"] = dict()\n\n    # time since tasks went into an unacceptable state\n    self._task_unacceptable_start: dict[str, float] = None\n    # time since tasks become inactive\n    self._task_inactive_start: dict[str, float] = None\n    # TODO track the time since user input (gaze) has been provided, we can trigger an error if this is too long\n    self._missing_gaze_since: float = None\n    # guidance shown on task?\n    self._guidance_on_task: str = None\n    # time since guidance was shown for each task (for grace period)\n    self._guidance_last: dict[str, float] = None\n    # method to use to break ties when more than one task meets the guidance criteria\n    self._break_ties = break_ties  # (\"random\", \"longest\", \"since\")\n    if self._break_ties not in (\"random\", \"longest\", \"since\"):\n        raise ValueError(\n            f\"Invalid argument: `break_ties` {self._break_ties} must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n        )\n    # time to wait before showing guidance again on a task (can be zero)\n    self._grace_period = grace_period  # TODO\n    if self._grace_period &lt; 0.0:\n        raise ValueError(\n            f\"Invalid argument: `grace_period` {self._grace_period} must be &gt; 0 \"\n        )\n    # whether to actually display guidance, or just trigger a guidance event\n    self._counter_factual = counter_factual\n    self._counter_factual_guidance_actuator = _counter_factual_guidance_actuator\n    self._attention_mode = attention_mode\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.break_guidance_tie","title":"<code>break_guidance_tie(tasks, method='random')</code>","text":"<p>Break a tie on tasks that all met the criteria for displaying guiance.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list[str]</code> <p>tasks to break the tie, one of which will be returned.</p> required <code>method</code> <code>Literal['random', 'longest', 'since']</code> <p>how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.</p> <code>'random'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the chosen task.</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def break_guidance_tie(\n    self, tasks: list[str], method: Literal[\"random\", \"longest\", \"since\"] = \"random\"\n) -&gt; str:\n    \"\"\"Break a tie on tasks that all met the criteria for displaying guiance.\n\n    Args:\n        tasks (list[str]): tasks to break the tie, one of which will be returned.\n        method (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.\n\n    Returns:\n        str: the chosen task.\n    \"\"\"\n    assert len(tasks) &gt; 0\n    if method == \"random\":\n        # randomly break the tie\n        return random.choice(tasks)\n    elif method == \"longest\":\n        return max(\n            [(x, self._task_unacceptable_start[x]) for x in tasks],\n            key=lambda x: x[1],\n        )[0]\n        # choose the one longest in failure\n    elif method == \"since\":\n        # choose the one with with the longest time since guidance was last shown\n        return max(\n            [(x, self._guidance_last[x]) for x in tasks], key=lambda x: x[1]\n        )[0]\n    else:\n        raise ValueError(\n            f\"Unknown guidance tie break method: {self._break_ties}, must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n        )\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.get_attending","title":"<code>get_attending()</code>","text":"<p>Get attention data from mouse or eyetracker.</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def get_attending(self):\n    \"\"\"Get attention data from mouse or eyetracker.\"\"\"\n    if self._attention_mode == \"gaze\":\n        elements, gaze = self.gaze_at_elements, self.gaze_position\n        # check if the gaze data is None, if so we need to see how long and give a warning, it may indicate that the eyetracker\n        # has stopped functioning which may invalidate an experimental trial!\n        if gaze is None:\n            if self._missing_gaze_since is None:\n                self._missing_gaze_since = time.time()\n            elif (\n                time.time() - self._missing_gaze_since\n                &gt; DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD\n            ):\n                LOGGER.warning(\n                    f\"No fresh gaze data for longer than: { DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD}s\"\n                )\n            return {\"elements\": elements}\n        else:\n            self._missing_gaze_since = None\n        # gaze data may be present, but it may be old (its stored in a buffer until fresh data arrives)\n        if (\n            time.time() - gaze[\"timestamp\"]\n            &gt; DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD\n        ):\n            LOGGER.warning(\n                f\"No fresh gaze data for longer than: { DefaultGuidanceAgent.MISSING_GAZE_DATA_THRESHOLD}s\"\n            )\n        return {\"elements\": elements, **(gaze if gaze else {})}\n    elif self._attention_mode == \"mouse\":\n        position_data = self.mouse_position\n        return {\n            \"elements\": self.mouse_at_elements,\n            **(position_data if position_data else {}),\n        }\n    else:\n        raise ValueError(f\"Unknown attention mode: {self._attention_mode}\")\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.get_inactive_tasks","title":"<code>get_inactive_tasks()</code>","text":"<p>Get the set of inactive tasks.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: set of inactive tasks.</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def get_inactive_tasks(self) -&gt; set[str]:\n    \"\"\"Get the set of inactive tasks.\n\n    Returns:\n        set[str]: set of inactive tasks.\n    \"\"\"\n    active = list(self._is_task_active.items())\n    return set([x[0] for x in active if not x[1]])\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.get_unacceptable_tasks","title":"<code>get_unacceptable_tasks()</code>","text":"<p>Get the set of unacceptable tasks.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: set of unacceptable tasks.</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def get_unacceptable_tasks(self) -&gt; set[str]:\n    \"\"\"Get the set of unacceptable tasks.\n\n    Returns:\n        set[str]: set of unacceptable tasks.\n    \"\"\"\n    unacceptable = list(self._is_task_acceptable.items())\n    # is the task in an unacceptable state? (remove if they are acceptable)\n    unacceptable = set([x[0] for x in unacceptable if not x[1]])\n    # remove all inactive tasks (never display guidance for these)\n    unacceptable -= self.get_inactive_tasks()\n    return unacceptable\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.hide_guidance","title":"<code>hide_guidance(task)</code>","text":"<p>Hide guidance for a given task.</p> <p>If overriding you must call super() to ensure consistent behaviour.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>the task to hide guidance for.</p> required Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def hide_guidance(self, task: str):\n    \"\"\"Hide guidance for a given task.\n\n    If overriding you must call super() to ensure consistent behaviour.\n\n    Args:\n        task (str): the task to hide guidance for.\n    \"\"\"\n    if self._guidance_on_task:\n        self.beliefs[self._guidance_on_task][\"guidance\"] = False\n    self._guidance_on_task = None\n    if not self._counter_factual:\n        for actuator in self.guidance_actuators:\n            actuator.hide_guidance(task=task)\n    else:\n        self._counter_factual_guidance_actuator.hide_guidance(task=task)\n\n    # update the last time guidance was shown for the given task (for the grace period check)\n    self._guidance_last[task] = time.time()\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.show_guidance","title":"<code>show_guidance(task)</code>","text":"<p>Show guidance for a given task.</p> <p>If overriding you must call super() to ensure consistent behaviour.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>the task to show guidance for.</p> required Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def show_guidance(self, task: str):\n    \"\"\"Show guidance for a given task.\n\n    If overriding you must call super() to ensure consistent behaviour.\n\n    Args:\n        task (str): the task to show guidance for.\n    \"\"\"\n    self._guidance_on_task = task\n    self.beliefs[task][\"guidance\"] = True\n    if not self._counter_factual:\n        for actuator in self.guidance_actuators:\n            actuator.show_guidance(task=task)\n    else:\n        self._counter_factual_guidance_actuator.show_guidance(task=task)\n</code></pre>"},{"location":"reference/guidance/sensor_guidance/","title":"Sensor guidance","text":"<p>Module contains the base class for task acceptability sensors <code>TaskAcceptabilitySensor</code>, it is an extension of the base class that is part of <code>icua</code> which includes functionality for determining if a task is active based on whether the task element is present in the environment state.</p>"},{"location":"reference/guidance/sensor_guidance/#matbii.guidance.sensor_guidance.TaskAcceptabilitySensor","title":"<code>TaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>This <code>Sensor</code> can be used by an agent to track the acceptability of a task.</p> Source code in <code>matbii\\guidance\\sensor_guidance.py</code> <pre><code>class TaskAcceptabilitySensor(_TaskAcceptabilitySensor):\n    \"\"\"This `Sensor` can be used by an agent to track the acceptability of a task.\"\"\"\n\n    def __init__(self, task_name: str, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            task_name (str): task to track.\n            args (list[Any]): Additional optional arguments.\n            kwargs (dict[str,Any]): Additional optionals keyword arguments.\n        \"\"\"\n        super().__init__(task_name, *args, **kwargs)\n        self._is_active = True  # unless it cannot be found...\n        # the id of the action that is used to check whether the task is active\n        self._is_active_action_id = None\n\n    def is_active(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        return self._is_active  # this is not done by subclass\n\n    def __transduce__(self, observations: list[Observation]) -&gt; list[Observation]:  # noqa\n        # fetch the observation that is the result of the is_active action and update _is_active\n        # this must happen before beliefs are updated since some updates may depend on whether the task is active\n        self._update_is_active(observations)\n        return super().__transduce__(observations)\n\n    def on_error_observation(self, observation: ErrorObservation):  # noqa\n        if self._is_active:\n            return super().on_error_observation(observation)\n        # if the task is inactive then some observations may result in XPathElementsNotFound\n        if issubclass(observation.resolve_exception_type(), XPathElementsNotFound):\n            pass  # ignore these\n        else:\n            # these may still be relevant\n            return super().on_error_observation(observation)\n\n    def _update_is_active(self, observations: list[Observation]) -&gt; bool:\n        \"\"\"Checks whether the task is currently active based on the observation resulting from the `is_active` action.\"\"\"\n        is_active_observation = list(\n            filter(\n                lambda x: isinstance(x, ActiveObservation)\n                and x.action_id == self._is_active_action_id,\n                observations,\n            )\n        )\n        if len(is_active_observation) == 0:\n            # the is_active observation was not part of these observations\n            # this can happen if the sensor is receiving observations via subscription\n            return\n        # the is_active observation was part of the observations, check it\n        is_active_observation = is_active_observation[0]\n        if self._is_active:\n            if isinstance(is_active_observation, ErrorObservation):\n                self._is_active = False  # the task is now inactive!\n            else:\n                self._is_active = True  # the task is active and remains active\n        else:\n            if not isinstance(is_active_observation, ErrorObservation):\n                self._is_active = True  # the task is inactive and may now be active\n            else:\n                self._is_active = False  # the task is inactive and remains inactive\n\n    def __sense__(self) -&gt; list[Event]:  # noqa\n        if self._is_active:\n            actions = self.sense()\n            if not isinstance(actions, list | tuple):\n                raise TypeError(\n                    f\"`sense()` must return a `list` of events, received: {type(actions)}\"\n                )\n        else:\n            actions = []\n        # always check if the task is active\n        is_active = Select(xpath=f\"//*[@id='{self.task_name}']\", attrs=[\"id\"])\n        self._is_active_action_id = is_active.id\n        actions.insert(0, is_active)\n        return actions\n</code></pre>"},{"location":"reference/guidance/sensor_guidance/#matbii.guidance.sensor_guidance.TaskAcceptabilitySensor.__init__","title":"<code>__init__(task_name, *args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>task to track.</p> required <code>args</code> <code>list[Any]</code> <p>Additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Additional optionals keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_guidance.py</code> <pre><code>def __init__(self, task_name: str, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        task_name (str): task to track.\n        args (list[Any]): Additional optional arguments.\n        kwargs (dict[str,Any]): Additional optionals keyword arguments.\n    \"\"\"\n    super().__init__(task_name, *args, **kwargs)\n    self._is_active = True  # unless it cannot be found...\n    # the id of the action that is used to check whether the task is active\n    self._is_active_action_id = None\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/","title":"Sensor resource management","text":"<p>Module contains a guidance sensor for tracking the \"resource management\" task acceptability, see <code>ResourceManagementTaskAcceptabilitySensor</code> documentation for details.</p>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor","title":"<code>ResourceManagementTaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>Guidance sensor for the resource management task.</p> <p>This sensor tracks a number of sub-tasks:</p> <ul> <li>\"system_monitoring.tank-a\"</li> <li>\"system_monitoring.tank-b\"</li> </ul> <p>The acceptability of these sub-tasks can be checked by calling the method: <code>ResourceManagementTaskAcceptabilitySensor.is_tank_acceptable</code>.</p> <p>Otherwise follow the <code>TaskAcceptabilitySensor</code> API.</p> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>class ResourceManagementTaskAcceptabilitySensor(TaskAcceptabilitySensor):\n    \"\"\"Guidance sensor for the resource management task.\n\n    This sensor tracks a number of sub-tasks:\n\n    - \"system_monitoring.tank-a\"\n    - \"system_monitoring.tank-b\"\n\n    The acceptability of these sub-tasks can be checked by calling the method: `ResourceManagementTaskAcceptabilitySensor.is_tank_acceptable`.\n\n    Otherwise follow the `TaskAcceptabilitySensor` API.\n    \"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(TASK_ID_RESOURCE_MANAGEMENT, *args, **kwargs)\n        self._is_subtask_acceptable_map = {\n            f\"{self.task_name}.tank-a\": partial(self.is_tank_acceptable, \"a\"),\n            f\"{self.task_name}.tank-b\": partial(self.is_tank_acceptable, \"b\"),\n        }\n\n    def is_acceptable(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        if task is None or task == self.task_name:\n            return all([x() for x in self._is_subtask_acceptable_map.values()])\n        else:\n            is_acceptable = self._is_subtask_acceptable_map.get(task, None)\n            if is_acceptable is None:\n                raise KeyError(\n                    f\"Invalid subtask: {task}, doesn't exist for task {self.task_name}\"\n                )\n            else:\n                return is_acceptable()\n\n    def is_tank_acceptable(self, _id: str) -&gt; bool:\n        \"\"\"Whether the given tank is in an acceptable state.\n\n        Acceptable: the fuel level lies in the required range.\n        Unacceptable: otherwise.\n\n        Args:\n            _id (int): the id of the tank (\"a\" or \"b\")\n\n        Returns:\n            bool: True if the tank is in an acceptable state, False otherwise.\n        \"\"\"\n        tank = self.beliefs[tank_id(_id)]\n        tank_level = self.beliefs[tank_level_id(_id)]\n\n        fuel_capacity = tank[\"data-capacity\"]\n        fuel_level = tank[\"data-level\"]\n        acceptable_level = tank_level[\"data-level\"] * fuel_capacity\n        acceptable_range2 = (tank_level[\"data-range\"] * fuel_capacity) / 2\n        return (\n            fuel_level &gt;= acceptable_level - acceptable_range2\n            and fuel_level &lt;= acceptable_level + acceptable_range2\n        )\n\n    def sense(self) -&gt; list[Select]:\n        \"\"\"Generates the sense actions that are required for checking whether the resource management task is in an acceptable state.\n\n        The actions will request the following data:\n        - the current fuel level and capacity of each main tank (\"a\" and \"b\")\n        - the acceptable range of fuel for each main tank (\"a\" and \"b\")\n\n        Returns:\n            list[Select]: list of sense actions to take.\n        \"\"\"\n        # interested in the fuel levels of the main tanks in the Resource Management Task\n        tanks = [tank_id(i) for i in (\"a\", \"b\")]\n        tank_levels = [tank_level_id(i) for i in (\"a\", \"b\")]\n        tank_selects = [\n            select(\n                xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-capacity\", \"data-level\"]\n            )\n            for id in tanks\n        ]\n        tank_level_selects = [\n            select(xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-level\", \"data-range\"])\n            for id in tank_levels\n        ]\n        return [*tank_selects, *tank_level_selects]\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(TASK_ID_RESOURCE_MANAGEMENT, *args, **kwargs)\n    self._is_subtask_acceptable_map = {\n        f\"{self.task_name}.tank-a\": partial(self.is_tank_acceptable, \"a\"),\n        f\"{self.task_name}.tank-b\": partial(self.is_tank_acceptable, \"b\"),\n    }\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor.is_tank_acceptable","title":"<code>is_tank_acceptable(_id)</code>","text":"<p>Whether the given tank is in an acceptable state.</p> <p>Acceptable: the fuel level lies in the required range. Unacceptable: otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>int</code> <p>the id of the tank (\"a\" or \"b\")</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the tank is in an acceptable state, False otherwise.</p> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>def is_tank_acceptable(self, _id: str) -&gt; bool:\n    \"\"\"Whether the given tank is in an acceptable state.\n\n    Acceptable: the fuel level lies in the required range.\n    Unacceptable: otherwise.\n\n    Args:\n        _id (int): the id of the tank (\"a\" or \"b\")\n\n    Returns:\n        bool: True if the tank is in an acceptable state, False otherwise.\n    \"\"\"\n    tank = self.beliefs[tank_id(_id)]\n    tank_level = self.beliefs[tank_level_id(_id)]\n\n    fuel_capacity = tank[\"data-capacity\"]\n    fuel_level = tank[\"data-level\"]\n    acceptable_level = tank_level[\"data-level\"] * fuel_capacity\n    acceptable_range2 = (tank_level[\"data-range\"] * fuel_capacity) / 2\n    return (\n        fuel_level &gt;= acceptable_level - acceptable_range2\n        and fuel_level &lt;= acceptable_level + acceptable_range2\n    )\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor.sense","title":"<code>sense()</code>","text":"<p>Generates the sense actions that are required for checking whether the resource management task is in an acceptable state.</p> <p>The actions will request the following data: - the current fuel level and capacity of each main tank (\"a\" and \"b\") - the acceptable range of fuel for each main tank (\"a\" and \"b\")</p> <p>Returns:</p> Type Description <code>list[Select]</code> <p>list[Select]: list of sense actions to take.</p> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>def sense(self) -&gt; list[Select]:\n    \"\"\"Generates the sense actions that are required for checking whether the resource management task is in an acceptable state.\n\n    The actions will request the following data:\n    - the current fuel level and capacity of each main tank (\"a\" and \"b\")\n    - the acceptable range of fuel for each main tank (\"a\" and \"b\")\n\n    Returns:\n        list[Select]: list of sense actions to take.\n    \"\"\"\n    # interested in the fuel levels of the main tanks in the Resource Management Task\n    tanks = [tank_id(i) for i in (\"a\", \"b\")]\n    tank_levels = [tank_level_id(i) for i in (\"a\", \"b\")]\n    tank_selects = [\n        select(\n            xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-capacity\", \"data-level\"]\n        )\n        for id in tanks\n    ]\n    tank_level_selects = [\n        select(xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-level\", \"data-range\"])\n        for id in tank_levels\n    ]\n    return [*tank_selects, *tank_level_selects]\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/","title":"Sensor system monitoring","text":"<p>Module contains a guidance sensor for tracking the \"system monitoring\" task acceptability, see <code>SystemMonitoringTaskAcceptabilitySensor</code> documentation for details.</p>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor","title":"<code>SystemMonitoringTaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>Guidance sensor for the system monitoring task.</p> <p>This sensor tracks a number of sub-tasks:</p> <ul> <li><code>\"system_monitoring.light-1\"</code></li> <li><code>\"system_monitoring.light-2\"</code></li> <li><code>\"system_monitoring.slider-1\"</code></li> <li><code>\"system_monitoring.slider-2\"</code></li> <li><code>\"system_monitoring.slider-3\"</code></li> <li><code>\"system_monitoring.slider-4\"</code></li> </ul> <p>The acceptability of these sub-tasks can be checked by calling the methods:</p> <ul> <li><code>SystemMonitoringTaskAcceptabilitySensor.is_light_acceptable</code></li> <li><code>SystemMonitoringTaskAcceptabilitySensor.is_slider_acceptable</code></li> </ul> <p>Otherwise follow the <code>icua.agent.TaskAcceptabilitySensor</code> API.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>class SystemMonitoringTaskAcceptabilitySensor(TaskAcceptabilitySensor):\n    \"\"\"Guidance sensor for the system monitoring task.\n\n    This sensor tracks a number of sub-tasks:\n\n    - `\"system_monitoring.light-1\"`\n    - `\"system_monitoring.light-2\"`\n    - `\"system_monitoring.slider-1\"`\n    - `\"system_monitoring.slider-2\"`\n    - `\"system_monitoring.slider-3\"`\n    - `\"system_monitoring.slider-4\"`\n\n    The acceptability of these sub-tasks can be checked by calling the methods:\n\n    - `SystemMonitoringTaskAcceptabilitySensor.is_light_acceptable`\n    - `SystemMonitoringTaskAcceptabilitySensor.is_slider_acceptable`\n\n    Otherwise follow the `icua.agent.TaskAcceptabilitySensor` API.\n    \"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(TASK_ID_SYSTEM_MONITORING, *args, **kwargs)\n        self._is_subtask_acceptable = {\n            f\"{self.task_name}.light-1\": partial(self.is_light_acceptable, 1),\n            f\"{self.task_name}.light-2\": partial(self.is_light_acceptable, 2),\n            f\"{self.task_name}.slider-1\": partial(self.is_slider_acceptable, 1),\n            f\"{self.task_name}.slider-2\": partial(self.is_slider_acceptable, 2),\n            f\"{self.task_name}.slider-3\": partial(self.is_slider_acceptable, 3),\n            f\"{self.task_name}.slider-4\": partial(self.is_slider_acceptable, 4),\n        }\n\n    def is_acceptable(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        if not self._is_active:\n            return False  # always return False if the task is inactive\n        if task is None or task == self.task_name:\n            return all([x() for x in self._is_subtask_acceptable.values()])\n        else:\n            is_acceptable = self._is_subtask_acceptable.get(task, None)\n            if is_acceptable is None:\n                raise KeyError(\n                    f\"Invalid subtask: {task}, doesn't exist for task {self.task_name}\"\n                )\n            else:\n                return is_acceptable()\n\n    def is_slider_acceptable(self, _id: int) -&gt; bool:\n        \"\"\"Whether the given slider is in an acceptable state.\n\n        Acceptable: the slider is at the central position.\n        Unacceptable: otherwise.\n\n        Args:\n            _id (int): the id of the slider (1, 2, 3 or 4)\n\n        Returns:\n            bool: True if the slider is in an acceptable state, False otherwise.\n        \"\"\"\n        if not self._is_active:\n            return False  # always return False if the task is inactive\n        # sliders should be at the center position to be acceptable\n        state = self.beliefs[slider_id(_id)][\"data-state\"]\n        acceptable_state = SetSliderAction.acceptable_state(\n            self.beliefs[slider_incs_id(_id)][\"incs\"]\n        )\n        return state == acceptable_state\n\n    def is_light_acceptable(self, _id: int) -&gt; bool:\n        \"\"\"Whether the given light is in an acceptable state.\n\n        Acceptable: light-1 is on, light-2 is off.\n        Unacceptable: otherwise.\n\n        Args:\n            _id (int): the id of the light (1 or 2)\n\n        Returns:\n            bool: True if the light is in an acceptable state, False otherwise.\n        \"\"\"\n        if not self._is_active:\n            return False  # always return False if the task is inactive\n        return [self._is_light1_acceptable, self._is_light2_acceptable][_id - 1]()\n\n    def _is_light1_acceptable(self):\n        # light 1 should be on\n        return self.beliefs[light_id(1)][\"data-state\"] == SetLightAction.ON\n\n    def _is_light2_acceptable(self):\n        # light 2 should be off\n        return self.beliefs[light_id(2)][\"data-state\"] == SetLightAction.OFF\n\n    def sense(self) -&gt; list[Select]:\n        \"\"\"Generates the sense actions that are required for checking whether the system monitoring task is in an acceptable state.\n\n        The actions will request the following data:\n        - the state of each light element.\n        - the state of each slider element.\n        - the number of increments in each slider element.\n\n        Returns:\n            list[Select]: list of sense actions to take.\n        \"\"\"\n        # take these actions if this task is active\n        lights = [f\"//*[@id='{light_id(i)}']\" for i in (1, 2)]\n        sliders = [f\"//*[@id='{slider_id(i)}']\" for i in (1, 2, 3, 4)]\n        slider_incs = [f\"//*[@id='{slider_incs_id(i)}']\" for i in (1, 2, 3, 4)]\n\n        lights = [Select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in lights]\n        sliders = [Select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in sliders]\n        slider_incs = [\n            Select(xpath=xpath, attrs=[\"id\", \"incs\"]) for xpath in slider_incs\n        ]\n        return [*lights, *sliders, *slider_incs]\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(TASK_ID_SYSTEM_MONITORING, *args, **kwargs)\n    self._is_subtask_acceptable = {\n        f\"{self.task_name}.light-1\": partial(self.is_light_acceptable, 1),\n        f\"{self.task_name}.light-2\": partial(self.is_light_acceptable, 2),\n        f\"{self.task_name}.slider-1\": partial(self.is_slider_acceptable, 1),\n        f\"{self.task_name}.slider-2\": partial(self.is_slider_acceptable, 2),\n        f\"{self.task_name}.slider-3\": partial(self.is_slider_acceptable, 3),\n        f\"{self.task_name}.slider-4\": partial(self.is_slider_acceptable, 4),\n    }\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.is_light_acceptable","title":"<code>is_light_acceptable(_id)</code>","text":"<p>Whether the given light is in an acceptable state.</p> <p>Acceptable: light-1 is on, light-2 is off. Unacceptable: otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>int</code> <p>the id of the light (1 or 2)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the light is in an acceptable state, False otherwise.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def is_light_acceptable(self, _id: int) -&gt; bool:\n    \"\"\"Whether the given light is in an acceptable state.\n\n    Acceptable: light-1 is on, light-2 is off.\n    Unacceptable: otherwise.\n\n    Args:\n        _id (int): the id of the light (1 or 2)\n\n    Returns:\n        bool: True if the light is in an acceptable state, False otherwise.\n    \"\"\"\n    if not self._is_active:\n        return False  # always return False if the task is inactive\n    return [self._is_light1_acceptable, self._is_light2_acceptable][_id - 1]()\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.is_slider_acceptable","title":"<code>is_slider_acceptable(_id)</code>","text":"<p>Whether the given slider is in an acceptable state.</p> <p>Acceptable: the slider is at the central position. Unacceptable: otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>int</code> <p>the id of the slider (1, 2, 3 or 4)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the slider is in an acceptable state, False otherwise.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def is_slider_acceptable(self, _id: int) -&gt; bool:\n    \"\"\"Whether the given slider is in an acceptable state.\n\n    Acceptable: the slider is at the central position.\n    Unacceptable: otherwise.\n\n    Args:\n        _id (int): the id of the slider (1, 2, 3 or 4)\n\n    Returns:\n        bool: True if the slider is in an acceptable state, False otherwise.\n    \"\"\"\n    if not self._is_active:\n        return False  # always return False if the task is inactive\n    # sliders should be at the center position to be acceptable\n    state = self.beliefs[slider_id(_id)][\"data-state\"]\n    acceptable_state = SetSliderAction.acceptable_state(\n        self.beliefs[slider_incs_id(_id)][\"incs\"]\n    )\n    return state == acceptable_state\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.sense","title":"<code>sense()</code>","text":"<p>Generates the sense actions that are required for checking whether the system monitoring task is in an acceptable state.</p> <p>The actions will request the following data: - the state of each light element. - the state of each slider element. - the number of increments in each slider element.</p> <p>Returns:</p> Type Description <code>list[Select]</code> <p>list[Select]: list of sense actions to take.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def sense(self) -&gt; list[Select]:\n    \"\"\"Generates the sense actions that are required for checking whether the system monitoring task is in an acceptable state.\n\n    The actions will request the following data:\n    - the state of each light element.\n    - the state of each slider element.\n    - the number of increments in each slider element.\n\n    Returns:\n        list[Select]: list of sense actions to take.\n    \"\"\"\n    # take these actions if this task is active\n    lights = [f\"//*[@id='{light_id(i)}']\" for i in (1, 2)]\n    sliders = [f\"//*[@id='{slider_id(i)}']\" for i in (1, 2, 3, 4)]\n    slider_incs = [f\"//*[@id='{slider_incs_id(i)}']\" for i in (1, 2, 3, 4)]\n\n    lights = [Select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in lights]\n    sliders = [Select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in sliders]\n    slider_incs = [\n        Select(xpath=xpath, attrs=[\"id\", \"incs\"]) for xpath in slider_incs\n    ]\n    return [*lights, *sliders, *slider_incs]\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/","title":"Sensor tracking","text":"<p>Module contains a guidance sensor for tracking the \"tracking\" task acceptability, see <code>TrackingTaskAcceptabilitySensor</code> documentation for details.</p>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor","title":"<code>TrackingTaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>Guidance sensor for the tracking task.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>class TrackingTaskAcceptabilitySensor(TaskAcceptabilitySensor):\n    \"\"\"Guidance sensor for the tracking task.\"\"\"\n\n    _BOX_ID = tracking_box_id()\n    _TARGET_ID = tracking_target_id()\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(TASK_ID_TRACKING, *args, **kwargs)\n        # initialise beliefs about the tracking tasks\n        self.beliefs[TrackingTaskAcceptabilitySensor._BOX_ID] = dict()\n        self.beliefs[TrackingTaskAcceptabilitySensor._TARGET_ID] = dict()\n\n    def is_acceptable(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        if task is None or task == self.task_name:\n            return self.is_tracking_acceptable()\n        else:\n            raise KeyError(\n                f\"Invalid subtask: {task}, doesn't exist for task {self.task_name}\"\n            )\n\n    def is_tracking_acceptable(self) -&gt; bool:\n        \"\"\"Determines whether the tracking task is in an acceptable state.\n\n        Acceptable: \"target\" is within the central box of the task.\n        Unacceptable: otherwise.\n\n        Raises:\n            ValueError: if there is missing observational data about the task - this may mean the task is not active.\n\n        Returns:\n            bool: whether the task is in an acceptable state.\n        \"\"\"\n        try:\n            target = self.beliefs.get(TrackingTaskAcceptabilitySensor._TARGET_ID, None)\n        except KeyError:\n            raise KeyError(\n                f\"Failed to determine acceptability of task: '{TASK_ID_TRACKING}'.\\n-- Missing beliefs for elements: '{TrackingTaskAcceptabilitySensor._TARGET_ID}'\"\n            )\n        try:\n            box = self.beliefs.get(TrackingTaskAcceptabilitySensor._BOX_ID, None)\n        except KeyError:\n            raise KeyError(\n                f\"Failed to determine acceptability of task: '{TASK_ID_TRACKING}'.\\n-- Missing beliefs for elements: '{TrackingTaskAcceptabilitySensor._BOX_ID}'\"\n            )\n        return TrackingTaskAcceptabilitySensor.is_point_in_rectangle(\n            target[\"xy\"], box[\"tl\"], box[\"br\"]\n        )\n\n    def on_observation(self, observation: Observation):\n        \"\"\"Update beliefs about the tracking task based on the incoming observation.\n\n        Args:\n            observation (Observation): observation\n        \"\"\"\n        for data in observation.values:\n            try:\n                if data[\"id\"] == TrackingTaskAcceptabilitySensor._TARGET_ID:\n                    tl = (data[\"x\"], data[\"y\"])\n                    size = (data[\"width\"], data[\"height\"])\n                    xy = (tl[0] + size[0] / 2, tl[1] + size[1] / 2)\n                    self.beliefs[TrackingTaskAcceptabilitySensor._TARGET_ID][\"xy\"] = xy\n                    self.beliefs[TrackingTaskAcceptabilitySensor._TARGET_ID][\"size\"] = (\n                        size\n                    )\n                elif data[\"id\"] == TrackingTaskAcceptabilitySensor._BOX_ID:\n                    tl = (data[\"x\"], data[\"y\"])\n                    self.beliefs[TrackingTaskAcceptabilitySensor._BOX_ID][\"tl\"] = tl\n                    self.beliefs[TrackingTaskAcceptabilitySensor._BOX_ID][\"br\"] = (\n                        tl[0] + data[\"width\"],\n                        tl[1] + data[\"height\"],\n                    )\n            except KeyError:\n                raise KeyError(\n                    f\"Observation: {observation} doesn't contain the required `id` attribute.\"\n                )\n\n    def sense(self) -&gt; list[Select]:\n        \"\"\"Generates the sense actions that are required for checking whether the tracking task is in an acceptable state.\n\n        The actions will request the following data:\n        - the bounds of the target element.\n        - the bounds of the central box of the tracking task.\n\n        Returns:\n            list[Select]: list of sense actions to take.\n        \"\"\"\n        return [\n            select(\n                xpath=f\"//*[@id='{tracking_target_id()}']\",\n                attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n            ),\n            select(\n                xpath=f\"//*[@id='{tracking_box_id()}']\",\n                attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n            ),\n        ]\n\n    @staticmethod\n    def is_point_in_rectangle(\n        point: tuple[float, float],\n        rect_min: tuple[float, float],\n        rect_max: tuple[float, float],\n    ) -&gt; bool:\n        \"\"\"Checks wether the given `point` is within the rectangle as specified by the top left and bottom right coordinate.\n\n        Args:\n            point (tuple[float, float]): point to check.\n            rect_min (tuple[float,float]): top left.\n            rect_max (tuple[float,float]): bottom right.\n\n        Returns:\n            bool: whether the point is in the rectangle.\n        \"\"\"\n        px, py = point\n        min_x, min_y = rect_min\n        max_x, max_y = rect_max\n        return min_x &lt;= px &lt;= max_x and min_y &lt;= py &lt;= max_y\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(TASK_ID_TRACKING, *args, **kwargs)\n    # initialise beliefs about the tracking tasks\n    self.beliefs[TrackingTaskAcceptabilitySensor._BOX_ID] = dict()\n    self.beliefs[TrackingTaskAcceptabilitySensor._TARGET_ID] = dict()\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.is_point_in_rectangle","title":"<code>is_point_in_rectangle(point, rect_min, rect_max)</code>  <code>staticmethod</code>","text":"<p>Checks wether the given <code>point</code> is within the rectangle as specified by the top left and bottom right coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple[float, float]</code> <p>point to check.</p> required <code>rect_min</code> <code>tuple[float, float]</code> <p>top left.</p> required <code>rect_max</code> <code>tuple[float, float]</code> <p>bottom right.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the point is in the rectangle.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>@staticmethod\ndef is_point_in_rectangle(\n    point: tuple[float, float],\n    rect_min: tuple[float, float],\n    rect_max: tuple[float, float],\n) -&gt; bool:\n    \"\"\"Checks wether the given `point` is within the rectangle as specified by the top left and bottom right coordinate.\n\n    Args:\n        point (tuple[float, float]): point to check.\n        rect_min (tuple[float,float]): top left.\n        rect_max (tuple[float,float]): bottom right.\n\n    Returns:\n        bool: whether the point is in the rectangle.\n    \"\"\"\n    px, py = point\n    min_x, min_y = rect_min\n    max_x, max_y = rect_max\n    return min_x &lt;= px &lt;= max_x and min_y &lt;= py &lt;= max_y\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.is_tracking_acceptable","title":"<code>is_tracking_acceptable()</code>","text":"<p>Determines whether the tracking task is in an acceptable state.</p> <p>Acceptable: \"target\" is within the central box of the task. Unacceptable: otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if there is missing observational data about the task - this may mean the task is not active.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the task is in an acceptable state.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def is_tracking_acceptable(self) -&gt; bool:\n    \"\"\"Determines whether the tracking task is in an acceptable state.\n\n    Acceptable: \"target\" is within the central box of the task.\n    Unacceptable: otherwise.\n\n    Raises:\n        ValueError: if there is missing observational data about the task - this may mean the task is not active.\n\n    Returns:\n        bool: whether the task is in an acceptable state.\n    \"\"\"\n    try:\n        target = self.beliefs.get(TrackingTaskAcceptabilitySensor._TARGET_ID, None)\n    except KeyError:\n        raise KeyError(\n            f\"Failed to determine acceptability of task: '{TASK_ID_TRACKING}'.\\n-- Missing beliefs for elements: '{TrackingTaskAcceptabilitySensor._TARGET_ID}'\"\n        )\n    try:\n        box = self.beliefs.get(TrackingTaskAcceptabilitySensor._BOX_ID, None)\n    except KeyError:\n        raise KeyError(\n            f\"Failed to determine acceptability of task: '{TASK_ID_TRACKING}'.\\n-- Missing beliefs for elements: '{TrackingTaskAcceptabilitySensor._BOX_ID}'\"\n        )\n    return TrackingTaskAcceptabilitySensor.is_point_in_rectangle(\n        target[\"xy\"], box[\"tl\"], box[\"br\"]\n    )\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.on_observation","title":"<code>on_observation(observation)</code>","text":"<p>Update beliefs about the tracking task based on the incoming observation.</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>Observation</code> <p>observation</p> required Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def on_observation(self, observation: Observation):\n    \"\"\"Update beliefs about the tracking task based on the incoming observation.\n\n    Args:\n        observation (Observation): observation\n    \"\"\"\n    for data in observation.values:\n        try:\n            if data[\"id\"] == TrackingTaskAcceptabilitySensor._TARGET_ID:\n                tl = (data[\"x\"], data[\"y\"])\n                size = (data[\"width\"], data[\"height\"])\n                xy = (tl[0] + size[0] / 2, tl[1] + size[1] / 2)\n                self.beliefs[TrackingTaskAcceptabilitySensor._TARGET_ID][\"xy\"] = xy\n                self.beliefs[TrackingTaskAcceptabilitySensor._TARGET_ID][\"size\"] = (\n                    size\n                )\n            elif data[\"id\"] == TrackingTaskAcceptabilitySensor._BOX_ID:\n                tl = (data[\"x\"], data[\"y\"])\n                self.beliefs[TrackingTaskAcceptabilitySensor._BOX_ID][\"tl\"] = tl\n                self.beliefs[TrackingTaskAcceptabilitySensor._BOX_ID][\"br\"] = (\n                    tl[0] + data[\"width\"],\n                    tl[1] + data[\"height\"],\n                )\n        except KeyError:\n            raise KeyError(\n                f\"Observation: {observation} doesn't contain the required `id` attribute.\"\n            )\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.sense","title":"<code>sense()</code>","text":"<p>Generates the sense actions that are required for checking whether the tracking task is in an acceptable state.</p> <p>The actions will request the following data: - the bounds of the target element. - the bounds of the central box of the tracking task.</p> <p>Returns:</p> Type Description <code>list[Select]</code> <p>list[Select]: list of sense actions to take.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def sense(self) -&gt; list[Select]:\n    \"\"\"Generates the sense actions that are required for checking whether the tracking task is in an acceptable state.\n\n    The actions will request the following data:\n    - the bounds of the target element.\n    - the bounds of the central box of the tracking task.\n\n    Returns:\n        list[Select]: list of sense actions to take.\n    \"\"\"\n    return [\n        select(\n            xpath=f\"//*[@id='{tracking_target_id()}']\",\n            attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n        ),\n        select(\n            xpath=f\"//*[@id='{tracking_box_id()}']\",\n            attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n        ),\n    ]\n</code></pre>"},{"location":"reference/tasks/","title":"Tasks","text":"<p>Package defining each of the matbii tasks.</p> Tasks <ul> <li>tracking</li> <li>system monitoring</li> <li>resource management</li> </ul>"},{"location":"reference/tasks/#packages","title":"Packages","text":"<ul> <li>matbii/tasks/resource_management</li> <li>matbii/tasks/system_monitoring</li> <li>matbii/tasks/tracking</li> </ul>"},{"location":"reference/tasks/resource_management/","title":"Resource management","text":"<p>Package that defines the matbii resource management task.</p>"},{"location":"reference/tasks/resource_management/#modules","title":"Modules","text":"<ul> <li>matbii/tasks/resource_management/resource_management.py</li> </ul>"},{"location":"reference/tasks/resource_management/resource_management/","title":"Resource management","text":"<p>Module that implements the resource management task.</p> This files contains <ul> <li>avatar actuator: <code>AvatarResourceManagementActuator</code></li> <li>agent actuator: <code>ResourceManagementActuator</code></li> <li>actions: [<code>SetPumpAction</code>, <code>TogglePumpAction</code>, <code>TogglePumpFailureAction</code>, <code>PumpFuelAction</code>, <code>BurnFuelAction</code>]</li> </ul>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator","title":"<code>AvatarResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class AvatarResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_pump_targets = partial(\n            AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[TogglePumpAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        # always include the user action as it needs to be logged\n        actions = []\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_pump_actions(user_action))\n        return actions\n\n    def _get_pump_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        targets = self._get_pump_targets(user_action.target)\n        return [TogglePumpAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_pump_targets = partial(\n        AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n    )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt a <code>TogglePumpAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>TogglePumpAction</code>: toggle the pump on-&gt;off or off-&gt;on.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[TogglePumpAction]</code> <p>list[TogglePumpAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[\"TogglePumpAction\"]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[TogglePumpAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    # always include the user action as it needs to be logged\n    actions = []\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_pump_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.BurnFuelAction","title":"<code>BurnFuelAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will burn fuel in one of the main tanks (tank id = \"a\", \"b\" or \"*\" which indicates both tanks).</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class BurnFuelAction(XMLUpdateQuery):\n    \"\"\"Action class that will burn fuel in one of the main tanks (tank id = \"a\", \"b\" or \"*\" which indicates both tanks).\"\"\"\n\n    target: str\n    burn: float\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value: int | str) -&gt; str:\n        if isinstance(value, int):\n            value = TANK_MAIN_IDS[value]\n        if isinstance(value, str):\n            if value in TANK_MAIN_IDS + [ALL]:\n                return value\n        raise ValueError(\n            f\"Invalid tank {value}, must be one of {TANK_MAIN_IDS + [ALL]}\"\n        )\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        targets = self._get_targets()\n        for target in targets:\n            values = _get_tank_data(xml_state, target)\n            if values[\"data-level\"] == 0:\n                continue  # fuel is already 0, no fuel to burn\n            new_level = max(values[\"data-level\"] - self.burn, 0)\n            _update_tank_level(xml_state, target, values, new_level)\n\n    def _get_targets(self) -&gt; list[str]:\n        if self.target != ALL:\n            targets = [self.target]\n        else:\n            targets = TANK_MAIN_IDS\n        return targets\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.PumpAction","title":"<code>PumpAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Base class for pump related actions.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class PumpAction(XMLUpdateQuery):\n    \"\"\"Base class for pump related actions.\"\"\"\n\n    target: str\n\n    OFF: ClassVar[int] = 0\n    ON: ClassVar[int] = 1\n    FAILURE: ClassVar[int] = 2\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value: str | int):\n        if isinstance(value, int):\n            value = PUMP_IDS[value]\n        if value not in PUMP_IDS:\n            raise ValueError(\n                f\"{SetPumpAction.__name__} `target` {value} must be one of {PUMP_IDS}\"\n            )\n        return value\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.PumpFuelAction","title":"<code>PumpFuelAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class that will pump fuel from one tank to another.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class PumpFuelAction(PumpAction):\n    \"\"\"Action class that will pump fuel from one tank to another.\"\"\"\n\n    flow: float\n    XPATH_PUMP: ClassVar[str] = \"//svg:rect[@id='pump-%s-button']\"\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        if self.is_pump_on(xml_state, self.target):\n            id_from = self.target[0]\n            id_to = self.target[1]\n\n            _from = _get_tank_data(xml_state, id_from)\n            if _from[\"data-level\"] &lt;= 0:\n                return  # there is no fuel to transfer\n            _to = _get_tank_data(xml_state, id_to)\n            remain = _to[\"data-capacity\"] - _to[\"data-level\"]\n            if remain &lt;= 0:\n                return  # the tank is full\n\n            # compute flow value and new levels\n            # TODO potential weird bug here if _from[\"data-level\"] is lower than flow for an infinite tank\n            flow = min(_from[\"data-level\"], remain, self.flow)\n            new_to_level = _to[\"data-level\"] + flow\n            _update_tank_level(xml_state, id_to, _to, new_to_level)\n            if id_from not in TANK_INF_IDS:\n                # \"from\" tank is a normal tank, fuel should be removed\n                new_from_level = _from[\"data-level\"] - flow\n                _update_tank_level(xml_state, id_from, _from, new_from_level)\n\n    def is_pump_on(self, xml_state: XMLState, target: str) -&gt; bool:\n        \"\"\"Is the given pump current in the \"on\" state?\n\n        Args:\n            xml_state (XMLState): environment state.\n            target (str): target pump.\n\n        Returns:\n            bool: whether the pump is on.\n        \"\"\"\n        xpath = PumpFuelAction.XPATH_PUMP % target\n        data_state = xml_state.select(select(xpath=xpath, attrs=[\"data-state\"]))[0][\n            \"data-state\"\n        ]\n        return data_state == PumpAction.ON\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.PumpFuelAction.is_pump_on","title":"<code>is_pump_on(xml_state, target)</code>","text":"<p>Is the given pump current in the \"on\" state?</p> <p>Parameters:</p> Name Type Description Default <code>xml_state</code> <code>XMLState</code> <p>environment state.</p> required <code>target</code> <code>str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the pump is on.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>def is_pump_on(self, xml_state: XMLState, target: str) -&gt; bool:\n    \"\"\"Is the given pump current in the \"on\" state?\n\n    Args:\n        xml_state (XMLState): environment state.\n        target (str): target pump.\n\n    Returns:\n        bool: whether the pump is on.\n    \"\"\"\n    xpath = PumpFuelAction.XPATH_PUMP % target\n    data_state = xml_state.select(select(xpath=xpath, attrs=[\"data-state\"]))[0][\n        \"data-state\"\n    ]\n    return data_state == PumpAction.ON\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator","title":"<code>ResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the resource management task.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class ResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the resource management task.\"\"\"\n\n    @attempt\n    def burn_fuel(\n        self,\n        target: int | str,\n        burn: float,\n    ) -&gt; \"BurnFuelAction\":\n        \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n        Args:\n            target (int | Literal[\"a\", \"b\"]): target tank\n            burn (float): amount of fuel to burn.\n\n        Returns:\n            BurnFuelAction: the action\n        \"\"\"\n        return BurnFuelAction(target=target, burn=burn)\n\n    @attempt\n    def pump_fuel(\n        self,\n        target: int | str,\n        flow: float,\n    ) -&gt; \"PumpFuelAction\":\n        \"\"\"Pumps the given amount of fuel via the given pump.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n            flow (float): amount of fuel to pump.\n\n        Returns:\n            PumpFuelAction: the action\n        \"\"\"\n        return PumpFuelAction(target=target, flow=flow)\n\n    @attempt\n    def toggle_pump_failure(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpFailureAction\":\n        \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpFailureAction(target=target)\n\n    @attempt\n    def toggle_pump(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpAction\":\n        \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.burn_fuel","title":"<code>burn_fuel(target, burn)</code>","text":"<p>Burns a given amount of fuel in the <code>target</code> tank, if the tank is empty this has no effect.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['a', 'b']</code> <p>target tank</p> required <code>burn</code> <code>float</code> <p>amount of fuel to burn.</p> required <p>Returns:</p> Name Type Description <code>BurnFuelAction</code> <code>BurnFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef burn_fuel(\n    self,\n    target: int | str,\n    burn: float,\n) -&gt; \"BurnFuelAction\":\n    \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n    Args:\n        target (int | Literal[\"a\", \"b\"]): target tank\n        burn (float): amount of fuel to burn.\n\n    Returns:\n        BurnFuelAction: the action\n    \"\"\"\n    return BurnFuelAction(target=target, burn=burn)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.pump_fuel","title":"<code>pump_fuel(target, flow)</code>","text":"<p>Pumps the given amount of fuel via the given pump.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump (this will determine which tanks are pumped to/from).</p> required <code>flow</code> <code>float</code> <p>amount of fuel to pump.</p> required <p>Returns:</p> Name Type Description <code>PumpFuelAction</code> <code>PumpFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef pump_fuel(\n    self,\n    target: int | str,\n    flow: float,\n) -&gt; \"PumpFuelAction\":\n    \"\"\"Pumps the given amount of fuel via the given pump.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n        flow (float): amount of fuel to pump.\n\n    Returns:\n        PumpFuelAction: the action\n    \"\"\"\n    return PumpFuelAction(target=target, flow=flow)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.toggle_pump","title":"<code>toggle_pump(target)</code>","text":"<p>Toggle pump state (on -&gt; off, off -&gt; on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpAction\":\n    \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.toggle_pump_failure","title":"<code>toggle_pump_failure(target)</code>","text":"<p>Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpFailureAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump_failure(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpFailureAction\":\n    \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpFailureAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction","title":"<code>SetPumpAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class for setting the state of a pump. Pumps states are off=0, on=1, failure=2.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class SetPumpAction(PumpAction):\n    \"\"\"Action class for setting the state of a pump. Pumps states are off=0, on=1, failure=2.\"\"\"\n\n    state: int\n\n    @field_validator(\"state\", mode=\"before\")\n    @classmethod\n    def _validate_state(cls, value: str | int):\n        if isinstance(value, str):\n            value = SetPumpAction.coerce_pump_state(value)\n        if value not in (PumpAction.OFF, PumpAction.ON, PumpAction.FAILURE):\n            raise ValueError(\n                f\"Invalid state `{value}` must be one of {[PumpAction.OFF, PumpAction.ON, PumpAction.FAILURE]}\"\n            )\n        return value\n\n    @staticmethod\n    def coerce_pump_state(value: int | str) -&gt; int:\n        \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1, \"failure\" -&gt; 2.\n\n        Args:\n            value (str | int): the value to coerce.\n\n        Raises:\n            ValueError: if the given state cannot be coerced.\n\n        Returns:\n            int: the integer state.\n        \"\"\"\n        if isinstance(value, int):\n            return value\n        if value == \"on\":\n            return PumpAction.ON\n        elif value == \"off\":\n            return PumpAction.OFF\n        elif value == \"failure\":\n            return PumpAction.FAILURE\n        else:\n            raise ValueError(\n                f\"Invalid state `{value}` must be one of ['on', 'off', 'failure']\"\n            )\n\n    @staticmethod\n    def new_on(target: int | str) -&gt; \"SetPumpAction\":\n        \"\"\"Factory method that returns an action that will turn the given pump on.\n\n        Args:\n            target (int | str): target pump.\n\n        Returns:\n            SetPumpAction: the action\n        \"\"\"\n        return SetPumpAction(target=target, state=PumpAction.ON)\n\n    @staticmethod\n    def new_off(target: int | str) -&gt; \"SetPumpAction\":\n        \"\"\"Factory method that returns an action that will turn the given pump off.\n\n        Args:\n            target (int | str): target pump.\n\n        Returns:\n            SetPumpAction: the action\n        \"\"\"\n        return SetPumpAction(target=target, state=PumpAction.OFF)\n\n    @staticmethod\n    def new_failure(target: int | str) -&gt; \"SetPumpAction\":\n        \"\"\"Factory function that returns an action that will make the pump fail.\n\n        Args:\n            target (int | str): target pump.\n\n        Returns:\n            SetPumpAction: the action\n        \"\"\"\n        return SetPumpAction(target=target, state=PumpAction.FAILURE)\n\n    def __execute__(self, state: XMLState):  # noqa\n        return state.update(\n            update(\n                xpath=f\"//*[@id='pump-{self.target}-button']\",\n                attrs={\n                    \"data-state\": str(self.state),\n                    \"fill\": Expr(\"{data-colors}[{state}]\", state=self.state),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.coerce_pump_state","title":"<code>coerce_pump_state(value)</code>  <code>staticmethod</code>","text":"<p>Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1, \"failure\" -&gt; 2.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int</code> <p>the value to coerce.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the given state cannot be coerced.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the integer state.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef coerce_pump_state(value: int | str) -&gt; int:\n    \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1, \"failure\" -&gt; 2.\n\n    Args:\n        value (str | int): the value to coerce.\n\n    Raises:\n        ValueError: if the given state cannot be coerced.\n\n    Returns:\n        int: the integer state.\n    \"\"\"\n    if isinstance(value, int):\n        return value\n    if value == \"on\":\n        return PumpAction.ON\n    elif value == \"off\":\n        return PumpAction.OFF\n    elif value == \"failure\":\n        return PumpAction.FAILURE\n    else:\n        raise ValueError(\n            f\"Invalid state `{value}` must be one of ['on', 'off', 'failure']\"\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.new_failure","title":"<code>new_failure(target)</code>  <code>staticmethod</code>","text":"<p>Factory function that returns an action that will make the pump fail.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>SetPumpAction</code> <code>SetPumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new_failure(target: int | str) -&gt; \"SetPumpAction\":\n    \"\"\"Factory function that returns an action that will make the pump fail.\n\n    Args:\n        target (int | str): target pump.\n\n    Returns:\n        SetPumpAction: the action\n    \"\"\"\n    return SetPumpAction(target=target, state=PumpAction.FAILURE)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.new_off","title":"<code>new_off(target)</code>  <code>staticmethod</code>","text":"<p>Factory method that returns an action that will turn the given pump off.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>SetPumpAction</code> <code>SetPumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new_off(target: int | str) -&gt; \"SetPumpAction\":\n    \"\"\"Factory method that returns an action that will turn the given pump off.\n\n    Args:\n        target (int | str): target pump.\n\n    Returns:\n        SetPumpAction: the action\n    \"\"\"\n    return SetPumpAction(target=target, state=PumpAction.OFF)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.new_on","title":"<code>new_on(target)</code>  <code>staticmethod</code>","text":"<p>Factory method that returns an action that will turn the given pump on.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>SetPumpAction</code> <code>SetPumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new_on(target: int | str) -&gt; \"SetPumpAction\":\n    \"\"\"Factory method that returns an action that will turn the given pump on.\n\n    Args:\n        target (int | str): target pump.\n\n    Returns:\n        SetPumpAction: the action\n    \"\"\"\n    return SetPumpAction(target=target, state=PumpAction.ON)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpAction","title":"<code>TogglePumpAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class that will toggle the pump on -&gt; off, off -&gt; on.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class TogglePumpAction(PumpAction):\n    \"\"\"Action class that will toggle the pump on -&gt; off, off -&gt; on.\"\"\"\n\n    @staticmethod\n    def new(\n        target: int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"],\n    ) -&gt; \"TogglePumpAction\":\n        \"\"\"Factory function for a `TogglePumpAction`.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n        Returns:\n            TogglePumpAction: the action.\n        \"\"\"\n        return TogglePumpAction(target=target)\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        # check if pump is in a failure state\n        pump_id = f\"pump-{self.target}-button\"\n        # 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 2 (cannot toggle if the pump is in failure)\n        new_state = \"(1-{data-state})%3\"\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='{pump_id}']\",\n                attrs={\n                    \"data-state\": Expr(new_state),\n                    # GOTCHA! data-state will be updated first (from above) and used to update fill! the order matters here.\n                    \"fill\": Expr(\"{data-colors}[{data-state}]\"),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpAction.new","title":"<code>new(target)</code>  <code>staticmethod</code>","text":"<p>Factory function for a <code>TogglePumpAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump</p> required <p>Returns:</p> Name Type Description <code>TogglePumpAction</code> <code>TogglePumpAction</code> <p>the action.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new(\n    target: int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"],\n) -&gt; \"TogglePumpAction\":\n    \"\"\"Factory function for a `TogglePumpAction`.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n    Returns:\n        TogglePumpAction: the action.\n    \"\"\"\n    return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpFailureAction","title":"<code>TogglePumpFailureAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class that will cause a pump failure (on/off -&gt; failure, failure -&gt; off).</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class TogglePumpFailureAction(PumpAction):\n    \"\"\"Action class that will cause a pump failure (on/off -&gt; failure, failure -&gt; off).\"\"\"\n\n    @staticmethod\n    def new(target: int) -&gt; \"TogglePumpFailureAction\":\n        \"\"\"Factory function for a `TogglePumpFailureAction`.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n        Returns:\n            TogglePumpFailureAction: the action.\n        \"\"\"\n        return TogglePumpFailureAction(target=target)\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        pump_id = f\"pump-{self.target}-button\"\n        # 0 -&gt; 2, 1 -&gt; 2, 2 -&gt; 0\n        new_state = \"2 * (1 - {data-state} // 2)\"\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='{pump_id}']\",\n                attrs={\n                    \"data-state\": Expr(new_state),\n                    # GOTCHA! data-state will be updated first (from above) and used to update fill! the order matters here.\n                    \"fill\": Expr(\"{data-colors}[{data-state}]\"),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpFailureAction.new","title":"<code>new(target)</code>  <code>staticmethod</code>","text":"<p>Factory function for a <code>TogglePumpFailureAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpFailureAction</code> <p>the action.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new(target: int) -&gt; \"TogglePumpFailureAction\":\n    \"\"\"Factory function for a `TogglePumpFailureAction`.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n    Returns:\n        TogglePumpFailureAction: the action.\n    \"\"\"\n    return TogglePumpFailureAction(target=target)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/","title":"System monitoring","text":"<p>Package that defines the matbii system monitoring task.</p>"},{"location":"reference/tasks/system_monitoring/#modules","title":"Modules","text":"<ul> <li>matbii/tasks/system_monitoring/system_monitoring.py</li> </ul>"},{"location":"reference/tasks/system_monitoring/system_monitoring/","title":"System monitoring","text":"<p>Module that implements the \"system monitoring\" task.</p> This files contains <ul> <li>avatar actuator: <code>AvatarSystemMonitoringActuator</code></li> <li>agent actuator: <code>SystemMonitoringActuator</code></li> <li>actions: [<code>TargetMoveAction</code>, <code>PerturbSliderAction</code>, <code>ResetSliderAction</code>, <code>SetSliderAction</code>, <code>SetLightAction</code>, <code>ToggleLightAction</code>]</li> </ul>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator","title":"<code>AvatarSystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class AvatarSystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_light_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n        )\n        self._get_slider_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n        - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[SetLightAction | SetSliderAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        actions = []\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_light_actions(user_action))\n            actions.extend(self._get_slider_actions(user_action))\n        return actions\n\n    def _get_light_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"ToggleLightAction\"]:\n        targets = [int(x) for x in self._get_light_targets(user_action.target)]\n        return [ToggleLightAction(target=target) for target in targets]\n\n    def _get_slider_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"SetSliderAction\"]:\n        targets = [int(x) for x in self._get_slider_targets(user_action.target)]\n        return [ResetSliderAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_light_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n    )\n    self._get_slider_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n    )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt either a <code>SetLightAction</code> or a <code>SetSliderAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>SetLightAction</code>: will always set the light to its preferred (acceptable) state. - <code>SetSliderAction</code> will reset the slider to its preferred (acceptable) state (which is the central position), see <code>ResetSliderAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[Union[SetLightAction, SetSliderAction]]</code> <p>list[SetLightAction | SetSliderAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n    - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[SetLightAction | SetSliderAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    actions = []\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_light_actions(user_action))\n        actions.extend(self._get_slider_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetLightAction","title":"<code>SetLightAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will update a light's state (on=1 or off=0).</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class SetLightAction(XMLUpdateQuery):\n    \"\"\"Action class that will update a light's state (on=1 or off=0).\"\"\"\n\n    target: int  # the target light\n    state: int  # the new state of the light\n\n    OFF: ClassVar[int] = 0  # off state\n    ON: ClassVar[int] = 1  # on state\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value):\n        if value not in VALID_LIGHT_IDS:\n            raise ValueError(f\"`target` {value} must be one of {VALID_LIGHT_IDS}\")\n        return value\n\n    @field_validator(\"state\", mode=\"before\")\n    @classmethod\n    def _validate_state(cls, value: int | str):\n        if isinstance(value, str):\n            value = SetLightAction.coerce_light_state(value)\n        if value not in (SetLightAction.OFF, SetLightAction.ON):\n            raise ValueError(\n                f\"Invalid state `{value}` must be one of {[SetLightAction.OFF, SetLightAction.ON]}\"\n            )\n        return value\n\n    @staticmethod\n    def coerce_light_state(value: str | int) -&gt; int:\n        \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1.\n\n        Args:\n            value (str | int): the value to coerce valid values: 0,1,\"on\",\"off.\n\n        Raises:\n            ValueError: if the given state cannot be  coerced.\n\n        Returns:\n            int: the integer state.\n        \"\"\"\n        if isinstance(value, int):\n            return value\n        if value == \"on\":\n            return SetLightAction.ON\n        elif value == \"off\":\n            return SetLightAction.OFF\n        else:\n            raise ValueError(f\"Invalid state `{value}` must be one of ['on', 'off']\")\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='light-{self.target}-button']\",\n                attrs={\n                    \"data-state\": str(self.state),\n                    \"fill\": Expr(\"{data-colors}[{state}]\", state=self.state),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetLightAction.coerce_light_state","title":"<code>coerce_light_state(value)</code>  <code>staticmethod</code>","text":"<p>Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int</code> <p>the value to coerce valid values: 0,1,\"on\",\"off.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the given state cannot be  coerced.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the integer state.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef coerce_light_state(value: str | int) -&gt; int:\n    \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1.\n\n    Args:\n        value (str | int): the value to coerce valid values: 0,1,\"on\",\"off.\n\n    Raises:\n        ValueError: if the given state cannot be  coerced.\n\n    Returns:\n        int: the integer state.\n    \"\"\"\n    if isinstance(value, int):\n        return value\n    if value == \"on\":\n        return SetLightAction.ON\n    elif value == \"off\":\n        return SetLightAction.OFF\n    else:\n        raise ValueError(f\"Invalid state `{value}` must be one of ['on', 'off']\")\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetSliderAction","title":"<code>SetSliderAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will update a sliders's state. The state of a slider is the integer index of one of its increments.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class SetSliderAction(XMLUpdateQuery):\n    \"\"\"Action class that will update a sliders's state. The state of a slider is the integer index of one of its increments.\"\"\"\n\n    # slider to target\n    target: int\n    # state to set, or offset from current state, or None if should reset the state.\n    state: int | None\n    # is `state` relative to the current state?\n    relative: bool = Field(default_factory=lambda: False)\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value):\n        if value not in VALID_SLIDER_IDS:\n            raise ValueError(f\"`target` {value} must be one of {VALID_LIGHT_IDS}\")\n        return value\n\n    @staticmethod\n    def acceptable_state(increments: int) -&gt; int:\n        \"\"\"Defines the acceptable state of the slider. This is the state that the slider will return to if the actions `state` field is None.\n\n        Args:\n            increments (int): the number of increments in the slider.\n\n        Returns:\n            int: the acceptable state of the slider\n        \"\"\"\n        return increments // 2\n\n    def __execute__(self, xml_state: XMLState) -&gt; Any:  # noqa\n        # get min and max values for the number of increments\n        inc_target = f\"slider-{self.target}-incs\"\n        but_target = f\"slider-{self.target}-button\"\n        response = xml_state.select(\n            select(\n                xpath=f\"//*[@id='{inc_target}']/svg:line\",\n                attrs=[\"y1\", \"data-state\"],\n            )\n        )\n        states = {x[\"data-state\"]: x[\"y1\"] for x in response}\n        # TODO check that these are all the same?\n        inc_size = states[2] - states[1]\n        min_state, max_state = (min(states.keys()), max(states.keys()) - 1)\n        state = self.state\n        if state is None:\n            self.relative = False\n            state = SetSliderAction.acceptable_state(max_state + 1)\n\n        # we select the parent of the button node because it contains the state and position to update\n        xpath_parent = f\"//*[@id='{but_target}']/parent::node()\"\n        if self.relative:\n            # update the state relative to the current state\n            response = xml_state.select(\n                select(\n                    xpath=xpath_parent,\n                    attrs=[\"data-state\"],\n                )\n            )\n            assert len(response) == 1\n            state = response[0][\"data-state\"] + self.state\n\n        # new state should not overflow\n        state = min(max(min_state, state), max_state)\n        new_y = states[state] - inc_size\n        return xml_state.update(\n            update(\n                xpath=xpath_parent,\n                attrs={\"data-state\": state, \"y\": new_y},\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetSliderAction.acceptable_state","title":"<code>acceptable_state(increments)</code>  <code>staticmethod</code>","text":"<p>Defines the acceptable state of the slider. This is the state that the slider will return to if the actions <code>state</code> field is None.</p> <p>Parameters:</p> Name Type Description Default <code>increments</code> <code>int</code> <p>the number of increments in the slider.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the acceptable state of the slider</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef acceptable_state(increments: int) -&gt; int:\n    \"\"\"Defines the acceptable state of the slider. This is the state that the slider will return to if the actions `state` field is None.\n\n    Args:\n        increments (int): the number of increments in the slider.\n\n    Returns:\n        int: the acceptable state of the slider\n    \"\"\"\n    return increments // 2\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator","title":"<code>SystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the system monitoring task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@agent_actuator\nclass SystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the system monitoring task.\"\"\"\n\n    @attempt\n    def on_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"on\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.ON)\n\n    @attempt\n    def off_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"off\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.OFF)\n\n    @attempt\n    def toggle_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return ToggleLightAction(target=target)\n\n    @attempt\n    def perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n        \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n        Args:\n            target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n        Returns:\n            SetSliderAction: the action\n        \"\"\"\n        state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n        return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.off_light","title":"<code>off_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"off\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef off_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"off\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.OFF)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.on_light","title":"<code>on_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"on\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef on_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"on\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.ON)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.perturb_slider","title":"<code>perturb_slider(target)</code>","text":"<p>Perturb the <code>target</code> slider by +/- 1 slot.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n    return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.toggle_light","title":"<code>toggle_light(target)</code>","text":"<p>Toggle the <code>target</code> light (on-&gt;off, off-&gt;on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef toggle_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return ToggleLightAction(target=target)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.ToggleLightAction","title":"<code>ToggleLightAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will toggle a light's state from on-&gt;off and off-&gt;on.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class ToggleLightAction(XMLUpdateQuery):\n    \"\"\"Action class that will toggle a light's state from on-&gt;off and off-&gt;on.\"\"\"\n\n    target: int\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value):\n        if value not in VALID_LIGHT_IDS:\n            raise ValueError(f\"`target` {value} must be one of {VALID_LIGHT_IDS}\")\n        return value\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='light-{self.target}-button']\",\n                attrs={\n                    \"data-state\": Expr(\"1-{data-state}\"),\n                    # GOTCHA! data-state will be updated first (above) and used to update fill! the dict order matters here.\n                    \"fill\": Expr(\"{data-colors}[{data-state}]\"),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.PerturbSliderAction","title":"<code>PerturbSliderAction(target)</code>","text":"<p>Perturb the <code>target</code> slider by +/- 1 slot.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def PerturbSliderAction(target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    state = random.randint(0, 1) * 2 - 1\n    return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.ResetSliderAction","title":"<code>ResetSliderAction(target)</code>","text":"<p>Reset the <code>target</code> slider to its central position.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def ResetSliderAction(target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Reset the `target` slider to its central position.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    return SetSliderAction(target=target, state=None, relative=False)\n</code></pre>"},{"location":"reference/tasks/tracking/","title":"Tracking","text":"<p>Package that defines the matbii tracking task.</p>"},{"location":"reference/tasks/tracking/#modules","title":"Modules","text":"<ul> <li>matbii/tasks/tracking/tracking.py</li> </ul>"},{"location":"reference/tasks/tracking/tracking/","title":"Tracking","text":"<p>Module that implements the \"tracking\" task.</p> This files contains <ul> <li>avatar actuator: <code>AvatarTrackingActuator</code></li> <li>agent actuator: <code>TrackingActuator</code></li> <li>actions: [<code>TargetMoveAction</code>]</li> </ul>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator","title":"<code>AvatarTrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class AvatarTrackingActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.\"\"\"\n\n    def __init__(\n        self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            target_speed (float): the speed of the target (svg units per second).\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._keys_pressed = set()\n        self._prev_time = time.time()\n        self._target_speed = target_speed\n\n    def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n        \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n        Returns:\n            list[TargetMoveAction]: the action\n        \"\"\"\n        current_time = time.time()\n        # this will contain the user action (KeyEvent)\n        actions = []\n        if len(self._keys_pressed) &gt; 0:\n            # compute speed based on time that has passed\n            dt = current_time - self._prev_time\n            speed = self._target_speed * dt\n            # this will be normalised when the action is executed\n            result = [0, 0]\n            # compute the movement action based on the currently pressed keys\n            for key in self._keys_pressed:\n                direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n                result[0] += direction[0]\n                result[1] += direction[1]\n            if result[0] != 0 or result[1] != 0:\n                actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n        self._prev_time = current_time\n        return actions\n\n    @attempt\n    def attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n        \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        Args:\n            user_action (KeyEvent): the users keyboard action\n\n        Returns:\n            list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n        \"\"\"\n        if user_action.key.lower() in DEFAULT_KEY_BINDING:\n            if user_action.status == KeyEvent.UP:\n                self._keys_pressed.remove(user_action.key)\n            elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n                self._keys_pressed.add(user_action.key)\n        return []\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator.__attempt__","title":"<code>__attempt__()</code>","text":"<p>Attempt method that will attempt a <code>TargetMoveAction</code> to move the target according to the users input (if it has been provided since the last call to this method).</p> <p>Returns:</p> Type Description <code>list[TargetMoveAction]</code> <p>list[TargetMoveAction]: the action</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n    \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n    Returns:\n        list[TargetMoveAction]: the action\n    \"\"\"\n    current_time = time.time()\n    # this will contain the user action (KeyEvent)\n    actions = []\n    if len(self._keys_pressed) &gt; 0:\n        # compute speed based on time that has passed\n        dt = current_time - self._prev_time\n        speed = self._target_speed * dt\n        # this will be normalised when the action is executed\n        result = [0, 0]\n        # compute the movement action based on the currently pressed keys\n        for key in self._keys_pressed:\n            direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n            result[0] += direction[0]\n            result[1] += direction[1]\n        if result[0] != 0 or result[1] != 0:\n            actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n    self._prev_time = current_time\n    return actions\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator.__init__","title":"<code>__init__(target_speed=5.0, *args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>target_speed</code> <code>float</code> <p>the speed of the target (svg units per second).</p> <code>5.0</code> <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __init__(\n    self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n):\n    \"\"\"Constructor.\n\n    Args:\n        target_speed (float): the speed of the target (svg units per second).\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._keys_pressed = set()\n    self._prev_time = time.time()\n    self._target_speed = target_speed\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator.attempt_key_event","title":"<code>attempt_key_event(user_action)</code>","text":"<p>Attempt method that takes a <code>KeyEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>KeyEvent</code> <p>the users keyboard action</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>an empty list (no action is taken by this attempt method, see <code>AvatarTrackingActuator.__attempt__</code>.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n    \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    Args:\n        user_action (KeyEvent): the users keyboard action\n\n    Returns:\n        list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n    \"\"\"\n    if user_action.key.lower() in DEFAULT_KEY_BINDING:\n        if user_action.status == KeyEvent.UP:\n            self._keys_pressed.remove(user_action.key)\n        elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n            self._keys_pressed.add(user_action.key)\n    return []\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TargetMoveAction","title":"<code>TargetMoveAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will update the tracking target position.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class TargetMoveAction(XMLUpdateQuery):\n    \"\"\"Action class that will update the tracking target position.\"\"\"\n\n    direction: tuple[float, float]\n    speed: float\n\n    @field_validator(\"direction\", mode=\"before\")\n    @classmethod\n    def _validate_direction(cls, value):\n        if isinstance(value, list):\n            value = tuple(value)  # a list is ok, convert it to a tuple\n        if isinstance(value, tuple):\n            if len(value) == 2:\n                # normalise the direction\n                d = math.sqrt(value[0] ** 2 + value[1] ** 2)\n                if d == 0:\n                    return (0.0, 0.0)\n                return (float(value[0]) / d, float(value[1]) / d)\n        raise ValueError(f\"Invalid direction {value}, must be Tuple[float,float].\")\n\n    @field_validator(\"speed\", mode=\"before\")\n    @classmethod\n    def _validate_speed(cls, value):\n        return float(value)\n\n    def __execute__(self, state: XMLState):  # noqa\n        if self.direction == (0.0, 0.0):\n            LOGGER.warning(\n                f\"Attempted {TargetMoveAction.__name__} with direction (0,0)\",\n            )\n            return\n        dx = self.direction[0] * self.speed\n        dy = self.direction[1] * self.speed\n        # get properties of the tracking task\n        properties = state.select(\n            select(\n                xpath=\"//svg:svg/svg:svg[@id='tracking']\",\n                attrs=[\"width\", \"height\"],\n            )\n        )[0]\n        # task bounds should limit the new position\n        x1, y1 = (0.0, 0.0)\n        x2, y2 = x1 + properties[\"width\"], y1 + properties[\"height\"]\n\n        new_x = Expr(\"max(min({x} + {dx}, {x2} - {width}), {x1})\", dx=dx, x1=x1, x2=x2)\n        new_y = Expr(\"max(min({y} + {dy}, {y2} - {height}), {y1})\", dy=dy, y1=x1, y2=y2)\n        return state.update(\n            update(\n                xpath=\"//svg:svg/svg:svg/svg:svg[@id='tracking_target']\",\n                attrs=dict(x=new_x, y=new_y),\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TrackingActuator","title":"<code>TrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the tracking task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class TrackingActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the tracking task.\"\"\"\n\n    @attempt\n    def move_target(\n        self, direction: tuple[float, float] | int | float, speed: float\n    ) -&gt; \"TargetMoveAction\":\n        \"\"\"Move the tracking target in a given direction at a given speed.\n\n        Args:\n            direction (tuple[float, float] | int | float): direction to move.\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        # an angle was provided (in degrees), convert it to a direction vector\n        if isinstance(direction, int | float):\n            angle = math.radians(direction)\n            direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n\n    @attempt\n    def perturb_target(self, speed: float) -&gt; \"TargetMoveAction\":\n        \"\"\"Move the tracking target in a random direction at a given speed.\n\n        Args:\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        angle = (random.random() * 2 - 1) * math.pi\n        direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TrackingActuator.move_target","title":"<code>move_target(direction, speed)</code>","text":"<p>Move the tracking target in a given direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>tuple[float, float] | int | float</code> <p>direction to move.</p> required <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef move_target(\n    self, direction: tuple[float, float] | int | float, speed: float\n) -&gt; \"TargetMoveAction\":\n    \"\"\"Move the tracking target in a given direction at a given speed.\n\n    Args:\n        direction (tuple[float, float] | int | float): direction to move.\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    # an angle was provided (in degrees), convert it to a direction vector\n    if isinstance(direction, int | float):\n        angle = math.radians(direction)\n        direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TrackingActuator.perturb_target","title":"<code>perturb_target(speed)</code>","text":"<p>Move the tracking target in a random direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef perturb_target(self, speed: float) -&gt; \"TargetMoveAction\":\n    \"\"\"Move the tracking target in a random direction at a given speed.\n\n    Args:\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    angle = (random.random() * 2 - 1) * math.pi\n    direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":"<p>Package defining various utilities.</p>"},{"location":"reference/utils/#modules","title":"Modules","text":"<ul> <li>matbii/utils/_const.py</li> </ul>"}]}