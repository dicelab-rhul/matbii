{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"matbii","text":""},{"location":"configuration_default/","title":"Configuration default","text":"<p>{  \"experiment\": {   \"id\": null,   \"path\": \"C:/Users/brjw/Documents/repos/dicelab/matbii/example/experiment-C\",   \"duration\": -1,   \"enable_video_recording\": false,   \"enable_tasks\": [    \"system_monitoring\",    \"resource_management\",    \"tracking\"   ],   \"meta\": {}  },  \"participant\": {   \"id\": null,   \"meta\": {}  },  \"guidance\": {   \"enable\": true,   \"counter_factual\": false  },  \"window\": {   \"x\": 0,   \"y\": 0,   \"width\": 640,   \"height\": 480,   \"title\": \"window\",   \"resizable\": false,   \"fullscreen\": false,   \"background_color\": \"#ffffff\"  },  \"eyetracking\": {   \"uri\": null,   \"sdk\": \"tobii\",   \"enabled\": false,   \"moving_average_n\": 5,   \"velocity_threshold\": 0.5  },  \"logging\": {   \"level\": \"INFO\",   \"path\": \"./logs/\"  },  \"ui\": {   \"size\": [    800,    600   ],   \"offset\": [    0,    0   ]  } }</p>"},{"location":"configuration_doc/","title":"Configuration doc","text":""},{"location":"configuration_doc/#configuration","title":"Configuration","text":"<ul> <li><code>experiment (ExperimentConfiguration)</code>: None Defaults to: <code>None</code>.</li> <li><code>participant (ParticipantConfiguration)</code>: None Defaults to: <code>None</code>.</li> <li><code>guidance (GuidanceConfiguration)</code>: None Defaults to: <code>None</code>.</li> <li><code>window (WindowConfiguration)</code>: None Defaults to: <code>None</code>.</li> <li><code>eyetracking (EyetrackingConfiguration)</code>: None Defaults to: <code>None</code>.</li> <li><code>logging (LoggingConfiguration)</code>: None Defaults to: <code>None</code>.</li> <li><code>ui (UIConfiguration)</code>: None Defaults to: <code>None</code>.</li> </ul>"},{"location":"configuration_doc/#experiment-configuration","title":"Experiment Configuration","text":"<ul> <li><code>id (str)</code>: The unique ID of this experiment. Defaults to: <code>None</code>.</li> <li><code>path (str)</code>: The full path to the directory containing task configuration files, details on configuring tasks consult the wiki. If this is a relative path it is relative to the current working directory. Defaults to: <code>None</code>.</li> <li><code>duration (int)</code>: The duration (in seconds) of this experiment (the simulation will close after this time), a negative value will leave the simulation running forever. Defaults to: <code>-1</code>.</li> <li><code>enable_video_recording (bool)</code>: Whether to begin a screen recording of the experiment when the simulation starts, the video will be saved to the logging path when the experiment ends. Defaults to: <code>False</code>.</li> <li><code>enable_tasks (list[str])</code>: Which tasks to enable at the start of the simulation. Defaults to: <code>['system_monitoring', 'resource_management', 'tracking']</code>.</li> <li><code>meta (dict)</code>: Any additional meta data you wish to associate with this experiment. Defaults to: <code>{}</code>.</li> </ul>"},{"location":"configuration_doc/#participant-configuration","title":"Participant Configuration","text":"<ul> <li><code>id (str)</code>: The unique ID of the participant that is taking part in the experiment. Defaults to: <code>None</code>.</li> <li><code>meta (dict)</code>: Any additional meta data you wish to associate with the participant. Defaults to: <code>{}</code>.</li> </ul>"},{"location":"configuration_doc/#guidance-configuration","title":"Guidance Configuration","text":"<ul> <li><code>enable (bool)</code>: Whether to enable guidance, if this is False then no guidance agent will be created. Defaults to: <code>True</code>.</li> <li><code>counter_factual (bool)</code>: Whether to show guidance to the user, if False then guidance agent will be configured NOT to display guidance but will still take actions for logging purposes (if they support this). Defaults to: <code>False</code>.</li> </ul>"},{"location":"configuration_doc/#window-configuration","title":"Window Configuration","text":"<ul> <li><code>x (int)</code>: None Defaults to: <code>0</code>.</li> <li><code>y (int)</code>: None Defaults to: <code>0</code>.</li> <li><code>width (int)</code>: None Defaults to: <code>640</code>.</li> <li><code>height (int)</code>: None Defaults to: <code>480</code>.</li> <li><code>title (str)</code>: None Defaults to: <code>\"window\"</code>.</li> <li><code>resizable (bool)</code>: None Defaults to: <code>False</code>.</li> <li><code>fullscreen (bool)</code>: None Defaults to: <code>False</code>.</li> <li><code>background_color (str)</code>: None Defaults to: <code>\"#ffffff\"</code>.</li> </ul>"},{"location":"configuration_doc/#eyetracking-configuration","title":"Eyetracking Configuration","text":"<ul> <li><code>uri (str | None)</code>: The eyetracker address (example: <code>'tet-tcp://172.28.195.1'</code>). For details on setting up eyetracking, consult the wiki. Defaults to: <code>None</code>.</li> <li><code>sdk (str)</code>: The eyetracking SDK to use, current options are: ['tobii']. Defaults to: <code>\"tobii\"</code>.</li> <li><code>enabled (bool)</code>: Whether eyetracking is enabled. Defaults to: <code>False</code>.</li> <li><code>moving_average_n (int)</code>: The window size to used to smooth eyetracking coordinates. Defaults to: <code>5</code>.</li> <li><code>velocity_threshold (float)</code>: The threshold on gaze velocity which will determine saccades/fixations. This is defined in screen space, where the screen coordinates are normalised in the range [0,1]. IMPORTANT NOTE: different monitor sizes may require different values, unfortunately this is difficult to standardise without access to data on the gaze angle (which would be monitor size independent). Defaults to: <code>0.5</code>.</li> </ul>"},{"location":"configuration_doc/#logging-configuration","title":"Logging Configuration","text":"<ul> <li><code>level (str)</code>: The logging level to use: ['DEBUG', 'INFO', 'WARNING', 'ERROR'], this will not affect event logging. Defaults to: <code>\"INFO\"</code>.</li> <li><code>path (str)</code>: The path to the directory where log files will be written. Defaults to: <code>\"./logs/\"</code>.</li> </ul>"},{"location":"configuration_doc/#ui-configuration","title":"UI Configuration","text":"<ul> <li><code>size (tuple[int,int])</code>: The width and height of the canvas used to render the tasks. This should fully encapsulate all task elements. If a task appears to be off screen, try increasing this value. Defaults to: <code>(800, 600)</code>.</li> <li><code>offset (tuple[int,int])</code>: The x and y offset used when rendering the root UI element, can be used to pad the top/left of the window. Defaults to: <code>(0, 0)</code>.</li> </ul>"},{"location":"resource_management_config/","title":"Resource management config","text":"<p>Below is a table outlining all configuration options for the resource management task. </p> <p>The <code>cerberus</code> schema file can be found here.</p> <p>The <code>svg</code> file used to render the task can be found here.</p> Field Name Type Default Description x integer 260 x position of the task y integer 360 y position of the task width integer 540 width of the task height integer 300 height of the task padding integer 10 padding surrounding the task pump_on_color color \"#00ff00\" color of pumps when in the \"on\" state pump_off_color color \"#add9e6\" color of pumps when in the \"off\" state pump_failure_color color \"#ff0000\" color of pumps when in the \"failure\" state stroke_color color \"#000000\" line colour stroke_width integer 2 line width show_tank_labels boolean true whether to show textual labels next to each tank background_color color \"#ffffff\" background color of the tanks debug boolean false whether to display debug information tank_capacity dict See details below: tank_capacity.a integer 2000 capacity for tank a tank_capacity.b integer 2000 capacity for tank b tank_capacity.c integer 1500 capacity for tank c tank_capacity.d integer 1500 capacity for tank d tank_capacity.e integer 1000 capacity for tank e tank_capacity.f integer 1000 capacity for tank f tank_level dict See details below: tank_level.a integer 1000 starting fuel level for tank a (&lt; tank_capacity.a) tank_level.b integer 1000 starting fuel level for tank b (&lt; tank_capacity.b) tank_level.c integer 750 starting fuel level for tank c (&lt; tank_capacity.c) tank_level.d integer 750 starting fuel level for tank d (&lt; tank_capacity.d) tank_level.e integer 750 starting fuel level for tank e (&lt; tank_capacity.e) tank_level.f integer 750 starting fuel level for tank f (&lt; tank_capacity.f) pump_state dict See details below: pump_state.ab str off starting state of pump ab (options \"off\", \"on\", \"failure\") pump_state.ba str off starting state of pump ba (options \"off\", \"on\", \"failure\") pump_state.ca str off starting state of pump ca (options \"off\", \"on\", \"failure\") pump_state.ec str off starting state of pump ec (options \"off\", \"on\", \"failure\") pump_state.ea str off starting state of pump ea (options \"off\", \"on\", \"failure\") pump_state.db str off starting state of pump db (options \"off\", \"on\", \"failure\") pump_state.fd str off starting state of pump fd (options \"off\", \"on\", \"failure\") pump_state.fb str off starting state of pump fb (options \"off\", \"on\", \"failure\")"},{"location":"system_monitoring_config/","title":"System monitoring config","text":"<p>Below is a table outlining all configuration options for the system monitoring task. </p> <p>The <code>cerberus</code> schema file can be found here.</p> <p>The <code>svg</code> file used to render the task can be found here.</p> Field Name Type Default Description x integer 0 x position of the task y integer 0 y position of the task width integer 240 width of the task height integer 330 height of the task padding integer 10 padding surrounding the task debug boolean false whether to display debug information show_keyboard_shortcuts boolean false whether to display keyboard shortcuts font_size integer 12 font size stroke_width integer 2 line width light_state list [0, 0] initial states of each light (options: 0 or 1) light_on_color color \"#00ff00\" color of light 1 when on light_failure_color color \"#ff0000\" color of light 2 when on light_off_color color \"#add9e6\" color of light 1 and 2 when off light_width integer 75 width of each light light_height integer 50 height of each light slider_num_increments integer 11 number of increments in each slider slider_state list [5, 5, 5, 5] intial states of each slider (options: 0 to slider_num_increments-1) slider_width integer 30 width of each slider slider_height integer 20 height of each slider slider_background_color color \"#add9e6\" slider background color slider_color color \"#4682b4\" slider color slider_arrow_color color \"#ffff00\" slider arrow color"},{"location":"tracking_config/","title":"Tracking config","text":"<p>Below is a table outlining all configuration options for the tracking task. </p> <p>The <code>cerberus</code> schema file can be found here.</p> <p>The <code>svg</code> file used to render the task can be found here.</p> Field Name Type Default Description x integer 320 x position of the task y integer 0 y position of the task width integer 320 width of the task height integer 320 height of the task padding integer 10 padding surrounding the task debug boolean false whether to display debug information line_color color \"#1d90ff\" line color target_color color \"#1d90ff\" line color of the target target_line_width integer 4 width of the target lines target_x_offset integer 0 starting x position of the target target_y_offset integer 0 starting y position of the target target_radius integer 25 size of the target dash_array string \"4,2,1,2\" dash array for dashed lines"},{"location":"reference/","title":"Reference","text":"<p>Matbii package.</p>"},{"location":"reference/#packages","title":"Packages","text":"<ul> <li>matbii/agent</li> <li>matbii/avatar</li> <li>matbii/config</li> <li>matbii/environment</li> <li>matbii/guidance</li> <li>matbii/tasks</li> <li>matbii/utils</li> </ul>"},{"location":"reference/#modules","title":"Modules","text":"<ul> <li>matbii/_const.py</li> <li>matbii/main.py</li> </ul>"},{"location":"reference/agent/","title":"Agent","text":"<p>Package defining agent related functionality.</p>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator","title":"<code>ResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the resource management task.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class ResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the resource management task.\"\"\"\n\n    @attempt\n    def burn_fuel(\n        self,\n        target: int | str,\n        burn: float,\n    ) -&gt; \"BurnFuelAction\":\n        \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n        Args:\n            target (int | Literal[\"a\", \"b\"]): target tank\n            burn (float): amount of fuel to burn.\n\n        Returns:\n            BurnFuelAction: the action\n        \"\"\"\n        return BurnFuelAction(target=target, burn=burn)\n\n    @attempt\n    def pump_fuel(\n        self,\n        target: int | str,\n        flow: float,\n    ) -&gt; \"PumpFuelAction\":\n        \"\"\"Pumps the given amount of fuel via the given pump.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n            flow (float): amount of fuel to pump.\n\n        Returns:\n            PumpFuelAction: the action\n        \"\"\"\n        return PumpFuelAction(target=target, flow=flow)\n\n    @attempt\n    def toggle_pump_failure(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpFailureAction\":\n        \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpFailureAction(target=target)\n\n    @attempt\n    def toggle_pump(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpAction\":\n        \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.burn_fuel","title":"<code>burn_fuel(target, burn)</code>","text":"<p>Burns a given amount of fuel in the <code>target</code> tank, if the tank is empty this has no effect.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['a', 'b']</code> <p>target tank</p> required <code>burn</code> <code>float</code> <p>amount of fuel to burn.</p> required <p>Returns:</p> Name Type Description <code>BurnFuelAction</code> <code>BurnFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef burn_fuel(\n    self,\n    target: int | str,\n    burn: float,\n) -&gt; \"BurnFuelAction\":\n    \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n    Args:\n        target (int | Literal[\"a\", \"b\"]): target tank\n        burn (float): amount of fuel to burn.\n\n    Returns:\n        BurnFuelAction: the action\n    \"\"\"\n    return BurnFuelAction(target=target, burn=burn)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.pump_fuel","title":"<code>pump_fuel(target, flow)</code>","text":"<p>Pumps the given amount of fuel via the given pump.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump (this will determine which tanks are pumped to/from).</p> required <code>flow</code> <code>float</code> <p>amount of fuel to pump.</p> required <p>Returns:</p> Name Type Description <code>PumpFuelAction</code> <code>PumpFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef pump_fuel(\n    self,\n    target: int | str,\n    flow: float,\n) -&gt; \"PumpFuelAction\":\n    \"\"\"Pumps the given amount of fuel via the given pump.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n        flow (float): amount of fuel to pump.\n\n    Returns:\n        PumpFuelAction: the action\n    \"\"\"\n    return PumpFuelAction(target=target, flow=flow)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.toggle_pump","title":"<code>toggle_pump(target)</code>","text":"<p>Toggle pump state (on -&gt; off, off -&gt; on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpAction\":\n    \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.ResourceManagementActuator.toggle_pump_failure","title":"<code>toggle_pump_failure(target)</code>","text":"<p>Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpFailureAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump_failure(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpFailureAction\":\n    \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpFailureAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator","title":"<code>SystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the system monitoring task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@agent_actuator\nclass SystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the system monitoring task.\"\"\"\n\n    @attempt\n    def on_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"on\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.ON)\n\n    @attempt\n    def off_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"off\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.OFF)\n\n    @attempt\n    def toggle_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return ToggleLightAction(target=target)\n\n    @attempt\n    def perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n        \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n        Args:\n            target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n        Returns:\n            SetSliderAction: the action\n        \"\"\"\n        state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n        return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.off_light","title":"<code>off_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"off\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef off_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"off\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.OFF)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.on_light","title":"<code>on_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"on\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef on_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"on\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.ON)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.perturb_slider","title":"<code>perturb_slider(target)</code>","text":"<p>Perturb the <code>target</code> slider by +/- 1 slot.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n    return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.SystemMonitoringActuator.toggle_light","title":"<code>toggle_light(target)</code>","text":"<p>Toggle the <code>target</code> light (on-&gt;off, off-&gt;on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef toggle_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return ToggleLightAction(target=target)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.TrackingActuator","title":"<code>TrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the tracking task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class TrackingActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the tracking task.\"\"\"\n\n    @attempt\n    def move_target(\n        self, direction: tuple[float, float] | int | float, speed: float\n    ) -&gt; \"TargetMoveAction\":\n        \"\"\"Move the tracking target in a given direction at a given speed.\n\n        Args:\n            direction (tuple[float, float] | int | float): direction to move.\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        # an angle was provided (in degrees), convert it to a direction vector\n        if isinstance(direction, int | float):\n            angle = math.radians(direction)\n            direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n\n    @attempt\n    def perturb_target(self, speed: float):\n        \"\"\"Move the tracking target in a random direction at a given speed.\n\n        Args:\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        angle = (random.random() * 2 - 1) * math.pi\n        direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.TrackingActuator.move_target","title":"<code>move_target(direction, speed)</code>","text":"<p>Move the tracking target in a given direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>tuple[float, float] | int | float</code> <p>direction to move.</p> required <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef move_target(\n    self, direction: tuple[float, float] | int | float, speed: float\n) -&gt; \"TargetMoveAction\":\n    \"\"\"Move the tracking target in a given direction at a given speed.\n\n    Args:\n        direction (tuple[float, float] | int | float): direction to move.\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    # an angle was provided (in degrees), convert it to a direction vector\n    if isinstance(direction, int | float):\n        angle = math.radians(direction)\n        direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/agent/#matbii.agent.TrackingActuator.perturb_target","title":"<code>perturb_target(speed)</code>","text":"<p>Move the tracking target in a random direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef perturb_target(self, speed: float):\n    \"\"\"Move the tracking target in a random direction at a given speed.\n\n    Args:\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    angle = (random.random() * 2 - 1) * math.pi\n    direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/avatar/","title":"Avatar","text":"<p>Package defining avatar related functionality.</p>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator","title":"<code>AvatarResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class AvatarResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_pump_targets = partial(\n            AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[TogglePumpAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        # always include the user action as it needs to be logged\n        actions = []\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_pump_actions(user_action))\n        return actions\n\n    def _get_pump_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        targets = self._get_pump_targets(user_action.target)\n        return [TogglePumpAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_pump_targets = partial(\n        AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n    )\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt a <code>TogglePumpAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>TogglePumpAction</code>: toggle the pump on-&gt;off or off-&gt;on.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[TogglePumpAction]</code> <p>list[TogglePumpAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[\"TogglePumpAction\"]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[TogglePumpAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    # always include the user action as it needs to be logged\n    actions = []\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_pump_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarResourceManagementActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator","title":"<code>AvatarSystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class AvatarSystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_light_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n        )\n        self._get_slider_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n        - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[SetLightAction | SetSliderAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        # always include the user action as it needs to be logged\n        actions = [user_action]\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_light_actions(user_action))\n            actions.extend(self._get_slider_actions(user_action))\n        return actions\n\n    def _get_light_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"ToggleLightAction\"]:\n        targets = [int(x) for x in self._get_light_targets(user_action.target)]\n        return [ToggleLightAction(target=target) for target in targets]\n\n    def _get_slider_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"SetSliderAction\"]:\n        targets = [int(x) for x in self._get_slider_targets(user_action.target)]\n        return [ResetSliderAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_light_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n    )\n    self._get_slider_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n    )\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt either a <code>SetLightAction</code> or a <code>SetSliderAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>SetLightAction</code>: will always set the light to its preferred (acceptable) state. - <code>SetSliderAction</code> will reset the slider to its preferred (acceptable) state (which is the central position), see <code>ResetSliderAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[Union[SetLightAction, SetSliderAction]]</code> <p>list[SetLightAction | SetSliderAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n    - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[SetLightAction | SetSliderAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    # always include the user action as it needs to be logged\n    actions = [user_action]\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_light_actions(user_action))\n        actions.extend(self._get_slider_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarSystemMonitoringActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator","title":"<code>AvatarTrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class AvatarTrackingActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.\"\"\"\n\n    def __init__(\n        self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            target_speed (float): the speed of the target (svg units per second).\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._keys_pressed = set()\n        self._prev_time = time.time()\n        self._target_speed = target_speed\n\n    def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n        \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n        Returns:\n            list[TargetMoveAction]: the action\n        \"\"\"\n        current_time = time.time()\n        # this will contain the user action (KeyEvent)\n        actions = []\n        if len(self._keys_pressed) &gt; 0:\n            # compute speed based on time that has passed\n            dt = current_time - self._prev_time\n            speed = self._target_speed * dt\n            # this will be normalised when the action is executed\n            result = [0, 0]\n            # compute the movement action based on the currently pressed keys\n            for key in self._keys_pressed:\n                direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n                result[0] += direction[0]\n                result[1] += direction[1]\n            if result[0] != 0 or result[1] != 0:\n                actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n        self._prev_time = current_time\n        return actions\n\n    @attempt\n    def attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n        \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        Args:\n            user_action (KeyEvent): the users keyboard action\n\n        Returns:\n            list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n        \"\"\"\n        if user_action.key.lower() in DEFAULT_KEY_BINDING:\n            if user_action.status == KeyEvent.UP:\n                self._keys_pressed.remove(user_action.key)\n            elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n                self._keys_pressed.add(user_action.key)\n        return []  # these will be recorded by the DefaultActuator\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator.__attempt__","title":"<code>__attempt__()</code>","text":"<p>Attempt method that will attempt a <code>TargetMoveAction</code> to move the target according to the users input (if it has been provided since the last call to this method).</p> <p>Returns:</p> Type Description <code>list[TargetMoveAction]</code> <p>list[TargetMoveAction]: the action</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n    \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n    Returns:\n        list[TargetMoveAction]: the action\n    \"\"\"\n    current_time = time.time()\n    # this will contain the user action (KeyEvent)\n    actions = []\n    if len(self._keys_pressed) &gt; 0:\n        # compute speed based on time that has passed\n        dt = current_time - self._prev_time\n        speed = self._target_speed * dt\n        # this will be normalised when the action is executed\n        result = [0, 0]\n        # compute the movement action based on the currently pressed keys\n        for key in self._keys_pressed:\n            direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n            result[0] += direction[0]\n            result[1] += direction[1]\n        if result[0] != 0 or result[1] != 0:\n            actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n    self._prev_time = current_time\n    return actions\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator.__init__","title":"<code>__init__(target_speed=5.0, *args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>target_speed</code> <code>float</code> <p>the speed of the target (svg units per second).</p> <code>5.0</code> <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __init__(\n    self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n):\n    \"\"\"Constructor.\n\n    Args:\n        target_speed (float): the speed of the target (svg units per second).\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._keys_pressed = set()\n    self._prev_time = time.time()\n    self._target_speed = target_speed\n</code></pre>"},{"location":"reference/avatar/#matbii.avatar.AvatarTrackingActuator.attempt_key_event","title":"<code>attempt_key_event(user_action)</code>","text":"<p>Attempt method that takes a <code>KeyEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>KeyEvent</code> <p>the users keyboard action</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>an empty list (no action is taken by this attempt method, see <code>AvatarTrackingActuator.__attempt__</code>.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n    \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    Args:\n        user_action (KeyEvent): the users keyboard action\n\n    Returns:\n        list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n    \"\"\"\n    if user_action.key.lower() in DEFAULT_KEY_BINDING:\n        if user_action.status == KeyEvent.UP:\n            self._keys_pressed.remove(user_action.key)\n        elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n            self._keys_pressed.add(user_action.key)\n    return []  # these will be recorded by the DefaultActuator\n</code></pre>"},{"location":"reference/config/","title":"Config","text":"<p>Module containing configuration classes.</p>"},{"location":"reference/config/#matbii.config.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Matbii configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class Configuration(BaseModel, validate_assignment=True):\n    \"\"\"Matbii configuration.\"\"\"\n\n    experiment: ExperimentConfiguration = Field(default_factory=ExperimentConfiguration)\n    participant: ParticipantConfiguration = Field(\n        default_factory=ParticipantConfiguration\n    )\n    guidance: GuidanceConfiguration = Field(default_factory=GuidanceConfiguration)\n    window: WindowConfiguration = Field(default_factory=WindowConfiguration)\n    eyetracking: EyetrackingConfiguration = Field(\n        default_factory=EyetrackingConfiguration\n    )\n    logging: LoggingConfiguration = Field(default_factory=LoggingConfiguration)\n    ui: UIConfiguration = Field(default_factory=UIConfiguration)\n\n    @staticmethod\n    def from_file(\n        path: str | Path | None, context: dict[str, Any] | None = None\n    ) -&gt; \"Configuration\":\n        \"\"\"Factory that will build `Configuration` from a .json file.\n\n        Args:\n            path (str | Path | None): path to config file.\n            context (dict[str, Any] | None, optional): additional context (to override file content). Defaults to None.\n\n        Returns:\n            Configuration: resulting configuration.\n        \"\"\"\n        context = context if context else {}\n        if path:\n            path = Path(path).expanduser().resolve().as_posix()\n            LOGGER.info(f\"Using config file: {path}\")\n            with open(path) as f:\n                return Configuration.model_validate_json(f.read(), context=context)\n        else:\n            LOGGER.info(\"No config file was specified, using default configuration.\")\n            return Configuration()\n</code></pre>"},{"location":"reference/config/#matbii.config.Configuration.from_file","title":"<code>from_file(path, context=None)</code>  <code>staticmethod</code>","text":"<p>Factory that will build <code>Configuration</code> from a .json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>path to config file.</p> required <code>context</code> <code>dict[str, Any] | None</code> <p>additional context (to override file content). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Configuration</code> <code>Configuration</code> <p>resulting configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>@staticmethod\ndef from_file(\n    path: str | Path | None, context: dict[str, Any] | None = None\n) -&gt; \"Configuration\":\n    \"\"\"Factory that will build `Configuration` from a .json file.\n\n    Args:\n        path (str | Path | None): path to config file.\n        context (dict[str, Any] | None, optional): additional context (to override file content). Defaults to None.\n\n    Returns:\n        Configuration: resulting configuration.\n    \"\"\"\n    context = context if context else {}\n    if path:\n        path = Path(path).expanduser().resolve().as_posix()\n        LOGGER.info(f\"Using config file: {path}\")\n        with open(path) as f:\n            return Configuration.model_validate_json(f.read(), context=context)\n    else:\n        LOGGER.info(\"No config file was specified, using default configuration.\")\n        return Configuration()\n</code></pre>"},{"location":"reference/config/#matbii.config.ExperimentConfiguration","title":"<code>ExperimentConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Experiment Configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class ExperimentConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Experiment Configuration.\"\"\"\n\n    id: str = Field(default=None, description=\"The unique ID of this experiment.\")\n    path: str = Field(\n        default_factory=lambda: Path(\"./\").resolve().as_posix(),\n        description=\"The full path to the directory containing task configuration files, details on configuring tasks consult the [wiki](https://github.com/dicelab-rhul/matbii/wiki/Task-Configuration). If this is a relative path it is relative to the current working directory.\",\n    )\n    duration: int = Field(\n        default=-1,\n        description=\"The duration (in seconds) of this experiment (the simulation will close after this time), a negative value will leave the simulation running forever.\",\n    )\n    enable_video_recording: bool = Field(\n        default=False,\n        description=\"Whether to begin a screen recording of the experiment when the simulation starts, the video will be saved to the logging path when the experiment ends.\",\n    )\n    enable_tasks: list[str] = Field(\n        default=[\"system_monitoring\", \"resource_management\", \"tracking\"],\n        description=\"Which tasks to enable at the start of the simulation.\",\n    )\n    meta: dict = Field(\n        default={},\n        description=\"Any additional meta data you wish to associate with this experiment.\",\n    )\n\n    @field_validator(\"path\", mode=\"before\")\n    @classmethod\n    def _validate_path(cls, value: str):\n        experiment_path = Path(value).expanduser().resolve()\n        if not experiment_path.exists():\n            raise ValueError(\n                f\"Experiment path: {experiment_path.as_posix()} does not exist.\"\n            )\n        return experiment_path.as_posix()\n</code></pre>"},{"location":"reference/config/#matbii.config.EyetrackingConfiguration","title":"<code>EyetrackingConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Eyetracking Configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class EyetrackingConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Eyetracking Configuration.\"\"\"\n\n    SUPPORTED_SDKS: ClassVar[tuple[str]] = (\"tobii\",)\n\n    uri: str | None = Field(\n        default=None,\n        description=\"The eye tracker address (example: `'tet-tcp://172.28.195.1'`). If left unspecified `matbii` will attempt to find an eye tracker. For details on setting up eye tracking, consult the [wiki](https://github.com/dicelab-rhul/matbii/wiki/Eyetracking).\",\n    )\n    sdk: str = Field(\n        default=\"tobii\",\n        description=\"The eye tracking SDK to use, current options are: `['tobii']`.\",\n    )\n    enabled: bool = Field(default=False, description=\"Whether eye tracking is enabled.\")\n    moving_average_n: int = Field(\n        default=5,\n        description=\"The window size to used to smooth eye tracking coordinates.\",\n    )\n    velocity_threshold: float = Field(\n        default=0.5,\n        description=\"The threshold on gaze velocity which will determine saccades/fixations. This is defined in screen space, where the screen coordinates are normalised in the range [0,1]. **IMPORTANT NOTE:** different monitor sizes may require different values, unfortunately this is difficult to standardise without access to data on the gaze angle (which would be monitor size independent).\",\n    )\n\n    @field_validator(\"sdk\", mode=\"before\")\n    @classmethod\n    def _validate_sdk(cls, value: str):\n        if value not in EyetrackingConfiguration.SUPPORTED_SDKS:\n            raise ValueError(\n                f\"Eyetracker SDK: {value} is not supported, must be one of {EyetrackingConfiguration.SUPPORTED_SDKS}\"\n            )\n        return value\n\n    def new_eyetracking_sensor(self) -&gt; EyetrackerIOSensor | None:\n        \"\"\"Factory method for an eyetracking sensor.\n\n        Returns:\n            EyetrackerIOSensor | None: the sensor, created based on this eyetracking configuration.\n        \"\"\"\n        if self.enabled:\n            eyetracker = self.new_eyetracker()\n            return EyetrackerIOSensor(\n                eyetracker, self.velocity_threshold, self.moving_average_n\n            )\n        return None\n\n    def new_eyetracker(self) -&gt; EyetrackerBase | None:\n        \"\"\"Factory method for an eyetracker.\n\n        Returns:\n            EyetrackerBase | None: the eyetracker created based on this eyetracking configuration.\n        \"\"\"\n        if self.enabled:\n            if self.sdk == \"tobii\":\n                return self._new_tobii_eyetracker()\n            else:\n                raise ValueError(\n                    f\"Eyetracker SDK: {self.sdk} is not supported, must be one of {EyetrackingConfiguration.SUPPORTED_SDKS}\"\n                )\n        return None\n\n    def _new_tobii_eyetracker(self) -&gt; EyetrackerBase:\n        from icua.extras.eyetracking import tobii  # this may fail!\n\n        return tobii.TobiiEyetracker(uri=self.uri)\n</code></pre>"},{"location":"reference/config/#matbii.config.EyetrackingConfiguration.new_eyetracker","title":"<code>new_eyetracker()</code>","text":"<p>Factory method for an eyetracker.</p> <p>Returns:</p> Type Description <code>EyetrackerBase | None</code> <p>EyetrackerBase | None: the eyetracker created based on this eyetracking configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>def new_eyetracker(self) -&gt; EyetrackerBase | None:\n    \"\"\"Factory method for an eyetracker.\n\n    Returns:\n        EyetrackerBase | None: the eyetracker created based on this eyetracking configuration.\n    \"\"\"\n    if self.enabled:\n        if self.sdk == \"tobii\":\n            return self._new_tobii_eyetracker()\n        else:\n            raise ValueError(\n                f\"Eyetracker SDK: {self.sdk} is not supported, must be one of {EyetrackingConfiguration.SUPPORTED_SDKS}\"\n            )\n    return None\n</code></pre>"},{"location":"reference/config/#matbii.config.EyetrackingConfiguration.new_eyetracking_sensor","title":"<code>new_eyetracking_sensor()</code>","text":"<p>Factory method for an eyetracking sensor.</p> <p>Returns:</p> Type Description <code>EyetrackerIOSensor | None</code> <p>EyetrackerIOSensor | None: the sensor, created based on this eyetracking configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>def new_eyetracking_sensor(self) -&gt; EyetrackerIOSensor | None:\n    \"\"\"Factory method for an eyetracking sensor.\n\n    Returns:\n        EyetrackerIOSensor | None: the sensor, created based on this eyetracking configuration.\n    \"\"\"\n    if self.enabled:\n        eyetracker = self.new_eyetracker()\n        return EyetrackerIOSensor(\n            eyetracker, self.velocity_threshold, self.moving_average_n\n        )\n    return None\n</code></pre>"},{"location":"reference/config/#matbii.config.GuidanceConfiguration","title":"<code>GuidanceConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Guidance Configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class GuidanceConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Guidance Configuration.\"\"\"\n\n    enable: bool = Field(\n        default=True,\n        description=\"Whether to enable guidance, if this is False then no guidance agent will be created.\",\n    )\n    counter_factual: bool = Field(\n        default=False,\n        description=\"Whether to show guidance to the user, if False then guidance agent will be configured NOT to display guidance but will still take actions for logging purposes (if they support this).\",\n    )\n</code></pre>"},{"location":"reference/config/#matbii.config.LoggingConfiguration","title":"<code>LoggingConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Logging Configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class LoggingConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Logging Configuration.\"\"\"\n\n    level: str = Field(\n        default=\"INFO\",\n        description=\"The logging level to use: ['DEBUG', 'INFO', 'WARNING', 'ERROR'], this will not affect event logging.\",\n    )\n    path: str = Field(\n        default=\"./logs/\",\n        description=\"The path to the directory where log files will be written.\",\n    )\n\n    @field_validator(\"level\", mode=\"before\")\n    @classmethod\n    def _validate_level(cls, value: str):\n        return value.upper()\n</code></pre>"},{"location":"reference/config/#matbii.config.ParticipantConfiguration","title":"<code>ParticipantConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Participant Configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class ParticipantConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"Participant Configuration.\"\"\"\n\n    id: str = Field(\n        default=None,\n        description=\"The unique ID of the participant that is taking part in the experiment.\",\n    )\n    meta: dict = Field(\n        default={},\n        description=\"Any additional meta data you wish to associate with the participant.\",\n    )\n</code></pre>"},{"location":"reference/config/#matbii.config.UIConfiguration","title":"<code>UIConfiguration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>UI Configuration.</p> Source code in <code>matbii\\config\\__init__.py</code> <pre><code>class UIConfiguration(BaseModel, validate_assignment=True):\n    \"\"\"UI Configuration.\"\"\"\n\n    size: tuple[int, int] = Field(\n        default=(800, 600),\n        description=\"The width and height of the canvas used to render the tasks. This should fully encapsulate all task elements. If a task appears to be off screen, try increasing this value.\",\n    )\n    offset: tuple[int, int] = Field(\n        default=(0, 0),\n        description=\"The x and y offset used when rendering the root UI element, can be used to pad the top/left of the window.\",\n    )\n</code></pre>"},{"location":"reference/environment/","title":"Environment","text":"<p>Package defining environment related functionality.</p>"},{"location":"reference/guidance/","title":"Guidance","text":"<p>Package defining guidance related functionality.</p>"},{"location":"reference/guidance/#modules","title":"Modules","text":"<ul> <li>matbii/guidance/agent_base.py</li> <li>matbii/guidance/agent_default.py</li> <li>matbii/guidance/sensor_resource_management.py</li> <li>matbii/guidance/sensor_system_monitoring.py</li> <li>matbii/guidance/sensor_tracking.py</li> </ul>"},{"location":"reference/guidance/agent_base/","title":"Agent base","text":"<p>Module containing the base class for matbii guidance agents, see <code>GuidanceAgent</code> documentation for details.</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent","title":"<code>GuidanceAgent</code>","text":"<p>               Bases: <code>GuidanceAgent</code></p> <p>Base class for matbii guidance agents.</p> Source code in <code>matbii\\guidance\\agent_base.py</code> <pre><code>class GuidanceAgent(_GuidanceAgent):\n    \"\"\"Base class for matbii guidance agents.\"\"\"\n\n    @property\n    def mouse_at_elements(self) -&gt; list[str]:\n        \"\"\"Getter for the elements that the mouse pointer is currently over (according to this agents beliefs).\n\n        Returns:\n            List[str]: list of element ids that the mouse pointer is currently over.\n        \"\"\"\n        try:\n            return next(self.get_latest_user_input(MouseMotionEvent)).target\n        except StopIteration:\n            return []\n\n    @property\n    def mouse_position(self) -&gt; dict[str, Any]:\n        \"\"\"Getter for the user's current mouse position (according to this agents beliefs).\n\n        Returns:\n            Dict[str, Any]: dict containing the `timestamp` and mouse `position` (in svg coordinate space).\n        \"\"\"\n        try:\n            event = next(self.get_latest_user_input(MouseMotionEvent))\n            return dict(timestamp=event.timestamp, position=event.position)\n        except StopIteration:\n            return None\n\n    @property\n    def gaze_at_elements(self) -&gt; list[str]:\n        \"\"\"Getter for the elements that the user is currently gazing at (according to this agents beliefs).\n\n        Returns:\n            List[str]: list of element id's that the user is currently gazing at.\n        \"\"\"\n        try:\n            return next(self.get_latest_user_input(EyeMotionEvent)).target\n        except StopIteration:\n            return []\n\n    @property\n    def gaze_position(self) -&gt; dict[str, Any]:\n        \"\"\"Getter for the user's current gaze position (according to this agents beliefs).\n\n        Returns:\n            Dict[str, Any]: dict containing the `timestamp` and gaze `position` (in svg coordinate space).\n        \"\"\"\n        try:\n            event = next(self.get_latest_user_input(EyeMotionEvent))\n            return dict(timestamp=event.timestamp, position=event.position)\n        except StopIteration:\n            return None\n</code></pre>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.gaze_at_elements","title":"<code>gaze_at_elements: list[str]</code>  <code>property</code>","text":"<p>Getter for the elements that the user is currently gazing at (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: list of element id's that the user is currently gazing at.</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.gaze_position","title":"<code>gaze_position: dict[str, Any]</code>  <code>property</code>","text":"<p>Getter for the user's current gaze position (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: dict containing the <code>timestamp</code> and gaze <code>position</code> (in svg coordinate space).</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.mouse_at_elements","title":"<code>mouse_at_elements: list[str]</code>  <code>property</code>","text":"<p>Getter for the elements that the mouse pointer is currently over (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: list of element ids that the mouse pointer is currently over.</p>"},{"location":"reference/guidance/agent_base/#matbii.guidance.agent_base.GuidanceAgent.mouse_position","title":"<code>mouse_position: dict[str, Any]</code>  <code>property</code>","text":"<p>Getter for the user's current mouse position (according to this agents beliefs).</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: dict containing the <code>timestamp</code> and mouse <code>position</code> (in svg coordinate space).</p>"},{"location":"reference/guidance/agent_default/","title":"Agent default","text":"<p>Module contains a default implementation for a guidance agent, see <code>DefaultGuidanceAgent</code> documentation for details.</p>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent","title":"<code>DefaultGuidanceAgent</code>","text":"<p>               Bases: <code>GuidanceAgent</code></p> <p>Default implementation of a guidance agent for the matbii system.</p> <p>TODO.</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>class DefaultGuidanceAgent(GuidanceAgent):\n    \"\"\"Default implementation of a guidance agent for the matbii system.\n\n    TODO.\n\n    \"\"\"\n\n    # used to break ties when multiple tasks could be highlighted. See `break_guidance_tie` method below.\n    BREAK_TIES = (\"random\", \"longest\", \"since\")\n\n    def __init__(\n        self,\n        sensors: list[Sensor],\n        actuators: list[Actuator],\n        break_ties: Literal[\"random\", \"longest\", \"since\"] = \"random\",\n        grace_period: float = 3.0,\n        counter_factual: bool = False,\n        **kwargs: dict[str, Any],\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            sensors (list[Sensor]): list of sensors, this will typically be a list of `icua.agent.TaskAcceptabilitySensor`s. A `UserInputSensor` will always be added automatically.\n            actuators (list[Actuator]): list of actuators, this will typically contain actuators that are capable of providing visual feedback to a user, see e.g. `icua.agent.GuidanceActuator` and its concrete implementations.\n            break_ties (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.\n            grace_period (float, optional): the time to wait (seconds) before guidance may be shown for a task after the last time guidance was shown on the task. Defaults to 3.0.\n            counter_factual (bool, optional): whether guidance should be shown to the user, or whether it should just be logged.  This allows counter-factual experiments to be run, we can track when guidance would have been shown, and compare the when it was actually shown (in a different run). Defaults to False.\n            kwargs (dict[str,Any]): Additional optional keyword arguments.\n        \"\"\"\n        super().__init__(sensors, actuators, **kwargs)\n\n        # this agent is tracking the following tasks (based on the provided sensors)\n        self._tracking_tasks = [s.task_name for s in self.task_acceptability_sensors]\n        # time since tasks went into an unacceptable state\n        self._task_unacceptable_start: dict[str, float] = None\n        # time since tasks become inactive\n        self._task_inactive_start: dict[str, float] = None\n        # TODO track the time since user input (gaze) has been provided, we can trigger an error if this is too long\n        self._missing_gaze_since: float = None\n        # guidance shown on task?\n        self._guidance_on_task: str = None\n        # time since guidance was shown for each task (for grace period)\n        self._guidance_last: dict[str, float] = None\n        # method to use to break ties when more than one task meets the guidance criteria\n        self._break_ties = break_ties  # (\"random\", \"longest\", \"since\")\n        if self._break_ties not in (\"random\", \"longest\", \"since\"):\n            raise ValueError(\n                f\"Invalid argument: `break_ties` {self._break_ties} must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n            )\n        # time to wait before showing guidance again on a task (can be zero)\n        self._grace_period = grace_period  # TODO\n        if self._grace_period &lt; 0.0:\n            raise ValueError(\n                f\"Invalid argument: `grace_period` {self._grace_period} must be &gt; 0 \"\n            )\n        # whether to actually display guidance, or just trigger a guidance event\n        self._counter_factual = counter_factual  # TODO\n\n    def __initialise__(self, state: State):  # noqa\n        super().__initialise__(state)\n        # initialise task unacceptability and inactivity\n        start_time = time.time()  # not accurate but good enough\n        self._task_inactive_start = {t: start_time for t in self._tracking_tasks}\n        self._task_unacceptable_start = {t: start_time for t in self._tracking_tasks}\n        # initialise time to last guidance shown\n        self._guidance_last = {t: start_time for t in self._tracking_tasks}\n\n    def show_guidance(self, task: str):\n        \"\"\"Show guidance for a given task.\n\n        If overriding you must call super() to ensure consistent behaviour.\n\n        Args:\n            task (str): the task to show guidance for.\n        \"\"\"\n        self._guidance_on_task = task\n        for actuator in self.guidance_actuators:\n            actuator.show_guidance(task=task)\n\n    def hide_guidance(self, task: str):\n        \"\"\"Hide guidance for a given task.\n\n        If overriding you must call super() to ensure consistent behaviour.\n\n        Args:\n            task (str): the task to hide guidance for.\n        \"\"\"\n        # TODO trigger event here! this will be used in post analysis, ensure that counterfactual guidance is also a thing!\n        self._guidance_on_task = None\n        for actuator in self.guidance_actuators:\n            actuator.hide_guidance(task=task)\n        # update the last time guidance was shown for the given task (for the grace period check)\n        self._guidance_last[task] = time.time()\n\n    def __cycle__(self):  # noqa\n        super().__cycle__()\n        gaze_elements, gaze = self.mouse_at_elements, self.mouse_position\n        gaze_elements, gaze = self.gaze_at_elements, self.gaze_position\n        # TODO gaze_elements can be none? hmm\n        if gaze is None:\n            pass  # might be an issue with the eyetracker... or it may be loading up\n\n        # # TODO an option for this (its a timeout)\n        # if self._missing_gaze_since &gt; 1:\n        #     raise ValueError(\n        #         \"Guidance agent has not recieved gaze input for more than 1 second.\")\n\n        # gaze_elements, gaze = self.gaze_at_elements, self.gaze_position\n        # this is the last gaze timestamp, it should be relatively close to NOW, otherwise the eyetracker may not be functioning\n        # gaze_timestamp = gaze['timestamp']  # TODO check this...\n\n        # =================================================== #\n        # here the agent is deciding whether to show guidance\n        # it uses the same rules as icua version 1 (TODO grace period)\n        # =================================================== #\n        if self._guidance_on_task:\n            # guidance is active, should it be?\n            if self._is_task_acceptable[self._guidance_on_task]:\n                # the task is now acceptable - hide guidance for this task\n                self.hide_guidance(self._guidance_on_task)\n            if self._guidance_on_task in gaze_elements:\n                # turn off guidance, the user is looking at the task - hide guidance\n                self.hide_guidance(self._guidance_on_task)\n            else:\n                # the user is not looking at the task and its unacceptable, keep guidance on.\n                pass\n        else:\n            current_time = time.time()\n            # guidance is not active, should it be?\n            unacceptable = list(self._is_task_acceptable.items())\n            # is the task in an unacceptable state? (remove if they are acceptable)\n            unacceptable = [x[0] for x in unacceptable if not x[1]]\n            # is the user looking at the task? (remove if they are)\n            unacceptable = [x for x in unacceptable if x not in gaze_elements]\n            # is the grace period over for the task?\n            unacceptable = [\n                x\n                for x in unacceptable\n                if current_time - self._guidance_last[x] &gt; self._grace_period\n            ]\n            if len(unacceptable) &gt; 0:\n                # there are tasks in failure, decide which one to highlight\n                # break ties randomly - this could be more interesting!\n                task = self.break_guidance_tie(unacceptable, self._break_ties)\n                self.show_guidance(task)  # show guidance on the chosen task\n            else:\n                pass  # no task is in failure, no guidance should be shown.\n\n    def break_guidance_tie(\n        self, tasks: list[str], method: Literal[\"random\", \"longest\", \"since\"] = \"random\"\n    ) -&gt; str:\n        \"\"\"Break a tie on tasks that all met the criteria for displaying guiance.\n\n        Args:\n            tasks (list[str]): tasks to break the tie, one of which will be returned.\n            method (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.\n\n        Returns:\n            str: the chosen task.\n        \"\"\"\n        assert len(tasks) &gt; 0\n        if method == \"random\":\n            # randomly break the tie\n            return random.choice(tasks)\n        elif method == \"longest\":\n            return max(\n                [(x, self._task_unacceptable_start[x]) for x in tasks],\n                key=lambda x: x[1],\n            )[0]\n            # choose the one longest in failure\n        elif method == \"since\":\n            # choose the one with with the longest time since guidance was last shown\n            return max(\n                [(x, self._guidance_last[x]) for x in tasks], key=lambda x: x[1]\n            )[0]\n        else:\n            raise ValueError(\n                f\"Unknown guidance tie break method: {self._break_ties}, must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n            )\n\n    def on_acceptable(self, task: str):  # noqa\n        self._log_acceptebility(task, \"acceptable\", True)\n\n    def on_active(self, task: str):  # noqa\n        self._log_acceptebility(task, \"active\", True)\n\n    def on_unacceptable(self, task: str):  # noqa\n        # NOTE: this time is not the exact time that the task went into failure.\n        # for this we would need to track the exact events that caused the failure, this is easier said than done...\n        self._task_unacceptable_start[task] = time.time()\n        self._log_acceptebility(task, \"acceptable\", False)\n\n    def on_inactive(self, task: str):  # noqa\n        self._log_acceptebility(task, \"active\", False)\n        self._task_inactive_start[task] = time.time()\n\n    @observe([EyeMotionEvent, MouseMotionEvent])\n    def _on_motion_event(self, event: MouseMotionEvent | EyeMotionEvent):\n        \"\"\"It may be useful to the actuators to get these events.\"\"\"\n        # TODO we may need to guard against actuators executing these actions...?\n        self.attempt(event)  # manually attempt the event\n\n    @property\n    def task_acceptability_sensors(self) -&gt; list[TaskAcceptabilitySensor]:\n        \"\"\"Getter for task acceptability sensors (sensors that derive the type: `icua.agent.TaskAcceptabilitySensor`).\n\n        Returns:\n            list[TaskAcceptabilitySensor]: the sensors.\n        \"\"\"\n        return list(self.get_sensors(oftype=TaskAcceptabilitySensor))\n\n    @property\n    def guidance_actuators(self) -&gt; list[GuidanceActuator]:\n        \"\"\"Getter for guidance actuators (actuators that derive the type: `icua.agent.GuidanceActuator`).\n\n        Returns:\n            list[GuidanceActuator]: the GuidanceActuator.\n        \"\"\"\n        candidates = list(self.get_actuators(oftype=GuidanceActuator))\n        if len(candidates) == 0:\n            raise ValueError(\n                f\"Missing required actuator of type: `{GuidanceActuator.__qualname__}`\"\n            )\n        return candidates\n\n    def _log_acceptebility(self, task, z, ok):\n        info = \"task %20s %20s %s\" % (z, task, [\"\u2718\", \"\u2714\"][int(ok)])\n        LOGGER.info(info)\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.guidance_actuators","title":"<code>guidance_actuators: list[GuidanceActuator]</code>  <code>property</code>","text":"<p>Getter for guidance actuators (actuators that derive the type: <code>icua.agent.GuidanceActuator</code>).</p> <p>Returns:</p> Type Description <code>list[GuidanceActuator]</code> <p>list[GuidanceActuator]: the GuidanceActuator.</p>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.task_acceptability_sensors","title":"<code>task_acceptability_sensors: list[TaskAcceptabilitySensor]</code>  <code>property</code>","text":"<p>Getter for task acceptability sensors (sensors that derive the type: <code>icua.agent.TaskAcceptabilitySensor</code>).</p> <p>Returns:</p> Type Description <code>list[TaskAcceptabilitySensor]</code> <p>list[TaskAcceptabilitySensor]: the sensors.</p>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.__init__","title":"<code>__init__(sensors, actuators, break_ties='random', grace_period=3.0, counter_factual=False, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>sensors</code> <code>list[Sensor]</code> <p>list of sensors, this will typically be a list of <code>icua.agent.TaskAcceptabilitySensor</code>s. A <code>UserInputSensor</code> will always be added automatically.</p> required <code>actuators</code> <code>list[Actuator]</code> <p>list of actuators, this will typically contain actuators that are capable of providing visual feedback to a user, see e.g. <code>icua.agent.GuidanceActuator</code> and its concrete implementations.</p> required <code>break_ties</code> <code>Literal['random', 'longest', 'since']</code> <p>how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.</p> <code>'random'</code> <code>grace_period</code> <code>float</code> <p>the time to wait (seconds) before guidance may be shown for a task after the last time guidance was shown on the task. Defaults to 3.0.</p> <code>3.0</code> <code>counter_factual</code> <code>bool</code> <p>whether guidance should be shown to the user, or whether it should just be logged.  This allows counter-factual experiments to be run, we can track when guidance would have been shown, and compare the when it was actually shown (in a different run). Defaults to False.</p> <code>False</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>Additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def __init__(\n    self,\n    sensors: list[Sensor],\n    actuators: list[Actuator],\n    break_ties: Literal[\"random\", \"longest\", \"since\"] = \"random\",\n    grace_period: float = 3.0,\n    counter_factual: bool = False,\n    **kwargs: dict[str, Any],\n):\n    \"\"\"Constructor.\n\n    Args:\n        sensors (list[Sensor]): list of sensors, this will typically be a list of `icua.agent.TaskAcceptabilitySensor`s. A `UserInputSensor` will always be added automatically.\n        actuators (list[Actuator]): list of actuators, this will typically contain actuators that are capable of providing visual feedback to a user, see e.g. `icua.agent.GuidanceActuator` and its concrete implementations.\n        break_ties (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.\n        grace_period (float, optional): the time to wait (seconds) before guidance may be shown for a task after the last time guidance was shown on the task. Defaults to 3.0.\n        counter_factual (bool, optional): whether guidance should be shown to the user, or whether it should just be logged.  This allows counter-factual experiments to be run, we can track when guidance would have been shown, and compare the when it was actually shown (in a different run). Defaults to False.\n        kwargs (dict[str,Any]): Additional optional keyword arguments.\n    \"\"\"\n    super().__init__(sensors, actuators, **kwargs)\n\n    # this agent is tracking the following tasks (based on the provided sensors)\n    self._tracking_tasks = [s.task_name for s in self.task_acceptability_sensors]\n    # time since tasks went into an unacceptable state\n    self._task_unacceptable_start: dict[str, float] = None\n    # time since tasks become inactive\n    self._task_inactive_start: dict[str, float] = None\n    # TODO track the time since user input (gaze) has been provided, we can trigger an error if this is too long\n    self._missing_gaze_since: float = None\n    # guidance shown on task?\n    self._guidance_on_task: str = None\n    # time since guidance was shown for each task (for grace period)\n    self._guidance_last: dict[str, float] = None\n    # method to use to break ties when more than one task meets the guidance criteria\n    self._break_ties = break_ties  # (\"random\", \"longest\", \"since\")\n    if self._break_ties not in (\"random\", \"longest\", \"since\"):\n        raise ValueError(\n            f\"Invalid argument: `break_ties` {self._break_ties} must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n        )\n    # time to wait before showing guidance again on a task (can be zero)\n    self._grace_period = grace_period  # TODO\n    if self._grace_period &lt; 0.0:\n        raise ValueError(\n            f\"Invalid argument: `grace_period` {self._grace_period} must be &gt; 0 \"\n        )\n    # whether to actually display guidance, or just trigger a guidance event\n    self._counter_factual = counter_factual  # TODO\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.break_guidance_tie","title":"<code>break_guidance_tie(tasks, method='random')</code>","text":"<p>Break a tie on tasks that all met the criteria for displaying guiance.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list[str]</code> <p>tasks to break the tie, one of which will be returned.</p> required <code>method</code> <code>Literal['random', 'longest', 'since']</code> <p>how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.</p> <code>'random'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the chosen task.</p> Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def break_guidance_tie(\n    self, tasks: list[str], method: Literal[\"random\", \"longest\", \"since\"] = \"random\"\n) -&gt; str:\n    \"\"\"Break a tie on tasks that all met the criteria for displaying guiance.\n\n    Args:\n        tasks (list[str]): tasks to break the tie, one of which will be returned.\n        method (Literal[\"random\", \"longest\", \"since\"], optional): how to break ties if guidance may be shown on multiple tasks simultaneously. Defaults to \"random\". \"random\" will randomly break the tie, \"longest\" will choose the task that has been in failure for the longest, \"since\" will choose the task that has not had guidance shown for the longest.\n\n    Returns:\n        str: the chosen task.\n    \"\"\"\n    assert len(tasks) &gt; 0\n    if method == \"random\":\n        # randomly break the tie\n        return random.choice(tasks)\n    elif method == \"longest\":\n        return max(\n            [(x, self._task_unacceptable_start[x]) for x in tasks],\n            key=lambda x: x[1],\n        )[0]\n        # choose the one longest in failure\n    elif method == \"since\":\n        # choose the one with with the longest time since guidance was last shown\n        return max(\n            [(x, self._guidance_last[x]) for x in tasks], key=lambda x: x[1]\n        )[0]\n    else:\n        raise ValueError(\n            f\"Unknown guidance tie break method: {self._break_ties}, must be one of {DefaultGuidanceAgent.BREAK_TIES}\"\n        )\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.hide_guidance","title":"<code>hide_guidance(task)</code>","text":"<p>Hide guidance for a given task.</p> <p>If overriding you must call super() to ensure consistent behaviour.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>the task to hide guidance for.</p> required Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def hide_guidance(self, task: str):\n    \"\"\"Hide guidance for a given task.\n\n    If overriding you must call super() to ensure consistent behaviour.\n\n    Args:\n        task (str): the task to hide guidance for.\n    \"\"\"\n    # TODO trigger event here! this will be used in post analysis, ensure that counterfactual guidance is also a thing!\n    self._guidance_on_task = None\n    for actuator in self.guidance_actuators:\n        actuator.hide_guidance(task=task)\n    # update the last time guidance was shown for the given task (for the grace period check)\n    self._guidance_last[task] = time.time()\n</code></pre>"},{"location":"reference/guidance/agent_default/#matbii.guidance.agent_default.DefaultGuidanceAgent.show_guidance","title":"<code>show_guidance(task)</code>","text":"<p>Show guidance for a given task.</p> <p>If overriding you must call super() to ensure consistent behaviour.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>the task to show guidance for.</p> required Source code in <code>matbii\\guidance\\agent_default.py</code> <pre><code>def show_guidance(self, task: str):\n    \"\"\"Show guidance for a given task.\n\n    If overriding you must call super() to ensure consistent behaviour.\n\n    Args:\n        task (str): the task to show guidance for.\n    \"\"\"\n    self._guidance_on_task = task\n    for actuator in self.guidance_actuators:\n        actuator.show_guidance(task=task)\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/","title":"Sensor resource management","text":"<p>Module contains a guidance sensor for tracking the \"resource management\" task acceptability, see <code>ResourceManagementTaskAcceptabilitySensor</code> documentation for details.</p>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor","title":"<code>ResourceManagementTaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>Guidance sensor for the resource management task.</p> <p>This sensor tracks a number of sub-tasks:</p> <ul> <li>\"system_monitoring.tank-a\"</li> <li>\"system_monitoring.tank-b\"</li> </ul> <p>The acceptability of these sub-tasks can be checked by calling the method: <code>ResourceManagementTaskAcceptabilitySensor.is_tank_acceptable</code>.</p> <p>Otherwise follow the <code>TaskAcceptabilitySensor</code> API.</p> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>class ResourceManagementTaskAcceptabilitySensor(TaskAcceptabilitySensor):\n    \"\"\"Guidance sensor for the resource management task.\n\n    This sensor tracks a number of sub-tasks:\n\n    - \"system_monitoring.tank-a\"\n    - \"system_monitoring.tank-b\"\n\n    The acceptability of these sub-tasks can be checked by calling the method: `ResourceManagementTaskAcceptabilitySensor.is_tank_acceptable`.\n\n    Otherwise follow the `TaskAcceptabilitySensor` API.\n    \"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(TASK_ID_RESOURCE_MANAGEMENT, *args, **kwargs)\n        self._is_subtask_acceptable_map = {\n            f\"{TASK_ID_RESOURCE_MANAGEMENT}.tank-a\": partial(\n                self.is_tank_acceptable, \"a\"\n            ),\n            f\"{TASK_ID_RESOURCE_MANAGEMENT}.tank-b\": partial(\n                self.is_tank_acceptable, \"b\"\n            ),\n        }\n\n    def is_active(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        return True  # TODO\n\n    def is_acceptable(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        if task is None or task == TASK_ID_RESOURCE_MANAGEMENT:\n            return all([x() for x in self._is_subtask_acceptable_map.values()])\n        else:\n            is_acceptable = self._is_subtask_acceptable_map.get(task, None)\n            if is_acceptable is None:\n                raise KeyError(\n                    f\"Invalid subtask: {task}, doesn't exist for task {self.task_name}\"\n                )\n            else:\n                return is_acceptable()\n\n    def is_tank_acceptable(self, _id: str):\n        \"\"\"Whether the given tank is in an acceptable state.\n\n        Acceptable: the fuel level lies in the required range.\n        Unacceptable: otherwise.\n\n        Args:\n            _id (int): the id of the tank (\"a\" or \"b\")\n\n        Returns:\n            bool: True if the tank is in an acceptable state, False otherwise.\n        \"\"\"\n        tank = self.beliefs[tank_id(_id)]\n        tank_level = self.beliefs[tank_level_id(_id)]\n\n        fuel_capacity = tank[\"data-capacity\"]\n        fuel_level = tank[\"data-level\"]\n        acceptable_level = tank_level[\"data-level\"] * fuel_capacity\n        acceptable_range2 = (tank_level[\"data-range\"] * fuel_capacity) / 2\n        return (\n            fuel_level &gt;= acceptable_level - acceptable_range2\n            and fuel_level &lt;= acceptable_level + acceptable_range2\n        )\n\n    def sense(self) -&gt; list[Select]:\n        \"\"\"Generates the sense actions that are required for checking whether the resource management task is in an acceptable state.\n\n        The actions will request the following data:\n        - the current fuel level and capacity of each main tank (\"a\" and \"b\")\n        - the acceptable range of fuel for each main tank (\"a\" and \"b\")\n\n        Returns:\n            list[Select]: list of sense actions to take.\n        \"\"\"\n        # interested in the fuel levels of the main tanks in the Resource Management Task\n        tanks = [tank_id(i) for i in (\"a\", \"b\")]\n        tank_levels = [tank_level_id(i) for i in (\"a\", \"b\")]\n        tank_selects = [\n            select(\n                xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-capacity\", \"data-level\"]\n            )\n            for id in tanks\n        ]\n        tank_level_selects = [\n            select(xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-level\", \"data-range\"])\n            for id in tank_levels\n        ]\n        return [*tank_selects, *tank_level_selects]\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(TASK_ID_RESOURCE_MANAGEMENT, *args, **kwargs)\n    self._is_subtask_acceptable_map = {\n        f\"{TASK_ID_RESOURCE_MANAGEMENT}.tank-a\": partial(\n            self.is_tank_acceptable, \"a\"\n        ),\n        f\"{TASK_ID_RESOURCE_MANAGEMENT}.tank-b\": partial(\n            self.is_tank_acceptable, \"b\"\n        ),\n    }\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor.is_tank_acceptable","title":"<code>is_tank_acceptable(_id)</code>","text":"<p>Whether the given tank is in an acceptable state.</p> <p>Acceptable: the fuel level lies in the required range. Unacceptable: otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>int</code> <p>the id of the tank (\"a\" or \"b\")</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the tank is in an acceptable state, False otherwise.</p> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>def is_tank_acceptable(self, _id: str):\n    \"\"\"Whether the given tank is in an acceptable state.\n\n    Acceptable: the fuel level lies in the required range.\n    Unacceptable: otherwise.\n\n    Args:\n        _id (int): the id of the tank (\"a\" or \"b\")\n\n    Returns:\n        bool: True if the tank is in an acceptable state, False otherwise.\n    \"\"\"\n    tank = self.beliefs[tank_id(_id)]\n    tank_level = self.beliefs[tank_level_id(_id)]\n\n    fuel_capacity = tank[\"data-capacity\"]\n    fuel_level = tank[\"data-level\"]\n    acceptable_level = tank_level[\"data-level\"] * fuel_capacity\n    acceptable_range2 = (tank_level[\"data-range\"] * fuel_capacity) / 2\n    return (\n        fuel_level &gt;= acceptable_level - acceptable_range2\n        and fuel_level &lt;= acceptable_level + acceptable_range2\n    )\n</code></pre>"},{"location":"reference/guidance/sensor_resource_management/#matbii.guidance.sensor_resource_management.ResourceManagementTaskAcceptabilitySensor.sense","title":"<code>sense()</code>","text":"<p>Generates the sense actions that are required for checking whether the resource management task is in an acceptable state.</p> <p>The actions will request the following data: - the current fuel level and capacity of each main tank (\"a\" and \"b\") - the acceptable range of fuel for each main tank (\"a\" and \"b\")</p> <p>Returns:</p> Type Description <code>list[Select]</code> <p>list[Select]: list of sense actions to take.</p> Source code in <code>matbii\\guidance\\sensor_resource_management.py</code> <pre><code>def sense(self) -&gt; list[Select]:\n    \"\"\"Generates the sense actions that are required for checking whether the resource management task is in an acceptable state.\n\n    The actions will request the following data:\n    - the current fuel level and capacity of each main tank (\"a\" and \"b\")\n    - the acceptable range of fuel for each main tank (\"a\" and \"b\")\n\n    Returns:\n        list[Select]: list of sense actions to take.\n    \"\"\"\n    # interested in the fuel levels of the main tanks in the Resource Management Task\n    tanks = [tank_id(i) for i in (\"a\", \"b\")]\n    tank_levels = [tank_level_id(i) for i in (\"a\", \"b\")]\n    tank_selects = [\n        select(\n            xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-capacity\", \"data-level\"]\n        )\n        for id in tanks\n    ]\n    tank_level_selects = [\n        select(xpath=f\"//*[@id='{id}']\", attrs=[\"id\", \"data-level\", \"data-range\"])\n        for id in tank_levels\n    ]\n    return [*tank_selects, *tank_level_selects]\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/","title":"Sensor system monitoring","text":"<p>Module contains a guidance sensor for tracking the \"system monitoring\" task acceptability, see <code>SystemMonitoringTaskAcceptabilitySensor</code> documentation for details.</p>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor","title":"<code>SystemMonitoringTaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>Guidance sensor for the system monitoring task.</p> <p>This sensor tracks a number of sub-tasks:</p> <ul> <li>\"system_monitoring.light-1\"</li> <li>\"system_monitoring.light-2\"</li> <li>\"system_monitoring.slider-1\"</li> <li>\"system_monitoring.slider-2\"</li> <li>\"system_monitoring.slider-3\"</li> <li>\"system_monitoring.slider-4\"</li> </ul> <p>The acceptability of these sub-tasks can be checked by calling the methods: <code>SystemMonitoringTaskAcceptabilitySensor.is_light_acceptable</code>, <code>SystemMonitoringTaskAcceptabilitySensor.is_slider_acceptable</code>.</p> <p>Otherwise follow the <code>TaskAcceptabilitySensor</code> API.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>class SystemMonitoringTaskAcceptabilitySensor(TaskAcceptabilitySensor):\n    \"\"\"Guidance sensor for the system monitoring task.\n\n    This sensor tracks a number of sub-tasks:\n\n    - \"system_monitoring.light-1\"\n    - \"system_monitoring.light-2\"\n    - \"system_monitoring.slider-1\"\n    - \"system_monitoring.slider-2\"\n    - \"system_monitoring.slider-3\"\n    - \"system_monitoring.slider-4\"\n\n    The acceptability of these sub-tasks can be checked by calling the methods: `SystemMonitoringTaskAcceptabilitySensor.is_light_acceptable`, `SystemMonitoringTaskAcceptabilitySensor.is_slider_acceptable`.\n\n    Otherwise follow the `TaskAcceptabilitySensor` API.\n    \"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(TASK_ID_SYSTEM_MONITORING, *args, **kwargs)\n        self._is_subtask_acceptable_map = {\n            f\"{TASK_ID_SYSTEM_MONITORING}.light-1\": partial(\n                self.is_light_acceptable, 1\n            ),\n            f\"{TASK_ID_SYSTEM_MONITORING}.light-2\": partial(\n                self.is_light_acceptable, 2\n            ),\n            f\"{TASK_ID_SYSTEM_MONITORING}.slider-1\": partial(\n                self.is_slider_acceptable, 1\n            ),\n            f\"{TASK_ID_SYSTEM_MONITORING}.slider-2\": partial(\n                self.is_slider_acceptable, 2\n            ),\n            f\"{TASK_ID_SYSTEM_MONITORING}.slider-3\": partial(\n                self.is_slider_acceptable, 3\n            ),\n            f\"{TASK_ID_SYSTEM_MONITORING}.slider-4\": partial(\n                self.is_slider_acceptable, 4\n            ),\n        }\n\n    def is_active(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        return True  # TODO\n\n    def is_acceptable(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        if task is None or task == TASK_ID_SYSTEM_MONITORING:\n            return all([x() for x in self._is_subtask_acceptable_map.values()])\n        else:\n            is_acceptable = self._is_subtask_acceptable_map.get(task, None)\n            if is_acceptable is None:\n                raise KeyError(\n                    f\"Invalid subtask: {task}, doesn't exist for task {self.task_name}\"\n                )\n            else:\n                return is_acceptable()\n\n    def is_slider_acceptable(self, _id: int) -&gt; bool:\n        \"\"\"Whether the given slider is in an acceptable state.\n\n        Acceptable: the slider is at the central position.\n        Unacceptable: otherwise.\n\n        Args:\n            _id (int): the id of the slider (1,2,3 or 4)\n\n        Returns:\n            bool: True if the slider is in an acceptable state, False otherwise.\n        \"\"\"\n        # sliders should be at the center position to be acceptable\n        state = self.beliefs[slider_id(_id)][\"data-state\"]\n        acceptable_state = self.beliefs[slider_incs_id(_id)][\"incs\"] // 2 + 1\n        return state == acceptable_state\n\n    def is_light_acceptable(self, _id: int):\n        \"\"\"Whether the given light is in an acceptable state.\n\n        Acceptable: light-1 is on, light-2 is off.\n        Unacceptable: otherwise.\n\n        Args:\n            _id (int): the id of the light (1 or 2)\n\n        Returns:\n            bool: True if the light is in an acceptable state, False otherwise.\n        \"\"\"\n        return [self._is_light1_acceptable, self._is_light2_acceptable][_id - 1]()\n\n    def _is_light1_acceptable(self):\n        # light 1 should be on\n        return self.beliefs[light_id(1)][\"data-state\"] == SetLightAction.ON\n\n    def _is_light2_acceptable(self):\n        # light 2 should be off\n        return self.beliefs[light_id(2)][\"data-state\"] == SetLightAction.OFF\n\n    def sense(self) -&gt; list[Select]:\n        \"\"\"Generates the sense actions that are required for checking whether the system monitoring task is in an acceptable state.\n\n        The actions will request the following data:\n        - the state of each light element.\n        - the state of each slider element.\n        - the number of increments in each slider element.\n\n        Returns:\n            list[Select]: list of sense actions to take.\n        \"\"\"\n        lights = [f\"//*[@id='{light_id(i)}']\" for i in (1, 2)]\n        sliders = [f\"//*[@id='{slider_id(i)}']\" for i in (1, 2, 3, 4)]\n        slider_incs = [f\"//*[@id='{slider_incs_id(i)}']\" for i in (1, 2, 3, 4)]\n\n        lights = [select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in lights]\n        sliders = [select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in sliders]\n        slider_incs = [\n            select(xpath=xpath, attrs=[\"id\", \"incs\"]) for xpath in slider_incs\n        ]\n        return [*lights, *sliders, *slider_incs]\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(TASK_ID_SYSTEM_MONITORING, *args, **kwargs)\n    self._is_subtask_acceptable_map = {\n        f\"{TASK_ID_SYSTEM_MONITORING}.light-1\": partial(\n            self.is_light_acceptable, 1\n        ),\n        f\"{TASK_ID_SYSTEM_MONITORING}.light-2\": partial(\n            self.is_light_acceptable, 2\n        ),\n        f\"{TASK_ID_SYSTEM_MONITORING}.slider-1\": partial(\n            self.is_slider_acceptable, 1\n        ),\n        f\"{TASK_ID_SYSTEM_MONITORING}.slider-2\": partial(\n            self.is_slider_acceptable, 2\n        ),\n        f\"{TASK_ID_SYSTEM_MONITORING}.slider-3\": partial(\n            self.is_slider_acceptable, 3\n        ),\n        f\"{TASK_ID_SYSTEM_MONITORING}.slider-4\": partial(\n            self.is_slider_acceptable, 4\n        ),\n    }\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.is_light_acceptable","title":"<code>is_light_acceptable(_id)</code>","text":"<p>Whether the given light is in an acceptable state.</p> <p>Acceptable: light-1 is on, light-2 is off. Unacceptable: otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>int</code> <p>the id of the light (1 or 2)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the light is in an acceptable state, False otherwise.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def is_light_acceptable(self, _id: int):\n    \"\"\"Whether the given light is in an acceptable state.\n\n    Acceptable: light-1 is on, light-2 is off.\n    Unacceptable: otherwise.\n\n    Args:\n        _id (int): the id of the light (1 or 2)\n\n    Returns:\n        bool: True if the light is in an acceptable state, False otherwise.\n    \"\"\"\n    return [self._is_light1_acceptable, self._is_light2_acceptable][_id - 1]()\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.is_slider_acceptable","title":"<code>is_slider_acceptable(_id)</code>","text":"<p>Whether the given slider is in an acceptable state.</p> <p>Acceptable: the slider is at the central position. Unacceptable: otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>int</code> <p>the id of the slider (1,2,3 or 4)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the slider is in an acceptable state, False otherwise.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def is_slider_acceptable(self, _id: int) -&gt; bool:\n    \"\"\"Whether the given slider is in an acceptable state.\n\n    Acceptable: the slider is at the central position.\n    Unacceptable: otherwise.\n\n    Args:\n        _id (int): the id of the slider (1,2,3 or 4)\n\n    Returns:\n        bool: True if the slider is in an acceptable state, False otherwise.\n    \"\"\"\n    # sliders should be at the center position to be acceptable\n    state = self.beliefs[slider_id(_id)][\"data-state\"]\n    acceptable_state = self.beliefs[slider_incs_id(_id)][\"incs\"] // 2 + 1\n    return state == acceptable_state\n</code></pre>"},{"location":"reference/guidance/sensor_system_monitoring/#matbii.guidance.sensor_system_monitoring.SystemMonitoringTaskAcceptabilitySensor.sense","title":"<code>sense()</code>","text":"<p>Generates the sense actions that are required for checking whether the system monitoring task is in an acceptable state.</p> <p>The actions will request the following data: - the state of each light element. - the state of each slider element. - the number of increments in each slider element.</p> <p>Returns:</p> Type Description <code>list[Select]</code> <p>list[Select]: list of sense actions to take.</p> Source code in <code>matbii\\guidance\\sensor_system_monitoring.py</code> <pre><code>def sense(self) -&gt; list[Select]:\n    \"\"\"Generates the sense actions that are required for checking whether the system monitoring task is in an acceptable state.\n\n    The actions will request the following data:\n    - the state of each light element.\n    - the state of each slider element.\n    - the number of increments in each slider element.\n\n    Returns:\n        list[Select]: list of sense actions to take.\n    \"\"\"\n    lights = [f\"//*[@id='{light_id(i)}']\" for i in (1, 2)]\n    sliders = [f\"//*[@id='{slider_id(i)}']\" for i in (1, 2, 3, 4)]\n    slider_incs = [f\"//*[@id='{slider_incs_id(i)}']\" for i in (1, 2, 3, 4)]\n\n    lights = [select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in lights]\n    sliders = [select(xpath=xpath, attrs=[\"id\", \"data-state\"]) for xpath in sliders]\n    slider_incs = [\n        select(xpath=xpath, attrs=[\"id\", \"incs\"]) for xpath in slider_incs\n    ]\n    return [*lights, *sliders, *slider_incs]\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/","title":"Sensor tracking","text":"<p>Module contains a guidance sensor for tracking the \"tracking\" task acceptability, see <code>TrackingTaskAcceptabilitySensor</code> documentation for details.</p>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor","title":"<code>TrackingTaskAcceptabilitySensor</code>","text":"<p>               Bases: <code>TaskAcceptabilitySensor</code></p> <p>Guidance sensor for the tracking task.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>class TrackingTaskAcceptabilitySensor(TaskAcceptabilitySensor):\n    \"\"\"Guidance sensor for the tracking task.\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(TASK_ID_TRACKING, *args, **kwargs)\n\n    def is_active(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        return True  # TODO\n\n    def is_acceptable(self, task: str = None, **kwargs: dict[str, Any]) -&gt; bool:  # noqa\n        if task is None or task == TASK_ID_TRACKING:\n            return self.is_tracking_acceptable()\n        else:\n            raise KeyError(\n                f\"Invalid subtask: {task}, doesn't exist for task {self.task_name}\"\n            )\n\n    def is_tracking_acceptable(self) -&gt; bool:\n        \"\"\"Determines whether the tracking task is in an acceptable state.\n\n        Acceptable: \"target\" is within the central box of the task.\n        Unacceptable: otherwise.\n\n        Raises:\n            ValueError: if there is missing observational data about the task - this may mean the task is not active.\n\n        Returns:\n            bool: whether the task is in an acceptable state.\n        \"\"\"\n        target = self.beliefs.get(tracking_target_id(), None)\n        box = self.beliefs.get(tracking_box_id(), None)\n        if target is None or box is None:\n            raise ValueError(\n                f\"Failed to determine acceptability of task: '{TASK_ID_TRACKING}'.\\n-- Missing beliefs for elements: '{tracking_target_id()}' and/or '{tracking_box_id()}'\"\n            )\n        target_top_left = (target[\"x\"], target[\"y\"])\n        target_size = (target[\"width\"], target[\"height\"])\n        box_top_left = (box[\"x\"], box[\"y\"])\n        box_bottom_right = (\n            box_top_left[0] + box[\"width\"],\n            box_top_left[1] + box[\"height\"],\n        )\n        target_center = (\n            target_top_left[0] + target_size[0] / 2,\n            target_top_left[1] + target_size[1] / 2,\n        )\n        return TrackingTaskAcceptabilitySensor.is_point_in_rectangle(\n            target_center, box_top_left, box_bottom_right\n        )\n\n    @staticmethod\n    def is_point_in_rectangle(\n        point: tuple[float, float],\n        rect_min: tuple[float, float],\n        rect_max: tuple[float, float],\n    ) -&gt; bool:\n        \"\"\"Checks wether the given `point` is within the rectangle as specified by the top left and bottom right coordinate.\n\n        Args:\n            point (tuple[float, float]): point to check.\n            rect_min (tuple[float,float]): top left.\n            rect_max (tuple[float,float]): bottom right.\n\n        Returns:\n            bool: whether the point is in the rectangle.\n        \"\"\"\n        px, py = point\n        min_x, min_y = rect_min\n        max_x, max_y = rect_max\n        return min_x &lt;= px &lt;= max_x and min_y &lt;= py &lt;= max_y\n\n    def sense(self) -&gt; list[Select]:\n        \"\"\"Generates the sense actions that are required for checking whether the tracking task is in an acceptable state.\n\n        The actions will request the following data:\n        - the bounds of the target element.\n        - the bounds of the central box of the tracking task.\n\n        Returns:\n            list[Select]: list of sense actions to take.\n        \"\"\"\n        return [\n            select(\n                xpath=f\"//*[@id='{tracking_target_id()}']\",\n                attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n            ),\n            select(\n                xpath=f\"//*[@id='{tracking_box_id()}']\",\n                attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n            ),\n        ]\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(TASK_ID_TRACKING, *args, **kwargs)\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.is_point_in_rectangle","title":"<code>is_point_in_rectangle(point, rect_min, rect_max)</code>  <code>staticmethod</code>","text":"<p>Checks wether the given <code>point</code> is within the rectangle as specified by the top left and bottom right coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple[float, float]</code> <p>point to check.</p> required <code>rect_min</code> <code>tuple[float, float]</code> <p>top left.</p> required <code>rect_max</code> <code>tuple[float, float]</code> <p>bottom right.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the point is in the rectangle.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>@staticmethod\ndef is_point_in_rectangle(\n    point: tuple[float, float],\n    rect_min: tuple[float, float],\n    rect_max: tuple[float, float],\n) -&gt; bool:\n    \"\"\"Checks wether the given `point` is within the rectangle as specified by the top left and bottom right coordinate.\n\n    Args:\n        point (tuple[float, float]): point to check.\n        rect_min (tuple[float,float]): top left.\n        rect_max (tuple[float,float]): bottom right.\n\n    Returns:\n        bool: whether the point is in the rectangle.\n    \"\"\"\n    px, py = point\n    min_x, min_y = rect_min\n    max_x, max_y = rect_max\n    return min_x &lt;= px &lt;= max_x and min_y &lt;= py &lt;= max_y\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.is_tracking_acceptable","title":"<code>is_tracking_acceptable()</code>","text":"<p>Determines whether the tracking task is in an acceptable state.</p> <p>Acceptable: \"target\" is within the central box of the task. Unacceptable: otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if there is missing observational data about the task - this may mean the task is not active.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the task is in an acceptable state.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def is_tracking_acceptable(self) -&gt; bool:\n    \"\"\"Determines whether the tracking task is in an acceptable state.\n\n    Acceptable: \"target\" is within the central box of the task.\n    Unacceptable: otherwise.\n\n    Raises:\n        ValueError: if there is missing observational data about the task - this may mean the task is not active.\n\n    Returns:\n        bool: whether the task is in an acceptable state.\n    \"\"\"\n    target = self.beliefs.get(tracking_target_id(), None)\n    box = self.beliefs.get(tracking_box_id(), None)\n    if target is None or box is None:\n        raise ValueError(\n            f\"Failed to determine acceptability of task: '{TASK_ID_TRACKING}'.\\n-- Missing beliefs for elements: '{tracking_target_id()}' and/or '{tracking_box_id()}'\"\n        )\n    target_top_left = (target[\"x\"], target[\"y\"])\n    target_size = (target[\"width\"], target[\"height\"])\n    box_top_left = (box[\"x\"], box[\"y\"])\n    box_bottom_right = (\n        box_top_left[0] + box[\"width\"],\n        box_top_left[1] + box[\"height\"],\n    )\n    target_center = (\n        target_top_left[0] + target_size[0] / 2,\n        target_top_left[1] + target_size[1] / 2,\n    )\n    return TrackingTaskAcceptabilitySensor.is_point_in_rectangle(\n        target_center, box_top_left, box_bottom_right\n    )\n</code></pre>"},{"location":"reference/guidance/sensor_tracking/#matbii.guidance.sensor_tracking.TrackingTaskAcceptabilitySensor.sense","title":"<code>sense()</code>","text":"<p>Generates the sense actions that are required for checking whether the tracking task is in an acceptable state.</p> <p>The actions will request the following data: - the bounds of the target element. - the bounds of the central box of the tracking task.</p> <p>Returns:</p> Type Description <code>list[Select]</code> <p>list[Select]: list of sense actions to take.</p> Source code in <code>matbii\\guidance\\sensor_tracking.py</code> <pre><code>def sense(self) -&gt; list[Select]:\n    \"\"\"Generates the sense actions that are required for checking whether the tracking task is in an acceptable state.\n\n    The actions will request the following data:\n    - the bounds of the target element.\n    - the bounds of the central box of the tracking task.\n\n    Returns:\n        list[Select]: list of sense actions to take.\n    \"\"\"\n    return [\n        select(\n            xpath=f\"//*[@id='{tracking_target_id()}']\",\n            attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n        ),\n        select(\n            xpath=f\"//*[@id='{tracking_box_id()}']\",\n            attrs=[\"id\", \"x\", \"y\", \"width\", \"height\"],\n        ),\n    ]\n</code></pre>"},{"location":"reference/tasks/","title":"Tasks","text":"<p>Package defining each of the matbii tasks.</p> Tasks <ul> <li>tracking</li> <li>system monitoring</li> <li>resource management</li> </ul>"},{"location":"reference/tasks/#packages","title":"Packages","text":"<ul> <li>matbii/tasks/resource_management</li> <li>matbii/tasks/system_monitoring</li> <li>matbii/tasks/tracking</li> </ul>"},{"location":"reference/tasks/resource_management/","title":"Resource management","text":"<p>Package that defines the matbii resource management task.</p>"},{"location":"reference/tasks/resource_management/#modules","title":"Modules","text":"<ul> <li>matbii/tasks/resource_management/resource_management.py</li> </ul>"},{"location":"reference/tasks/resource_management/resource_management/","title":"Resource management","text":"<p>Module that implements the resource management task.</p> This files contains <ul> <li>avatar actuator: <code>AvatarResourceManagementActuator</code></li> <li>agent actuator: <code>ResourceManagementActuator</code></li> <li>actions: [<code>SetPumpAction</code>, <code>TogglePumpAction</code>, <code>TogglePumpFailureAction</code>, <code>PumpFuelAction</code>, <code>BurnFuelAction</code>]</li> </ul>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator","title":"<code>AvatarResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class AvatarResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the resource management task is enabled. It allows the user to control the pumps in this task..\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_pump_targets = partial(\n            AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[TogglePumpAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        # always include the user action as it needs to be logged\n        actions = []\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_pump_actions(user_action))\n        return actions\n\n    def _get_pump_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"TogglePumpAction\"]:\n        targets = self._get_pump_targets(user_action.target)\n        return [TogglePumpAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_pump_targets = partial(\n        AvatarResourceManagementActuator.get_click_targets, r\"pump-([a-z]+)-button\"\n    )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt a <code>TogglePumpAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>TogglePumpAction</code>: toggle the pump on-&gt;off or off-&gt;on.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[TogglePumpAction]</code> <p>list[TogglePumpAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[\"TogglePumpAction\"]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt a `TogglePumpAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `TogglePumpAction`: toggle the pump on-&gt;off or off-&gt;on.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[TogglePumpAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    # always include the user action as it needs to be logged\n    actions = []\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_pump_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.AvatarResourceManagementActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.BurnFuelAction","title":"<code>BurnFuelAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will burn fuel in one of the main tanks (tank id = \"a\", \"b\" or \"*\" which indicates both tanks).</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class BurnFuelAction(XMLUpdateQuery):\n    \"\"\"Action class that will burn fuel in one of the main tanks (tank id = \"a\", \"b\" or \"*\" which indicates both tanks).\"\"\"\n\n    target: str\n    burn: float\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value: int | str) -&gt; str:\n        if isinstance(value, int):\n            value = TANK_MAIN_IDS[value]\n        if isinstance(value, str):\n            if value in TANK_MAIN_IDS + [ALL]:\n                return value\n        raise ValueError(\n            f\"Invalid tank {value}, must be one of {TANK_MAIN_IDS + [ALL]}\"\n        )\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        targets = self._get_targets()\n        for target in targets:\n            values = _get_tank_data(xml_state, target)\n            if values[\"data-level\"] == 0:\n                continue  # fuel is already 0, no fuel to burn\n            new_level = max(values[\"data-level\"] - self.burn, 0)\n            _update_tank_level(xml_state, target, values, new_level)\n\n    def _get_targets(self) -&gt; list[str]:\n        if self.target != ALL:\n            targets = [self.target]\n        else:\n            targets = TANK_MAIN_IDS\n        return targets\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.PumpAction","title":"<code>PumpAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Base class for pump related actions.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class PumpAction(XMLUpdateQuery):\n    \"\"\"Base class for pump related actions.\"\"\"\n\n    target: str\n\n    OFF: ClassVar[int] = 0\n    ON: ClassVar[int] = 1\n    FAILURE: ClassVar[int] = 2\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value: str | int):\n        if isinstance(value, int):\n            value = PUMP_IDS[value]\n        if value not in PUMP_IDS:\n            raise ValueError(\n                f\"{SetPumpAction.__name__} `target` {value} must be one of {PUMP_IDS}\"\n            )\n        return value\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.PumpFuelAction","title":"<code>PumpFuelAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class that will pump fuel from one tank to another.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class PumpFuelAction(PumpAction):\n    \"\"\"Action class that will pump fuel from one tank to another.\"\"\"\n\n    flow: float\n    XPATH_PUMP: ClassVar[str] = \"//svg:rect[@id='pump-%s-button']\"\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        if self.is_pump_on(xml_state, self.target):\n            id_from = self.target[0]\n            id_to = self.target[1]\n\n            _from = _get_tank_data(xml_state, id_from)\n            if _from[\"data-level\"] &lt;= 0:\n                return  # there is no fuel to transfer\n            _to = _get_tank_data(xml_state, id_to)\n            remain = _to[\"data-capacity\"] - _to[\"data-level\"]\n            if remain &lt;= 0:\n                return  # the tank is full\n\n            # compute flow value and new levels\n            # TODO potential weird bug here if _from[\"data-level\"] is lower than flow for an infinite tank\n            flow = min(_from[\"data-level\"], remain, self.flow)\n            new_to_level = _to[\"data-level\"] + flow\n            _update_tank_level(xml_state, id_to, _to, new_to_level)\n            if id_from not in TANK_INF_IDS:\n                # \"from\" tank is a normal tank, fuel should be removed\n                new_from_level = _from[\"data-level\"] - flow\n                _update_tank_level(xml_state, id_from, _from, new_from_level)\n\n    def is_pump_on(self, xml_state: XMLState, target: str) -&gt; bool:\n        \"\"\"Is the given pump current in the \"on\" state?\n\n        Args:\n            xml_state (XMLState): environment state.\n            target (str): target pump.\n\n        Returns:\n            bool: whether the pump is on.\n        \"\"\"\n        xpath = PumpFuelAction.XPATH_PUMP % target\n        data_state = xml_state.select(select(xpath=xpath, attrs=[\"data-state\"]))[0][\n            \"data-state\"\n        ]\n        return data_state == PumpAction.ON\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.PumpFuelAction.is_pump_on","title":"<code>is_pump_on(xml_state, target)</code>","text":"<p>Is the given pump current in the \"on\" state?</p> <p>Parameters:</p> Name Type Description Default <code>xml_state</code> <code>XMLState</code> <p>environment state.</p> required <code>target</code> <code>str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the pump is on.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>def is_pump_on(self, xml_state: XMLState, target: str) -&gt; bool:\n    \"\"\"Is the given pump current in the \"on\" state?\n\n    Args:\n        xml_state (XMLState): environment state.\n        target (str): target pump.\n\n    Returns:\n        bool: whether the pump is on.\n    \"\"\"\n    xpath = PumpFuelAction.XPATH_PUMP % target\n    data_state = xml_state.select(select(xpath=xpath, attrs=[\"data-state\"]))[0][\n        \"data-state\"\n    ]\n    return data_state == PumpAction.ON\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator","title":"<code>ResourceManagementActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the resource management task.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class ResourceManagementActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the resource management task.\"\"\"\n\n    @attempt\n    def burn_fuel(\n        self,\n        target: int | str,\n        burn: float,\n    ) -&gt; \"BurnFuelAction\":\n        \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n        Args:\n            target (int | Literal[\"a\", \"b\"]): target tank\n            burn (float): amount of fuel to burn.\n\n        Returns:\n            BurnFuelAction: the action\n        \"\"\"\n        return BurnFuelAction(target=target, burn=burn)\n\n    @attempt\n    def pump_fuel(\n        self,\n        target: int | str,\n        flow: float,\n    ) -&gt; \"PumpFuelAction\":\n        \"\"\"Pumps the given amount of fuel via the given pump.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n            flow (float): amount of fuel to pump.\n\n        Returns:\n            PumpFuelAction: the action\n        \"\"\"\n        return PumpFuelAction(target=target, flow=flow)\n\n    @attempt\n    def toggle_pump_failure(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpFailureAction\":\n        \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpFailureAction(target=target)\n\n    @attempt\n    def toggle_pump(\n        self,\n        target: int | str,\n    ) -&gt; \"TogglePumpAction\":\n        \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n        Returns:\n            TogglePumpFailureAction: the action\n        \"\"\"\n        return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.burn_fuel","title":"<code>burn_fuel(target, burn)</code>","text":"<p>Burns a given amount of fuel in the <code>target</code> tank, if the tank is empty this has no effect.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['a', 'b']</code> <p>target tank</p> required <code>burn</code> <code>float</code> <p>amount of fuel to burn.</p> required <p>Returns:</p> Name Type Description <code>BurnFuelAction</code> <code>BurnFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef burn_fuel(\n    self,\n    target: int | str,\n    burn: float,\n) -&gt; \"BurnFuelAction\":\n    \"\"\"Burns a given amount of fuel in the `target` tank, if the tank is empty this has no effect.\n\n    Args:\n        target (int | Literal[\"a\", \"b\"]): target tank\n        burn (float): amount of fuel to burn.\n\n    Returns:\n        BurnFuelAction: the action\n    \"\"\"\n    return BurnFuelAction(target=target, burn=burn)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.pump_fuel","title":"<code>pump_fuel(target, flow)</code>","text":"<p>Pumps the given amount of fuel via the given pump.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump (this will determine which tanks are pumped to/from).</p> required <code>flow</code> <code>float</code> <p>amount of fuel to pump.</p> required <p>Returns:</p> Name Type Description <code>PumpFuelAction</code> <code>PumpFuelAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef pump_fuel(\n    self,\n    target: int | str,\n    flow: float,\n) -&gt; \"PumpFuelAction\":\n    \"\"\"Pumps the given amount of fuel via the given pump.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump (this will determine which tanks are pumped to/from).\n        flow (float): amount of fuel to pump.\n\n    Returns:\n        PumpFuelAction: the action\n    \"\"\"\n    return PumpFuelAction(target=target, flow=flow)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.toggle_pump","title":"<code>toggle_pump(target)</code>","text":"<p>Toggle pump state (on -&gt; off, off -&gt; on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpAction\":\n    \"\"\"Toggle pump state (on -&gt; off, off -&gt; on).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.ResourceManagementActuator.toggle_pump_failure","title":"<code>toggle_pump_failure(target)</code>","text":"<p>Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpFailureAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@attempt\ndef toggle_pump_failure(\n    self,\n    target: int | str,\n) -&gt; \"TogglePumpFailureAction\":\n    \"\"\"Toggle a pump failure (on/off -&gt; failure, failure -&gt; off).\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump.\n\n    Returns:\n        TogglePumpFailureAction: the action\n    \"\"\"\n    return TogglePumpFailureAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction","title":"<code>SetPumpAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class for setting the state of a pump. Pumps states are off=0, on=1, failure=2.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class SetPumpAction(PumpAction):\n    \"\"\"Action class for setting the state of a pump. Pumps states are off=0, on=1, failure=2.\"\"\"\n\n    state: int\n\n    @field_validator(\"state\", mode=\"before\")\n    @classmethod\n    def _validate_state(cls, value: str | int):\n        if isinstance(value, str):\n            value = SetPumpAction.coerce_pump_state(value)\n        if value not in (PumpAction.OFF, PumpAction.ON, PumpAction.FAILURE):\n            raise ValueError(\n                f\"Invalid state `{value}` must be one of {[PumpAction.OFF, PumpAction.ON, PumpAction.FAILURE]}\"\n            )\n        return value\n\n    @staticmethod\n    def coerce_pump_state(value: int | str) -&gt; int:\n        \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1, \"failure\" -&gt; 2.\n\n        Args:\n            value (str | int): the value to coerce.\n\n        Raises:\n            ValueError: if the given state cannot be coerced.\n\n        Returns:\n            int: the integer state.\n        \"\"\"\n        if isinstance(value, int):\n            return value\n        if value == \"on\":\n            return PumpAction.ON\n        elif value == \"off\":\n            return PumpAction.OFF\n        elif value == \"failure\":\n            return PumpAction.FAILURE\n        else:\n            raise ValueError(\n                f\"Invalid state `{value}` must be one of ['on', 'off', 'failure']\"\n            )\n\n    @staticmethod\n    def new_on(target: int | str) -&gt; \"SetPumpAction\":\n        \"\"\"Factory method that returns an action that will turn the given pump on.\n\n        Args:\n            target (int | str): target pump.\n\n        Returns:\n            SetPumpAction: the action\n        \"\"\"\n        return SetPumpAction(target=target, state=PumpAction.ON)\n\n    @staticmethod\n    def new_off(target: int | str) -&gt; \"SetPumpAction\":\n        \"\"\"Factory method that returns an action that will turn the given pump off.\n\n        Args:\n            target (int | str): target pump.\n\n        Returns:\n            SetPumpAction: the action\n        \"\"\"\n        return SetPumpAction(target=target, state=PumpAction.OFF)\n\n    @staticmethod\n    def new_failure(target: int | str) -&gt; \"SetPumpAction\":\n        \"\"\"Factory function that returns an action that will make the pump fail.\n\n        Args:\n            target (int | str): target pump.\n\n        Returns:\n            SetPumpAction: the action\n        \"\"\"\n        return SetPumpAction(target=target, state=PumpAction.FAILURE)\n\n    def __execute__(self, state: XMLState):  # noqa\n        return state.update(\n            update(\n                xpath=f\"//*[@id='pump-{self.target}-button']\",\n                attrs={\n                    \"data-state\": str(self.state),\n                    \"fill\": Expr(\"{data-colors}[{state}]\", state=self.state),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.coerce_pump_state","title":"<code>coerce_pump_state(value)</code>  <code>staticmethod</code>","text":"<p>Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1, \"failure\" -&gt; 2.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int</code> <p>the value to coerce.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the given state cannot be coerced.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the integer state.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef coerce_pump_state(value: int | str) -&gt; int:\n    \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1, \"failure\" -&gt; 2.\n\n    Args:\n        value (str | int): the value to coerce.\n\n    Raises:\n        ValueError: if the given state cannot be coerced.\n\n    Returns:\n        int: the integer state.\n    \"\"\"\n    if isinstance(value, int):\n        return value\n    if value == \"on\":\n        return PumpAction.ON\n    elif value == \"off\":\n        return PumpAction.OFF\n    elif value == \"failure\":\n        return PumpAction.FAILURE\n    else:\n        raise ValueError(\n            f\"Invalid state `{value}` must be one of ['on', 'off', 'failure']\"\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.new_failure","title":"<code>new_failure(target)</code>  <code>staticmethod</code>","text":"<p>Factory function that returns an action that will make the pump fail.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>SetPumpAction</code> <code>SetPumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new_failure(target: int | str) -&gt; \"SetPumpAction\":\n    \"\"\"Factory function that returns an action that will make the pump fail.\n\n    Args:\n        target (int | str): target pump.\n\n    Returns:\n        SetPumpAction: the action\n    \"\"\"\n    return SetPumpAction(target=target, state=PumpAction.FAILURE)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.new_off","title":"<code>new_off(target)</code>  <code>staticmethod</code>","text":"<p>Factory method that returns an action that will turn the given pump off.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>SetPumpAction</code> <code>SetPumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new_off(target: int | str) -&gt; \"SetPumpAction\":\n    \"\"\"Factory method that returns an action that will turn the given pump off.\n\n    Args:\n        target (int | str): target pump.\n\n    Returns:\n        SetPumpAction: the action\n    \"\"\"\n    return SetPumpAction(target=target, state=PumpAction.OFF)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.SetPumpAction.new_on","title":"<code>new_on(target)</code>  <code>staticmethod</code>","text":"<p>Factory method that returns an action that will turn the given pump on.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | str</code> <p>target pump.</p> required <p>Returns:</p> Name Type Description <code>SetPumpAction</code> <code>SetPumpAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new_on(target: int | str) -&gt; \"SetPumpAction\":\n    \"\"\"Factory method that returns an action that will turn the given pump on.\n\n    Args:\n        target (int | str): target pump.\n\n    Returns:\n        SetPumpAction: the action\n    \"\"\"\n    return SetPumpAction(target=target, state=PumpAction.ON)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpAction","title":"<code>TogglePumpAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class that will toggle the pump on -&gt; off, off -&gt; on.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class TogglePumpAction(PumpAction):\n    \"\"\"Action class that will toggle the pump on -&gt; off, off -&gt; on.\"\"\"\n\n    @staticmethod\n    def new(\n        target: int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"],\n    ) -&gt; \"TogglePumpAction\":\n        \"\"\"Factory function for a `TogglePumpAction`.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n        Returns:\n            TogglePumpAction: the action.\n        \"\"\"\n        return TogglePumpAction(target=target)\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        # check if pump is in a failure state\n        pump_id = f\"pump-{self.target}-button\"\n        # 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 2 (cannot toggle if the pump is in failure)\n        new_state = \"(1-{data-state})%3\"\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='{pump_id}']\",\n                attrs={\n                    \"data-state\": Expr(new_state),\n                    # GOTCHA! data-state will be updated first (from above) and used to update fill! the order matters here.\n                    \"fill\": Expr(\"{data-colors}[{data-state}]\"),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpAction.new","title":"<code>new(target)</code>  <code>staticmethod</code>","text":"<p>Factory function for a <code>TogglePumpAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump</p> required <p>Returns:</p> Name Type Description <code>TogglePumpAction</code> <code>TogglePumpAction</code> <p>the action.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new(\n    target: int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"],\n) -&gt; \"TogglePumpAction\":\n    \"\"\"Factory function for a `TogglePumpAction`.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n    Returns:\n        TogglePumpAction: the action.\n    \"\"\"\n    return TogglePumpAction(target=target)\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpFailureAction","title":"<code>TogglePumpFailureAction</code>","text":"<p>               Bases: <code>PumpAction</code></p> <p>Action class that will cause a pump failure (on/off -&gt; failure, failure -&gt; off).</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>class TogglePumpFailureAction(PumpAction):\n    \"\"\"Action class that will cause a pump failure (on/off -&gt; failure, failure -&gt; off).\"\"\"\n\n    @staticmethod\n    def new(target: int) -&gt; \"TogglePumpFailureAction\":\n        \"\"\"Factory function for a `TogglePumpFailureAction`.\n\n        Args:\n            target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n        Returns:\n            TogglePumpFailureAction: the action.\n        \"\"\"\n        return TogglePumpFailureAction(target=target)\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        pump_id = f\"pump-{self.target}-button\"\n        # 0 -&gt; 2, 1 -&gt; 2, 2 -&gt; 0\n        new_state = \"2 * (1 - {data-state} // 2)\"\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='{pump_id}']\",\n                attrs={\n                    \"data-state\": Expr(new_state),\n                    # GOTCHA! data-state will be updated first (from above) and used to update fill! the order matters here.\n                    \"fill\": Expr(\"{data-colors}[{data-state}]\"),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/resource_management/resource_management/#matbii.tasks.resource_management.resource_management.TogglePumpFailureAction.new","title":"<code>new(target)</code>  <code>staticmethod</code>","text":"<p>Factory function for a <code>TogglePumpFailureAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | Literal['ab', 'ba', 'ca', 'ec', 'ea', 'db', 'fd', 'fb']</code> <p>target pump</p> required <p>Returns:</p> Name Type Description <code>TogglePumpFailureAction</code> <code>TogglePumpFailureAction</code> <p>the action.</p> Source code in <code>matbii\\tasks\\resource_management\\resource_management.py</code> <pre><code>@staticmethod\ndef new(target: int) -&gt; \"TogglePumpFailureAction\":\n    \"\"\"Factory function for a `TogglePumpFailureAction`.\n\n    Args:\n        target (int | Literal[\"ab\", \"ba\", \"ca\", \"ec\", \"ea\", \"db\", \"fd\", \"fb\"]): target pump\n\n    Returns:\n        TogglePumpFailureAction: the action.\n    \"\"\"\n    return TogglePumpFailureAction(target=target)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/","title":"System monitoring","text":"<p>Package that defines the matbii system monitoring task.</p>"},{"location":"reference/tasks/system_monitoring/#modules","title":"Modules","text":"<ul> <li>matbii/tasks/system_monitoring/system_monitoring.py</li> </ul>"},{"location":"reference/tasks/system_monitoring/system_monitoring/","title":"System monitoring","text":"<p>Module that implements the \"system monitoring\" task.</p> This files contains <ul> <li>avatar actuator: <code>AvatarSystemMonitoringActuator</code></li> <li>agent actuator: <code>SystemMonitoringActuator</code></li> <li>actions: [<code>TargetMoveAction</code>, <code>PerturbSliderAction</code>, <code>ResetSliderAction</code>, <code>SetSliderAction</code>, <code>SetLightAction</code>, <code>ToggleLightAction</code>]</li> </ul>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator","title":"<code>AvatarSystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class AvatarSystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the system monitoring task is enabled. It allows the user to control the lights and sliders in this task.\"\"\"\n\n    def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n        \"\"\"Constructor.\n\n        Args:\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._get_light_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n        )\n        self._get_slider_targets = partial(\n            AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n        )\n\n    @attempt\n    def attempt_mouse_event(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n        \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n        Effects:\n        - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n        - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n        Args:\n            user_action (MouseButtonEvent): the users mouse button action.\n\n        Returns:\n            list[SetLightAction | SetSliderAction]: the action to be attempted\n        \"\"\"\n        assert isinstance(user_action, MouseButtonEvent)\n        # always include the user action as it needs to be logged\n        actions = [user_action]\n        if (\n            user_action.status == MouseButtonEvent.DOWN\n            and user_action.button == MouseButtonEvent.BUTTON_LEFT\n        ):\n            actions.extend(self._get_light_actions(user_action))\n            actions.extend(self._get_slider_actions(user_action))\n        return actions\n\n    def _get_light_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"ToggleLightAction\"]:\n        targets = [int(x) for x in self._get_light_targets(user_action.target)]\n        return [ToggleLightAction(target=target) for target in targets]\n\n    def _get_slider_actions(\n        self, user_action: MouseButtonEvent\n    ) -&gt; list[\"SetSliderAction\"]:\n        targets = [int(x) for x in self._get_slider_targets(user_action.target)]\n        return [ResetSliderAction(target=target) for target in targets]\n\n    @staticmethod\n    def get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n        \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n        Args:\n            pattern (str): pattern to test.\n            targets (list[str]): targets to search.\n\n        Returns:\n            list[str]: matching targets.\n        \"\"\"\n\n        def _get():\n            for target in targets:\n                match = re.match(pattern, target)\n                if match:\n                    target = match.group(1)\n                    yield target\n\n        return list(_get())\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def __init__(self, *args: list[Any], **kwargs: dict[str, Any]):\n    \"\"\"Constructor.\n\n    Args:\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._get_light_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"light-(\\d+)-button\"\n    )\n    self._get_slider_targets = partial(\n        AvatarSystemMonitoringActuator.get_click_targets, r\"slider-(\\d+)-button\"\n    )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator.attempt_mouse_event","title":"<code>attempt_mouse_event(user_action)</code>","text":"<p>Attempt method that takes a <code>MouseButtonEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>This will attempt either a <code>SetLightAction</code> or a <code>SetSliderAction</code> depending on what svg element was clicked (assuming the mouse event registers as a click).</p> <p>Effects: - <code>SetLightAction</code>: will always set the light to its preferred (acceptable) state. - <code>SetSliderAction</code> will reset the slider to its preferred (acceptable) state (which is the central position), see <code>ResetSliderAction</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>MouseButtonEvent</code> <p>the users mouse button action.</p> required <p>Returns:</p> Type Description <code>list[Union[SetLightAction, SetSliderAction]]</code> <p>list[SetLightAction | SetSliderAction]: the action to be attempted</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef attempt_mouse_event(\n    self, user_action: MouseButtonEvent\n) -&gt; list[Union[\"SetLightAction\", \"SetSliderAction\"]]:\n    \"\"\"Attempt method that takes a `MouseButtonEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    This will attempt either a `SetLightAction` or a `SetSliderAction` depending on what svg element was clicked (assuming the mouse event registers as a click).\n\n    Effects:\n    - `SetLightAction`: will always set the light to its preferred (acceptable) state.\n    - `SetSliderAction` will reset the slider to its preferred (acceptable) state (which is the central position), see `ResetSliderAction`.\n\n    Args:\n        user_action (MouseButtonEvent): the users mouse button action.\n\n    Returns:\n        list[SetLightAction | SetSliderAction]: the action to be attempted\n    \"\"\"\n    assert isinstance(user_action, MouseButtonEvent)\n    # always include the user action as it needs to be logged\n    actions = [user_action]\n    if (\n        user_action.status == MouseButtonEvent.DOWN\n        and user_action.button == MouseButtonEvent.BUTTON_LEFT\n    ):\n        actions.extend(self._get_light_actions(user_action))\n        actions.extend(self._get_slider_actions(user_action))\n    return actions\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.AvatarSystemMonitoringActuator.get_click_targets","title":"<code>get_click_targets(pattern, targets)</code>  <code>staticmethod</code>","text":"<p>Extras the <code>id</code> field of a target in <code>targets</code> if it matches the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to test.</p> required <code>targets</code> <code>list[str]</code> <p>targets to search.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: matching targets.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef get_click_targets(pattern: str, targets: list[str]) -&gt; list[str]:\n    \"\"\"Extras the `id` field of a target in `targets` if it matches the pattern.\n\n    Args:\n        pattern (str): pattern to test.\n        targets (list[str]): targets to search.\n\n    Returns:\n        list[str]: matching targets.\n    \"\"\"\n\n    def _get():\n        for target in targets:\n            match = re.match(pattern, target)\n            if match:\n                target = match.group(1)\n                yield target\n\n    return list(_get())\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetLightAction","title":"<code>SetLightAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will update a light's state (on=1 or off=0).</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class SetLightAction(XMLUpdateQuery):\n    \"\"\"Action class that will update a light's state (on=1 or off=0).\"\"\"\n\n    target: int  # the target light\n    state: int  # the new state of the light\n\n    OFF: ClassVar[int] = 0  # off state\n    ON: ClassVar[int] = 1  # on state\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value):\n        if value not in VALID_LIGHT_IDS:\n            raise ValueError(f\"`target` {value} must be one of {VALID_LIGHT_IDS}\")\n        return value\n\n    @field_validator(\"state\", mode=\"before\")\n    @classmethod\n    def _validate_state(cls, value: int | str):\n        if isinstance(value, str):\n            value = SetLightAction.coerce_light_state(value)\n        if value not in (SetLightAction.OFF, SetLightAction.ON):\n            raise ValueError(\n                f\"Invalid state `{value}` must be one of {[SetLightAction.OFF, SetLightAction.ON]}\"\n            )\n        return value\n\n    @staticmethod\n    def coerce_light_state(value: str | int):\n        \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1.\n\n        Args:\n            value (str | int): the value to coerce valid values: 0,1,\"on\",\"off.\n\n        Raises:\n            ValueError: if the given state cannot be  coerced.\n\n        Returns:\n            int: the integer state.\n        \"\"\"\n        if isinstance(value, int):\n            return value\n        if value == \"on\":\n            return SetLightAction.ON\n        elif value == \"off\":\n            return SetLightAction.OFF\n        else:\n            raise ValueError(f\"Invalid state `{value}` must be one of ['on', 'off']\")\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='light-{self.target}-button']\",\n                attrs={\n                    \"data-state\": str(self.state),\n                    \"fill\": Expr(\"{data-colors}[{state}]\", state=self.state),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetLightAction.coerce_light_state","title":"<code>coerce_light_state(value)</code>  <code>staticmethod</code>","text":"<p>Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int</code> <p>the value to coerce valid values: 0,1,\"on\",\"off.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the given state cannot be  coerced.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>the integer state.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef coerce_light_state(value: str | int):\n    \"\"\"Coerce a state that is specified as a string to an int: \"off -&gt; 0, \"on\" -&gt; 1.\n\n    Args:\n        value (str | int): the value to coerce valid values: 0,1,\"on\",\"off.\n\n    Raises:\n        ValueError: if the given state cannot be  coerced.\n\n    Returns:\n        int: the integer state.\n    \"\"\"\n    if isinstance(value, int):\n        return value\n    if value == \"on\":\n        return SetLightAction.ON\n    elif value == \"off\":\n        return SetLightAction.OFF\n    else:\n        raise ValueError(f\"Invalid state `{value}` must be one of ['on', 'off']\")\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetSliderAction","title":"<code>SetSliderAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will update a sliders's state. The state of a slider is the integer index of one of its increments.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class SetSliderAction(XMLUpdateQuery):\n    \"\"\"Action class that will update a sliders's state. The state of a slider is the integer index of one of its increments.\"\"\"\n\n    # slider to target\n    target: int\n    # state to set, or offset from current state, or None if should reset the state.\n    state: int | None\n    # is `state` relative to the current state?\n    relative: bool = Field(default_factory=lambda: False)\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value):\n        if value not in VALID_SLIDER_IDS:\n            raise ValueError(f\"`target` {value} must be one of {VALID_LIGHT_IDS}\")\n        return value\n\n    @staticmethod\n    def acceptable_state(increments: int) -&gt; int:\n        \"\"\"Defines the acceptable state of the slider. This is the state that the slider will return to if the actions `state` field is None.\n\n        Args:\n            increments (int): the number of increments in the slider.\n\n        Returns:\n            int: the acceptable state of the slider\n        \"\"\"\n        return increments // 2 + 1\n\n    def __execute__(self, xml_state: XMLState) -&gt; Any:  # noqa\n        # get min and max values for the number of increments\n        inc_target = f\"slider-{self.target}-incs\"\n        but_target = f\"slider-{self.target}-button\"\n        response = xml_state.select(\n            select(\n                xpath=f\"//*[@id='{inc_target}']/svg:line\",\n                attrs=[\"y1\", \"data-state\"],\n            )\n        )\n        states = {x[\"data-state\"]: x[\"y1\"] for x in response}\n        # TODO check that these are all the same?\n        inc_size = states[2] - states[1]\n        min_state, max_state = (min(states.keys()), max(states.keys()) - 1)\n        state = self.state\n        if state is None:\n            self.relative = False\n            state = SetSliderAction.acceptable_state(max_state)\n\n        # we select the parent of the button node because it contains the state and position to update\n        xpath_parent = f\"//*[@id='{but_target}']/parent::node()\"\n        if self.relative:\n            # update the state relative to the current state\n            response = xml_state.select(\n                select(\n                    xpath=xpath_parent,\n                    attrs=[\"data-state\"],\n                )\n            )\n            assert len(response) == 1\n            state = response[0][\"data-state\"] + self.state\n\n        # new state should not overflow\n        state = min(max(min_state, state), max_state)\n        new_y = states[state] - inc_size\n        return xml_state.update(\n            update(\n                xpath=xpath_parent,\n                attrs={\"data-state\": state, \"y\": new_y},\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SetSliderAction.acceptable_state","title":"<code>acceptable_state(increments)</code>  <code>staticmethod</code>","text":"<p>Defines the acceptable state of the slider. This is the state that the slider will return to if the actions <code>state</code> field is None.</p> <p>Parameters:</p> Name Type Description Default <code>increments</code> <code>int</code> <p>the number of increments in the slider.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the acceptable state of the slider</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@staticmethod\ndef acceptable_state(increments: int) -&gt; int:\n    \"\"\"Defines the acceptable state of the slider. This is the state that the slider will return to if the actions `state` field is None.\n\n    Args:\n        increments (int): the number of increments in the slider.\n\n    Returns:\n        int: the acceptable state of the slider\n    \"\"\"\n    return increments // 2 + 1\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator","title":"<code>SystemMonitoringActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the system monitoring task.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@agent_actuator\nclass SystemMonitoringActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the system monitoring task.\"\"\"\n\n    @attempt\n    def on_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"on\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.ON)\n\n    @attempt\n    def off_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Switch the `target` light to the \"off\" state.\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return SetLightAction(target=target, state=SetLightAction.OFF)\n\n    @attempt\n    def toggle_light(self, target: int) -&gt; \"SetLightAction\":\n        \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n        Args:\n            target (int): the integer `id` of the target light (1 or 2).\n\n        Returns:\n            SetLightAction: the action\n        \"\"\"\n        return ToggleLightAction(target=target)\n\n    @attempt\n    def perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n        \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n        Args:\n            target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n        Returns:\n            SetSliderAction: the action\n        \"\"\"\n        state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n        return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.off_light","title":"<code>off_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"off\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef off_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"off\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.OFF)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.on_light","title":"<code>on_light(target)</code>","text":"<p>Switch the <code>target</code> light to the \"on\" state.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef on_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Switch the `target` light to the \"on\" state.\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return SetLightAction(target=target, state=SetLightAction.ON)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.perturb_slider","title":"<code>perturb_slider(target)</code>","text":"<p>Perturb the <code>target</code> slider by +/- 1 slot.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef perturb_slider(self, target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    state = 2 * random.randint(0, 1) - 1  # randomly perturb +/- 1\n    return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.SystemMonitoringActuator.toggle_light","title":"<code>toggle_light(target)</code>","text":"<p>Toggle the <code>target</code> light (on-&gt;off, off-&gt;on).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target light (1 or 2).</p> required <p>Returns:</p> Name Type Description <code>SetLightAction</code> <code>SetLightAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>@attempt\ndef toggle_light(self, target: int) -&gt; \"SetLightAction\":\n    \"\"\"Toggle the `target` light (on-&gt;off, off-&gt;on).\n\n    Args:\n        target (int): the integer `id` of the target light (1 or 2).\n\n    Returns:\n        SetLightAction: the action\n    \"\"\"\n    return ToggleLightAction(target=target)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.ToggleLightAction","title":"<code>ToggleLightAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will toggle a light's state from on-&gt;off and off-&gt;on.</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>class ToggleLightAction(XMLUpdateQuery):\n    \"\"\"Action class that will toggle a light's state from on-&gt;off and off-&gt;on.\"\"\"\n\n    target: int\n\n    @field_validator(\"target\", mode=\"before\")\n    @classmethod\n    def _validate_target(cls, value):\n        if value not in VALID_LIGHT_IDS:\n            raise ValueError(f\"`target` {value} must be one of {VALID_LIGHT_IDS}\")\n        return value\n\n    def __execute__(self, xml_state: XMLState):  # noqa\n        xml_state.update(\n            update(\n                xpath=f\"//*[@id='light-{self.target}-button']\",\n                attrs={\n                    \"data-state\": Expr(\"1-{data-state}\"),\n                    # GOTCHA! data-state will be updated first (above) and used to update fill! the dict order matters here.\n                    \"fill\": Expr(\"{data-colors}[{data-state}]\"),\n                },\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.PerturbSliderAction","title":"<code>PerturbSliderAction(target)</code>","text":"<p>Perturb the <code>target</code> slider by +/- 1 slot.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def PerturbSliderAction(target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Perturb the `target` slider by +/- 1 slot.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    state = random.randint(0, 1) * 2 - 1\n    return SetSliderAction(target=target, state=state, relative=True)\n</code></pre>"},{"location":"reference/tasks/system_monitoring/system_monitoring/#matbii.tasks.system_monitoring.system_monitoring.ResetSliderAction","title":"<code>ResetSliderAction(target)</code>","text":"<p>Reset the <code>target</code> slider to its central position.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int</code> <p>the integer <code>id</code> of the target slider (1, 2, 3 or 4).</p> required <p>Returns:</p> Name Type Description <code>SetSliderAction</code> <code>SetSliderAction</code> <p>the action</p> Source code in <code>matbii\\tasks\\system_monitoring\\system_monitoring.py</code> <pre><code>def ResetSliderAction(target: int) -&gt; \"SetSliderAction\":\n    \"\"\"Reset the `target` slider to its central position.\n\n    Args:\n        target (int): the integer `id` of the target slider (1, 2, 3 or 4).\n\n    Returns:\n        SetSliderAction: the action\n    \"\"\"\n    return SetSliderAction(target=target, state=None, relative=False)\n</code></pre>"},{"location":"reference/tasks/tracking/","title":"Tracking","text":"<p>Package that defines the matbii tracking task.</p>"},{"location":"reference/tasks/tracking/#modules","title":"Modules","text":"<ul> <li>matbii/tasks/tracking/tracking.py</li> </ul>"},{"location":"reference/tasks/tracking/tracking/","title":"Tracking","text":"<p>Module that implements the \"tracking\" task.</p> This files contains <ul> <li>avatar actuator: <code>AvatarTrackingActuator</code></li> <li>agent actuator: <code>TrackingActuator</code></li> <li>actions: [<code>TargetMoveAction</code>]</li> </ul>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator","title":"<code>AvatarTrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class AvatarTrackingActuator(Actuator):\n    \"\"\"Actuator class that should be added to the Avatar when the tracking task is enabled. It allows the user to control the \"target\" in this task.\"\"\"\n\n    def __init__(\n        self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            target_speed (float): the speed of the target (svg units per second).\n            args (list[Any], optional): additional optional arguments.\n            kwargs (dict[Any], optional): additional optional keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._keys_pressed = set()\n        self._prev_time = time.time()\n        self._target_speed = target_speed\n\n    def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n        \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n        Returns:\n            list[TargetMoveAction]: the action\n        \"\"\"\n        current_time = time.time()\n        # this will contain the user action (KeyEvent)\n        actions = []\n        if len(self._keys_pressed) &gt; 0:\n            # compute speed based on time that has passed\n            dt = current_time - self._prev_time\n            speed = self._target_speed * dt\n            # this will be normalised when the action is executed\n            result = [0, 0]\n            # compute the movement action based on the currently pressed keys\n            for key in self._keys_pressed:\n                direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n                result[0] += direction[0]\n                result[1] += direction[1]\n            if result[0] != 0 or result[1] != 0:\n                actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n        self._prev_time = current_time\n        return actions\n\n    @attempt\n    def attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n        \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n        Args:\n            user_action (KeyEvent): the users keyboard action\n\n        Returns:\n            list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n        \"\"\"\n        if user_action.key.lower() in DEFAULT_KEY_BINDING:\n            if user_action.status == KeyEvent.UP:\n                self._keys_pressed.remove(user_action.key)\n            elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n                self._keys_pressed.add(user_action.key)\n        return []  # these will be recorded by the DefaultActuator\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator.__attempt__","title":"<code>__attempt__()</code>","text":"<p>Attempt method that will attempt a <code>TargetMoveAction</code> to move the target according to the users input (if it has been provided since the last call to this method).</p> <p>Returns:</p> Type Description <code>list[TargetMoveAction]</code> <p>list[TargetMoveAction]: the action</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __attempt__(self) -&gt; list[\"TargetMoveAction\"]:\n    \"\"\"Attempt method that will attempt a `TargetMoveAction` to move the target according to the users input (if it has been provided since the last call to this method).\n\n    Returns:\n        list[TargetMoveAction]: the action\n    \"\"\"\n    current_time = time.time()\n    # this will contain the user action (KeyEvent)\n    actions = []\n    if len(self._keys_pressed) &gt; 0:\n        # compute speed based on time that has passed\n        dt = current_time - self._prev_time\n        speed = self._target_speed * dt\n        # this will be normalised when the action is executed\n        result = [0, 0]\n        # compute the movement action based on the currently pressed keys\n        for key in self._keys_pressed:\n            direction = DIRECTION_MAP[DEFAULT_KEY_BINDING[key]]\n            result[0] += direction[0]\n            result[1] += direction[1]\n        if result[0] != 0 or result[1] != 0:\n            actions.append(TargetMoveAction(direction=tuple(result), speed=speed))\n    self._prev_time = current_time\n    return actions\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator.__init__","title":"<code>__init__(target_speed=5.0, *args, **kwargs)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>target_speed</code> <code>float</code> <p>the speed of the target (svg units per second).</p> <code>5.0</code> <code>args</code> <code>list[Any]</code> <p>additional optional arguments.</p> <code>()</code> <code>kwargs</code> <code>dict[Any]</code> <p>additional optional keyword arguments.</p> <code>{}</code> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>def __init__(\n    self, target_speed: float = 5.0, *args: list[Any], **kwargs: dict[str, Any]\n):\n    \"\"\"Constructor.\n\n    Args:\n        target_speed (float): the speed of the target (svg units per second).\n        args (list[Any], optional): additional optional arguments.\n        kwargs (dict[Any], optional): additional optional keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._keys_pressed = set()\n    self._prev_time = time.time()\n    self._target_speed = target_speed\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.AvatarTrackingActuator.attempt_key_event","title":"<code>attempt_key_event(user_action)</code>","text":"<p>Attempt method that takes a <code>KeyEvent</code> as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>KeyEvent</code> <p>the users keyboard action</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>an empty list (no action is taken by this attempt method, see <code>AvatarTrackingActuator.__attempt__</code>.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef attempt_key_event(self, user_action: KeyEvent) -&gt; list:\n    \"\"\"Attempt method that takes a `KeyEvent` as input from the user. It is up to the avatar to provide this event to this actuator. The information is essential if the user is to control this task.\n\n    Args:\n        user_action (KeyEvent): the users keyboard action\n\n    Returns:\n        list: an empty list (no action is taken by this attempt method, see `AvatarTrackingActuator.__attempt__`.\n    \"\"\"\n    if user_action.key.lower() in DEFAULT_KEY_BINDING:\n        if user_action.status == KeyEvent.UP:\n            self._keys_pressed.remove(user_action.key)\n        elif user_action.status in (KeyEvent.DOWN, KeyEvent.HOLD):\n            self._keys_pressed.add(user_action.key)\n    return []  # these will be recorded by the DefaultActuator\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TargetMoveAction","title":"<code>TargetMoveAction</code>","text":"<p>               Bases: <code>XMLUpdateQuery</code></p> <p>Action class that will update the tracking target position.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class TargetMoveAction(XMLUpdateQuery):\n    \"\"\"Action class that will update the tracking target position.\"\"\"\n\n    direction: tuple[float, float]\n    speed: float\n\n    @field_validator(\"direction\", mode=\"before\")\n    @classmethod\n    def _validate_direction(cls, value):\n        if isinstance(value, list):\n            value = tuple(value)  # a list is ok, convert it to a tuple\n        if isinstance(value, tuple):\n            if len(value) == 2:\n                # normalise the direction\n                d = math.sqrt(value[0] ** 2 + value[1] ** 2)\n                if d == 0:\n                    return (0.0, 0.0)\n                return (float(value[0]) / d, float(value[1]) / d)\n        raise ValueError(f\"Invalid direction {value}, must be Tuple[float,float].\")\n\n    @field_validator(\"speed\", mode=\"before\")\n    @classmethod\n    def _validate_speed(cls, value):\n        return float(value)\n\n    def __execute__(self, state: XMLState):  # noqa\n        if self.direction == (0.0, 0.0):\n            LOGGER.warning(\n                f\"Attempted {TargetMoveAction.__name__} with direction (0,0)\",\n            )\n            return\n        dx = self.direction[0] * self.speed\n        dy = self.direction[1] * self.speed\n        # get properties of the tracking task\n        properties = state.select(\n            select(\n                xpath=\"//svg:svg/svg:svg[@id='tracking']\",\n                attrs=[\"width\", \"height\"],\n            )\n        )[0]\n        # task bounds should limit the new position\n        x1, y1 = (0.0, 0.0)\n        x2, y2 = x1 + properties[\"width\"], y1 + properties[\"height\"]\n\n        new_x = Expr(\"max(min({x} + {dx}, {x2} - {width}), {x1})\", dx=dx, x1=x1, x2=x2)\n        new_y = Expr(\"max(min({y} + {dy}, {y2} - {height}), {y1})\", dy=dy, y1=x1, y2=y2)\n        return state.update(\n            update(\n                xpath=\"//svg:svg/svg:svg/svg:svg[@id='tracking_target']\",\n                attrs=dict(x=new_x, y=new_y),\n            )\n        )\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TrackingActuator","title":"<code>TrackingActuator</code>","text":"<p>               Bases: <code>Actuator</code></p> <p>Actuator class that will be part of a <code>ScheduledAgent</code> or any other agent that controls the evolution of the tracking task.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>class TrackingActuator(Actuator):\n    \"\"\"Actuator class that will be part of a `ScheduledAgent` or any other agent that controls the evolution of the tracking task.\"\"\"\n\n    @attempt\n    def move_target(\n        self, direction: tuple[float, float] | int | float, speed: float\n    ) -&gt; \"TargetMoveAction\":\n        \"\"\"Move the tracking target in a given direction at a given speed.\n\n        Args:\n            direction (tuple[float, float] | int | float): direction to move.\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        # an angle was provided (in degrees), convert it to a direction vector\n        if isinstance(direction, int | float):\n            angle = math.radians(direction)\n            direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n\n    @attempt\n    def perturb_target(self, speed: float):\n        \"\"\"Move the tracking target in a random direction at a given speed.\n\n        Args:\n            speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n        Returns:\n            TargetMoveAction: the action to move the tracking target.\n        \"\"\"\n        angle = (random.random() * 2 - 1) * math.pi\n        direction = (math.sin(angle), math.cos(angle))\n        return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TrackingActuator.move_target","title":"<code>move_target(direction, speed)</code>","text":"<p>Move the tracking target in a given direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>tuple[float, float] | int | float</code> <p>direction to move.</p> required <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef move_target(\n    self, direction: tuple[float, float] | int | float, speed: float\n) -&gt; \"TargetMoveAction\":\n    \"\"\"Move the tracking target in a given direction at a given speed.\n\n    Args:\n        direction (tuple[float, float] | int | float): direction to move.\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    # an angle was provided (in degrees), convert it to a direction vector\n    if isinstance(direction, int | float):\n        angle = math.radians(direction)\n        direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/tasks/tracking/tracking/#matbii.tasks.tracking.tracking.TrackingActuator.perturb_target","title":"<code>perturb_target(speed)</code>","text":"<p>Move the tracking target in a random direction at a given speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>speed to move (svg units per call to this function) # TODO perhaps this should be per second!</p> required <p>Returns:</p> Name Type Description <code>TargetMoveAction</code> <p>the action to move the tracking target.</p> Source code in <code>matbii\\tasks\\tracking\\tracking.py</code> <pre><code>@attempt\ndef perturb_target(self, speed: float):\n    \"\"\"Move the tracking target in a random direction at a given speed.\n\n    Args:\n        speed (float): speed to move (svg units per call to this function) # TODO perhaps this should be per second!\n\n    Returns:\n        TargetMoveAction: the action to move the tracking target.\n    \"\"\"\n    angle = (random.random() * 2 - 1) * math.pi\n    direction = (math.sin(angle), math.cos(angle))\n    return TargetMoveAction(direction=direction, speed=speed)\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":"<p>Package defining various utilities.</p>"},{"location":"reference/utils/#matbii.utils.get_class_from_fqn","title":"<code>get_class_from_fqn(name)</code>","text":"<p>Gets a class from its fully qualified name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>type</code> <p>fully qualified name of the class.</p> Source code in <code>matbii\\utils\\__init__.py</code> <pre><code>def get_class_from_fqn(name: str) -&gt; type:\n    \"\"\"Gets a class from its fully qualified name.\n\n    Returns:\n        str : fully qualified name of the class.\n    \"\"\"\n    module_path, _, class_name = name.rpartition(\".\")\n    module = importlib.import_module(module_path)\n    return getattr(module, class_name)\n</code></pre>"}]}